# ç†è®ºè®¾è®¡
å‰å‘æ¸²æŸ“æ˜¯ï¼š**æ¯æ¸²æŸ“ä¸€ä¸ªç‰©ä½“ â†’ è®¡ç®—å®Œæ•´å…‰ç…§ â†’ è¾“å‡ºé¢œè‰²**
å»¶è¿Ÿæ¸²æŸ“æ˜¯ï¼š

1.  ç¬¬ä¸€æ­¥ï¼ˆGBuffer Passï¼‰ï¼šæ¸²æŸ“æ‰€æœ‰ç‰©ä½“ï¼ŒæŠŠå‡ ä½•ä¿¡æ¯å†™å…¥å¤šä¸ªç¼“å†²ï¼ˆGBufferï¼‰ï¼š
    ä½ç½® / æ³•çº¿ / æ¼«åå°„é¢œè‰² / é•œé¢åå°„å‚æ•° ç­‰
        
2.  ç¬¬äºŒæ­¥ï¼ˆLighting Passï¼‰ï¼šéå†å…‰æºï¼Œ**åœ¨å±å¹•ç©ºé—´**ä¸­è¿›è¡Œå…‰ç…§è®¡ç®—ï¼Œç”Ÿæˆæœ€ç»ˆé¢œè‰²

å¼€å§‹è®¾è®¡
åœ¨åŸæœ¬å‰å‘æ¸²æŸ“çš„åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬éœ€è¦
# æ”¹é€ æµç¨‹
## 1. åˆ›å»º GBuffer ç»“æ„

éœ€è¦åˆ›å»ºå¤šä¸ª FBO é¢œè‰²é™„ä»¶ï¼ˆGBufferï¼‰ï¼š
```cpp
// åˆ›å»º FBO
glGenFramebuffers(1, &gBufferFBO);
glBindFramebuffer(GL_FRAMEBUFFER, gBufferFBO);

// GBuffer åˆ†é‡
- Albedo + Specularï¼ˆRGBAï¼‰
- Normalï¼ˆRGB æˆ–ç¼–ç æˆ 2 åˆ†é‡ï¼‰
- Positionï¼ˆæˆ–æ·±åº¦ï¼‰

// æ¯ä¸ªä½¿ç”¨ glTexImage2D åˆ›å»ºå¹¶ attach åˆ° GL_COLOR_ATTACHMENTi
glFramebufferTexture2D(...);
```

å¯ä»¥è§£é‡Šä¸€ä¸‹è¿™ä¸ªå¤šä¸ªé¢œè‰²é™„ä»¶
### ä¸ºä»€ä¹ˆè¦å¤šä¸ª Color Attachmentï¼Ÿ

**å»¶è¿Ÿæ¸²æŸ“æ ¸å¿ƒæ€æƒ³æ˜¯ï¼šå…ˆæ”¶é›†â€œæè´¨ + å‡ ä½•ä¿¡æ¯â€ï¼Œç»Ÿä¸€åšå…‰ç…§**ã€‚

è¿™äº›ä¿¡æ¯æ— æ³•å¡è¿›ä¸€ä¸ªé¢œè‰²è¾“å‡ºï¼ˆColor Attachmentï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦**å¤šä¸ªé¢œè‰²ç¼“å†²ï¼ˆGBufferï¼‰**ï¼Œæ¯ä¸ªç”¨æ¥å­˜å‚¨ä¸åŒçš„ä¿¡æ¯ï¼š

`GL_COLOR_ATTACHMENT0`ï¼šAlbedo + Specularï¼Œè¡¨é¢é¢œè‰²ã€æè´¨å‚æ•°

`GL_COLOR_ATTACHMENT1`ï¼šæ³•çº¿ï¼ˆNormalï¼‰ï¼Œå…‰ç…§æ–¹å‘è®¡ç®—

`GL_COLOR_ATTACHMENT2`ï¼šä¸–ç•Œåæ ‡ / è§†ç©ºé—´ä½ç½®ï¼Œè®¡ç®—å…‰ç…§æ–¹å‘ã€è·ç¦»è¡°å‡

`GL_DEPTH_ATTACHMENT`ï¼šæ·±åº¦å€¼ï¼Œå…‰ç…§è®¡ç®—æ—¶è¿˜åŸä½ç½® / å±å¹•ç©ºé—´è£å‰ª

ğŸ‘‰ æ‰€ä»¥ï¼š
> â€œæ³•çº¿â€ã€â€œUVâ€ã€â€œé¢œè‰²â€ç­‰éƒ½è¢«**è¾“å‡ºåˆ°ä¸åŒçš„é¢œè‰² attachment ä¸­â€ï¼Œæ”¾åœ¨åŒä¸€ä¸ª FBO é‡Œã€‚

### æ˜¯ä¸æ˜¯å¤šä¸ª FBOï¼Ÿç­”æ¡ˆæ˜¯ âŒ **ä¸€ä¸ª FBO + å¤šä¸ª Color Attachment**

ä½ åªéœ€è¦ä¸€ä¸ª FBOï¼Œä½†ç»‘å®šå¤šä¸ªçº¹ç†ï¼š
```cpp
glGenFramebuffers(1, &gBufferFBO);
glBindFramebuffer(GL_FRAMEBUFFER, gBufferFBO);

// åˆ›å»ºå¤šä¸ªé¢œè‰² attachment çº¹ç†
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, ..., gAlbedoTexture);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, ..., gNormalTexture);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, ..., gPositionTexture);

// æ·±åº¦ç¼“å†²
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, ..., depthBuffer);

// å‘Šè¯‰ OpenGL ä½ ä¼šå†™å…¥è¿™å‡ ä¸ªé¢œè‰²é™„ä»¶
GLenum attachments[3] = {
  GL_COLOR_ATTACHMENT0,
  GL_COLOR_ATTACHMENT1,
  GL_COLOR_ATTACHMENT2
};
glDrawBuffers(3, attachments);
```
æ‰€ä»¥ï¼š
-   **ä¸€ä¸ª FBO**ï¼šæ•´åˆå¤šä¸ª attachment
-   **å¤šä¸ª Attachmentï¼ˆGBufferï¼‰**ï¼šç”¨äº Geometry Pass æ—¶è¾“å‡ºå¤šä¸ªæ•°æ®é€šé“
-   **æ¯ä¸ª GBuffer æ˜¯ä¸€ä¸ªè´´å›¾ï¼ˆTextureï¼‰**ï¼Œä¹‹å Lighting Pass ä¼šç”¨å®ƒä»¬ä½œä¸ºè¾“å…¥

## 2. å®ç° Geometry Passï¼ˆå†™å…¥ GBufferï¼‰

-   ä½¿ç”¨ä¸€ä¸ªæ–°çš„ Shaderï¼ˆ`geometry_pass.vert / frag`ï¼‰
    
-   è¾“å‡ºï¼š
```cpp
out vec4 gAlbedoSpec;
out vec3 gNormal;
out vec3 gPosition;
```
ä¸åšå…‰ç…§è®¡ç®—ï¼Œåªå†™æ•°æ®åˆ°å¤šä¸ªç›®æ ‡

è®°å¾—ç”¨ï¼š
```cpp
GLenum attachments[3] = {GL_COLOR_ATTACHMENT0, 1, 2};
glDrawBuffers(3, attachments);
```
è¿™é‡Œæ˜¯ **OpenGL å¤šé‡æ¸²æŸ“ç›®æ ‡ï¼ˆMRTï¼ŒMultiple Render Targetsï¼‰** çš„å…³é”®è®¾ç½®
### è¿™æ®µä»£ç çš„ä½œç”¨ï¼š

å®ƒå‘Šè¯‰ OpenGLï¼š
> â€œå½“å‰ç»‘å®šçš„ FBO ä¸Šï¼Œæˆ‘è¦æŠŠ Fragment Shader çš„å¤šä¸ªè¾“å‡ºå†™å…¥å“ªäº›é¢œè‰²é™„ä»¶ï¼ˆColor Attachmentï¼‰ã€‚â€
## åˆ†è§£è§£é‡Šï¼š

### ğŸ”¸ `GLenum attachments[3] = {GL_COLOR_ATTACHMENT0, 1, 2};`

è¿™é‡Œå®šä¹‰äº†ä¸€ä¸ªåˆ—è¡¨ï¼Œè¡¨ç¤ºæˆ‘ä»¬å‡†å¤‡â€œæ¿€æ´»â€å“ªäº› `Color Attachment`ï¼ˆé¢œè‰²è¾“å‡ºæ§½ï¼‰ã€‚

æ­£ç¡®å†™æ³•åº”è¯¥æ˜¯ï¼š
```cpp
GLenum attachments[3] = {     
GL_COLOR_ATTACHMENT0,     
GL_COLOR_ATTACHMENT1,     
GL_COLOR_ATTACHMENT2 
};
```
### `glDrawBuffers(3, attachments);`

è¿™å¥è°ƒç”¨çš„å«ä¹‰æ˜¯ï¼š

> â€œå½“å‰è¿™ä¸ª FBO ä¸­ï¼Œæˆ‘çš„ Fragment Shader è¾“å‡ºè¦å†™å…¥è¿™ä¸‰ä¸ªé¢œè‰²ç›®æ ‡ã€‚â€

æ‰€ä»¥å¦‚æœä½ åœ¨`fragment shader` ä¸­è¿™æ ·å†™ï¼š
ä¸Šé¢è¿™ä¸ªæ‰æ˜¯å®Œæ•´è¡¨è¾¾ä¸‰ä¸ªé¢œè‰²ç›®æ ‡ï¼š0ã€1ã€2ã€‚
```glsl
layout(location = 0) out vec4 gAlbedoSpec;
layout(location = 1) out vec3 gNormal;
layout(location = 2) out vec3 gPosition;
```
é‚£ä¹ˆï¼š

-   `gAlbedoSpec` â†’ å†™å…¥ `GL_COLOR_ATTACHMENT0`
-   `gNormal` â†’ å†™å…¥ `GL_COLOR_ATTACHMENT1`
-   `gPosition` â†’ å†™å…¥ `GL_COLOR_ATTACHMENT2`

è¿™æ · GBuffer çš„ä¸‰ä¸ªè´´å›¾å°±èƒ½ä¸€æ¬¡æ€§å†™å®Œï¼
ä¸**å‰å‘æ¸²æŸ“**è¿›è¡Œå¯¹æ¯”ï¼Œä¸ºä»€ä¹ˆ`fragment`è¿˜è¦`out`è´´å›¾å‡ºå»ï¼Ÿ
### å‰å‘æ¸²æŸ“ä¸­ï¼š
`Fragment Shader` æ˜¯è®¡ç®— **æœ€ç»ˆåƒç´ é¢œè‰²**ï¼Œæ‰€ä»¥ä½ é€šå¸¸ä¼šçœ‹åˆ°ï¼š
```glsl
in vec3 normal; // ä» vertex shader ä¼ å…¥çš„æ’å€¼æ•°æ®
uniform vec3 lightDir;
out vec4 FragColor; // æœ€ç»ˆé¢œè‰²

void main() {
    float NdotL = max(dot(normal, lightDir), 0.0);
    FragColor = vec4(NdotL, NdotL, NdotL, 1.0); // è¾“å‡ºäº®åº¦
}
```
è¾“å‡ºå°±æ˜¯æœ€ç»ˆå±å¹•é¢œè‰²ï¼Œå†™å…¥ color attachment 0ã€‚
### å»¶è¿Ÿæ¸²æŸ“ä¸­ï¼š
Fragment Shader ä¸å†è¾“å‡ºé¢œè‰²ç»“æœï¼Œè€Œæ˜¯**â€œå­˜å‚¨å‡ ä½•ä¿¡æ¯â€**åˆ°å¤šä¸ªç¼“å†²ä¸­ï¼ˆGBufferï¼‰ï¼š
```glsl
// æ¯ä¸ª out å¯¹åº”ä¸€ä¸ªé¢œè‰² attachmentï¼Œå†™å…¥è´´å›¾ä¸­
layout(location = 0) out vec4 gAlbedoSpec;
layout(location = 1) out vec3 gNormal;
layout(location = 2) out vec3 gPosition;

void main() {
    gAlbedoSpec = vec4(texture(diffuseMap, TexCoords).rgb, 1.0); // æè´¨é¢œè‰²
    gNormal = normalize(Normal);       // æ³•çº¿
    gPosition = FragPos;               // ä¸–ç•Œåæ ‡ or è§†ç©ºé—´åæ ‡
}
```
æ‰€ä»¥ï¼Œ
-   **è¿™äº› `out` å¹¶ä¸æ˜¯æœ€ç»ˆé¢œè‰²**
-   è€Œæ˜¯ä¸ºäº†å†™å…¥åˆ°ä½ è‡ªå·±åˆ›å»ºçš„ FBO çš„ **å¤šä¸ªè´´å›¾ï¼ˆcolor attachmentï¼‰**
-   è¿™äº›è´´å›¾å°†æ¥ä¼šä½œä¸ºè¾“å…¥ï¼Œä¼ ç»™ä¸‹ä¸€ä¸ªé˜¶æ®µï¼ˆLighting Passï¼‰

**ï¼ï¼ï¼æ³¨æ„**è¿™ä¸ªæ˜¯`geometry`çš„`fragment shader`

### ä¸ºä»€ä¹ˆè¦è¿™ä¹ˆè®¾ç½®ï¼Ÿ

å› ä¸º OpenGL é»˜è®¤åªå†™å…¥ `GL_COLOR_ATTACHMENT0`ï¼Œå¦‚æœä½ è¦**å¯ç”¨å¤šä¸ªè¾“å‡º**ï¼ˆæ¯”å¦‚å»¶è¿Ÿæ¸²æŸ“çš„ GBufferï¼‰ï¼Œå°±å¿…é¡»å‘Šè¯‰ OpenGLï¼šâ€œæˆ‘è¦å†™å…¥å¤šä¸ª attachmentâ€ã€‚

----------

### ç±»æ¯”ç†è§£ï¼š

ä½ å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆï¼š

> "æˆ‘è¿™ä¸ªå¸§ç¼“å†²æœ‰å¥½å‡ ä¸ªå†™å…¥é€šé“ï¼Œå‘Šè¯‰ OpenGLæˆ‘æƒ³å¯ç”¨å“ªå‡ ä¸ªï¼Œå¹¶ä¸” Shader ä¸­çš„è¾“å‡ºè¦æ€ä¹ˆå¯¹å·å…¥åº§ã€‚"

## 3. å®ç° Lighting Passï¼ˆå…‰ç…§è®¡ç®—ï¼‰

-   ä½¿ç”¨ä¸€ä¸ªå…¨å± Quadï¼ˆæˆ–å±å¹•åæ ‡ä¸‰è§’å½¢ï¼‰
-   ç»‘å®šä¸Šä¸€æ­¥çš„ GBuffer ä¸ºè´´å›¾è¾“å…¥
-   å¯¹æ¯ä¸ªå…‰æºæ‰§è¡Œå±å¹•ç©ºé—´å…‰ç…§ï¼š

```cpp
vec3 albedo = texture(gAlbedo, uv).rgb;
vec3 normal = texture(gNormal, uv).xyz;
vec3 pos = texture(gPosition, uv).xyz;
vec3 lightDir = normalize(lightPos - pos);
vec3 diffuse = max(dot(normal, lightDir), 0.0) * lightColor * albedo;

```
## 4. åˆæˆ Passï¼ˆTone Mapping + Gamma + åå¤„ç†ï¼‰

-   è¾“å‡ºä¸€ä¸ªæœ€ç»ˆçš„é¢œè‰² FBO ç»“æœ
-   åº”ç”¨ Gamma æ ¡æ­£ã€Bloom ç­‰åå¤„ç†

## 5. è°ƒæ•´æ·±åº¦ & ç®¡çº¿æ§åˆ¶

-   ä½ éœ€è¦åˆç†ç®¡ç† `depth buffer`ï¼ŒGBuffer Pass å†™å…¥ `depth`ï¼ŒLight Pass ä¸å†™
-   å…‰ç…§ Pass ä¸­ç¦ç”¨æ·±åº¦å†™å…¥ï¼š
```cpp
glDisable(GL_DEPTH_TEST);
glDepthMask(GL_FALSE);
```

# æ€»ç»“
æœ€ååšä¸€ä¸ªè®¾è®¡æ€»ç»“ï¼Œä»¥`phong`ä¸ºä¾‹
æˆ‘ä»¬ä¸€å…±åšäº†ä¸¤å¥—`shader`
### Geometry Passï¼ˆå†™ GBufferï¼‰
-   `geometry.vert`
    -   æŠŠæ¨¡å‹é¡¶ç‚¹ä»å±€éƒ¨åæ ‡å˜æ¢åˆ° clip space
    -   ä¼ å‡º world/eye åæ ‡ã€æ³•çº¿ã€UV
-   `geometry.frag`
   -   è¾“å‡ºï¼š
       ä½ç½®ï¼ˆgPositionï¼‰
       æ³•çº¿ï¼ˆgNormalï¼‰
      æ¼«åå°„é¢œè‰²ã€é•œé¢åå°„ç³»æ•°ï¼ˆgAlbedoSpecï¼‰

### Lighting Passï¼ˆè®¡ç®—å…‰ç…§ï¼‰

-   `light.vert`
    -   é€šå¸¸æ¸²æŸ“ `full-screen quad`ï¼Œç›´æ¥ä¼ å±å¹•åæ ‡ `UV`
-   `light.frag`
    -   è¾“å…¥ï¼š`GBuffer` ä¸­çš„è´´å›¾ï¼ˆgPosition, gNormal, gAlbedoSpecï¼‰
    -   æŒ‰ç…§ `Phong` æ¨¡å‹åœ¨å±å¹•ç©ºé—´ä¸­æ‰§è¡Œå…‰ç…§å…¬å¼
    -   è¾“å‡ºæœ€ç»ˆé¢œè‰²


# å¼€å§‹æ–½å·¥

## å®Œå–„shader
æˆ‘ä»¬ä¾æ®è®¾è®¡çš„åŸåˆ™ï¼Œä¾æ¬¡å®Œå–„ä¸€ä¸‹ä¸¤å¥—`shader`
`geometry.vert`
```glsl
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aUV;
layout (location = 2) in vec3 aNormal;
layout (location = 3) in vec3 aTangent;

out vec2 uv;
out vec3 normal;
out vec3 worldPosition;
out mat3 tbn;

uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

uniform mat3 normalMatrix;

//aPosä½œä¸ºattributeï¼ˆå±æ€§ï¼‰ä¼ å…¥shader
//ä¸å…è®¸æ›´æ”¹çš„
void main()
{
// å°†è¾“å…¥çš„é¡¶ç‚¹ä½ç½®ï¼Œè½¬åŒ–ä¸ºé½æ¬¡åæ ‡ï¼ˆ3ç»´-4ç»´ï¼‰
	vec4 transformPosition = vec4(aPos, 1.0);

	//åšä¸€ä¸ªä¸­é—´å˜é‡TransformPositionï¼Œç”¨äºè®¡ç®—å››ä½ä½ç½®ä¸modelMatrixç›¸ä¹˜çš„ä¸­é—´ç»“æœ
	transformPosition = modelMatrix * transformPosition;

	//è®¡ç®—å½“å‰é¡¶ç‚¹çš„worldPositionï¼Œå¹¶ä¸”å‘åä¼ è¾“ç»™FragmentShader
	worldPosition = transformPosition.xyz;

	gl_Position = projectionMatrix * viewMatrix * transformPosition;
	
	uv = aUV;
//	normal =  transpose(inverse(mat3(modelMatrix))) * aNormal;
	normal =  normalMatrix * aNormal;
	vec3 tangent = normalize(mat3(modelMatrix) * aTangent);
	vec3 bitangent = normalize(cross(normal, tangent));
	tbn = mat3(tangent, bitangent, normal);
}
```
`geometry.frag`
```glsl
#version 460 core

in vec2 uv;
in vec3 fragPos;
in mat3 tbn;

layout(location = 0) out vec4 gAlbedoSpec;  // RGB: albedo, A: metallic
layout(location = 1) out vec3 gNormal;
layout(location = 2) out vec3 gPosition;

uniform sampler2D albedoTex;
uniform sampler2D roughnessTex;
uniform sampler2D metallicTex;
uniform sampler2D normalTex;

void main()
{
	vec3 albedo = texture(albedoTex, uv).rgb;
	float metallic = texture(metallicTex, uv).b;

	vec3 N = texture(normalTex, uv).rgb;
	N = normalize(tbn * (N * 2.0 - 1.0));

	gPosition = fragPos;
	gNormal = N;
	gAlbedoSpec = vec4(albedo, metallic);
}

```
`light.vert`
```glsl
#version 460 core
layout (location = 0) in vec2 aPos;
out vec2 uv;

void main()
{
	uv = aPos * 0.5 + 0.5;
	gl_Position = vec4(aPos, 0.0, 1.0);
}

```
`light.frag`
```glsl
#version 460 core
out vec4 FragColor;

in vec2 uv;
in vec3 normal;
in vec3 worldPosition;
in mat3 tbn;

//ç›¸æœºä¸–ç•Œä½ç½®
uniform vec3 cameraPosition;

#include "../../common/lightStruct.glsl"

uniform sampler2D albedoTex;//ç‰©ä½“é¢œè‰²(åç…§ç‡ï¼‰
uniform sampler2D roughnessTex;//ç²—ç³™åº¦è´´å›¾
uniform sampler2D metallicTex;//é‡‘å±åº¦è´´å›¾
uniform sampler2D normalTex;//æ³•çº¿è´´å›¾

uniform PointLight pointLights[4];


#define PI 3.141592653589793

//NDFï¼šÎ±æœ¬åº”è¯¥è¡¨ç¤ºç²—ç³™åº¦ï¼ˆroughnessï¼‰ï¼ŒÎ±= r^2ï¼Œä¾¿äºç¾æœ¯è°ƒæ§
float NDF_GGX(vec3 N, vec3 H, float roughness){
	float a = roughness * roughness;
	float a2 = a*a;
	float NdotH = max(dot(N,H), 0.0);

	float num = a2;
	float denom =PI * (NdotH * NdotH *(a2 - 1.0) + 1.0);//åˆ†æ¯

	denom = max(denom, 0.0001);//ä¸èƒ½ä¸º0

	return num / denom;
}

//Geometry
float GeometrySchlickGGX(float NdotV, float roughness){
	float r = (roughness + 1.0);
	float k = r * r / 8.0;

	float num = NdotV;
	float denom = NdotV * (1.0 - k) + k;

	denom = max(denom, 0.00001);

	return num / denom;
}

//è€ƒè™‘å‡ ä½•é®è”½å’Œå‡ ä½•é˜´å½±çš„å…±åŒä½œç”¨å¾—åˆ°çš„å€¼
//æ­¤å¤„çš„Næ˜¯å®å¹³é¢çš„æ³•çº¿æ–¹å‘
float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness){
	float NdotV = max(dot(N,V),0.0);
	float NdotL = max(dot(N,L),0.0);

	float ggx1 = GeometrySchlickGGX(NdotV, roughness);
	float ggx2 = GeometrySchlickGGX(NdotL, roughness);

	return ggx1 * ggx2;
}

//Fresnel
vec3 fresnelSchlick(vec3 F0, float HdotV){
	return F0 + (1.0 - F0) * pow((1.0 - HdotV), 5.0);
}


void main()
{
	//1 å‡†å¤‡é€šç”¨æ•°æ®
	vec3 albedo = texture(albedoTex, uv).xyz;
	//vec3 albedo = vec3(1.0, 0.0, 0.0);
	
	vec3 V = normalize(cameraPosition - worldPosition);

	vec3 N = texture(normalTex, uv).xyz;
	N = N * 2.0 - 1.0;
	N = normalize(tbn * N);

	float metallic = texture(metallicTex, uv).b;
	float roughness = texture(roughnessTex, uv).r;
	
	//2 è®¡ç®—åŸºç¡€åå°„ç‡
	vec3 F0 = vec3(0.04);
	//å› ä¸ºé‡‘å±é¢œè‰²å¯ä»¥ç”¨è‡ªèº«çš„é¢œè‰²è¡¨ç¤ºï¼Œæ‰€ä»¥ä½¿ç”¨mixå‡½æ•°ï¼Œmetallicè¶Šå¤§ï¼Œè¡¨ç¤ºé‡‘å±åº¦è¶Šé«˜ï¼Œè‡ªèº«é¢œè‰²å çš„æƒé‡å°±æ›´å¤§
	F0 = mix(F0, albedo, metallic);

	//3 éå†å››ä¸ªç‚¹å…‰æºï¼Œè®¡ç®—åå°„æ€»å…±çš„radiance
	vec3 Lo = vec3(0.0);
	for(int i = 0; i < 4; i++){
		//3.1 å‡†å¤‡è®¡ç®—å•ä¸ªå…‰æºè´¡çŒ®çš„æ—¶å€™ç”¨åˆ°çš„é€šç”¨æ•°æ®
		vec3 L = normalize(pointLights[i].position - worldPosition);
		//åŠç¨‹å‘é‡H
		vec3 H = normalize(L + V);
		float NdotL = max(dot(N,L),0.0);
		float NdotV = max(dot(N,V),0.0);

		//3.2 è®¡ç®—å…‰æºæ‰“åˆ°å¹³é¢ä¸Šçš„irradiance
		float dis = length(pointLights[i].position - worldPosition);
		float attenuation = 1.0 / (dis * dis);
		vec3 irradiance = pointLights[i].color * NdotL * attenuation;

		//3.3 è®¡ç®—NDF G Få„é¡¹å€¼
		float D = NDF_GGX(N, H, roughness);
		float G = GeometrySmith(N, V, L, roughness);
		vec3 F = fresnelSchlick(F0, max(dot(H, V), 0.0));

		//3.4 å†³å®šdiffuseä¸specularå„è‡ªæ¯”ä¾‹å¤šå°‘
		//å› ä¸ºFè€ƒè™‘çš„å°±æ˜¯æœ‰å¤šå°‘å…‰è¢«åå°„å‡ºå»äº†ï¼Œæ‰€ä»¥ç”¨æ¥åšksçš„æƒé‡åˆšåˆšå¥½
		vec3 ks = F;
		vec3 kd = vec3(1.0) - ks;
		//è€ƒè™‘é—®é¢˜ï¼šå¯¹äºé‡‘å±è€Œè¨€æ˜¯æ²¡æœ‰diffuseåå°„çš„ï¼
		kd *= (1.0 - metallic);

		//3.5 è®¡ç®—cook-torrance BRDFçš„å€¼
		vec3 num = D * G * F;//åˆ†å­
		float denom = max(4.0 * NdotL * NdotV, 0.0000001);//åˆ†æ¯ï¼Œè¿™é‡Œç”¨maxå‡½æ•°é˜²æ­¢åˆ†æ¯ä¸º0çš„æƒ…å†µ
		vec3 specularBRDF = num / denom; 

		//3.6 è€ƒè™‘specular + diffuseæœ€ç»ˆçš„åå°„ç»“æœ
		//æ­¤å¤„specularBRDFä¸ç”¨å†ä¹˜ä¸€æ¬¡ksï¼Œå› ä¸ºnum = D * G * Fï¼Œä»¥åŠè€ƒè™‘äº†Fé¡¹ï¼Œè€ŒF = ks
		Lo += (kd * albedo / PI + specularBRDF) * irradiance;
	}
	vec3 ambient = vec3(0.1) * albedo;
	Lo += ambient;

	FragColor = vec4(Lo, 1.0);
}
```

## æ¥ä¸‹æ¥åˆ›å»ºå¯¹åº”çš„fbo
```cpp
Framebuffer* Framebuffer::createGBufferFbo(unsigned int width, unsigned int height)
{
	Framebuffer* fb = new Framebuffer();
	unsigned int fbo;
	glGenFramebuffers(1, &fbo);
	glBindFramebuffer(GL_FRAMEBUFFER, fbo);

	// åˆ›å»ºä¸‰ä¸ª G-Buffer çš„ color attachment
	auto gPosition = Texture::createTexture(width, height, GL_RGB16F, GL_RGB, GL_FLOAT);
	auto gNormal = Texture::createTexture(width, height, GL_RGB16F, GL_RGB, GL_FLOAT);
	auto gAlbedoSpec = Texture::createTexture(width, height, GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE); // albedo.rgb + spec.a

	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, gPosition->getTexture(), 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, gNormal->getTexture(), 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, gAlbedoSpec->getTexture(), 0);

	// è®¾ç½® draw bufferï¼ˆé‡è¦ï¼‰
	GLenum attachments[3] = {
		GL_COLOR_ATTACHMENT0,
		GL_COLOR_ATTACHMENT1,
		GL_COLOR_ATTACHMENT2
	};
	glDrawBuffers(3, attachments);

	// æ·»åŠ æ·±åº¦ç¼“å†²
	auto rboDepth = Texture::createRenderBuffer(width, height, GL_DEPTH_COMPONENT);
	glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rboDepth->getTexture());

	// æ£€æŸ¥å®Œæ•´æ€§
	if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
		std::cerr << "GBuffer Framebuffer not complete!" << std::endl;

	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	fb->mFBO = fbo;
	fb->mGPosition = gPosition;
	fb->mGNormal = gNormal;
	fb->mGAlbedoSpec = gAlbedoSpec;
	fb->mDepthAttachment = rboDepth;
	fb->mWidth = width;
	fb->mHeight = height;

	return fb;
}
```
## æ¥ä¸‹æ¥åˆ›å»ºtexture
æˆ‘ä»¬æœ‰æ·±åº¦`attachment`çš„åˆ›å»ºæ–¹æ³•
ä½†æ˜¯æ²¡æœ‰å¯¹åº”å¯ä»¥
```cpp
Texture* Texture::createTexture(
	unsigned int width,
	unsigned int height,
	unsigned int internalFormat, // å¦‚ GL_RGB16F, GL_RGBA8
	unsigned int format,         // å¦‚ GL_RGB, GL_RGBA
	unsigned int type,           // å¦‚ GL_FLOAT, GL_UNSIGNED_BYTE
	unsigned int unit
) {
	Texture* tex = new Texture();
	tex->mWidth = width;
	tex->mHeight = height;
	tex->mUnit = unit;

	glGenTextures(1, &tex->mTexture);
	glActiveTexture(GL_TEXTURE0 + unit);
	glBindTexture(GL_TEXTURE_2D, tex->mTexture);

	glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, width, height, 0, format, type, NULL);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); // é¿å… GBuffer é‡‡æ ·æ¨¡ç³Š
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	return tex;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTU3MjA2OTQ4NSwxMzAzODY3NDc5LDYyNT
I4NzE4MSw0NDk5MDIyNjEsLTE3NjU0NDE3NTIsLTg1NzQ5ODg4
NCwtMTgyOTc0MjgxLDc2NzYzODIwNCw1MDM5NTk2MzFdfQ==
-->