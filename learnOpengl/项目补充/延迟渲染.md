# 理论设计
前向渲染是：**每渲染一个物体 → 计算完整光照 → 输出颜色**
延迟渲染是：

1.  第一步（GBuffer Pass）：渲染所有物体，把几何信息写入多个缓冲（GBuffer）：
    位置 / 法线 / 漫反射颜色 / 镜面反射参数 等
        
2.  第二步（Lighting Pass）：遍历光源，**在屏幕空间**中进行光照计算，生成最终颜色

开始设计
在原本前向渲染的基础上，我们需要
# 改造流程
## 1. 创建 GBuffer 结构

需要创建多个 FBO 颜色附件（GBuffer）：
```cpp
// 创建 FBO
glGenFramebuffers(1, &gBufferFBO);
glBindFramebuffer(GL_FRAMEBUFFER, gBufferFBO);

// GBuffer 分量
- Albedo + Specular（RGBA）
- Normal（RGB 或编码成 2 分量）
- Position（或深度）

// 每个使用 glTexImage2D 创建并 attach 到 GL_COLOR_ATTACHMENTi
glFramebufferTexture2D(...);
```

可以解释一下这个多个颜色附件
### 为什么要多个 Color Attachment？

**延迟渲染核心思想是：先收集“材质 + 几何信息”，统一做光照**。

这些信息无法塞进一个颜色输出（Color Attachment），所以我们需要**多个颜色缓冲（GBuffer）**，每个用来存储不同的信息：

`GL_COLOR_ATTACHMENT0`：Albedo + Specular，表面颜色、材质参数

`GL_COLOR_ATTACHMENT1`：法线（Normal），光照方向计算

`GL_COLOR_ATTACHMENT2`：世界坐标 / 视空间位置，计算光照方向、距离衰减

`GL_DEPTH_ATTACHMENT`：深度值，光照计算时还原位置 / 屏幕空间裁剪

👉 所以：
> “法线”、“UV”、“颜色”等都被**输出到不同的颜色 attachment 中”，放在同一个 FBO 里。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTcxOTIyODU3Niw1MDM5NTk2MzFdfQ==
-->