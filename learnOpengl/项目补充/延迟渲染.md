# 理论设计
前向渲染是：**每渲染一个物体 → 计算完整光照 → 输出颜色**
延迟渲染是：

1.  第一步（GBuffer Pass）：渲染所有物体，把几何信息写入多个缓冲（GBuffer）：
    位置 / 法线 / 漫反射颜色 / 镜面反射参数 等
        
2.  第二步（Lighting Pass）：遍历光源，**在屏幕空间**中进行光照计算，生成最终颜色

开始设计
在原本前向渲染的基础上，我们需要
# 改造流程
## 1. 创建 GBuffer 结构

需要创建多个 FBO 颜色附件（GBuffer）：
```cpp
// 创建 FBO
glGenFramebuffers(1, &gBufferFBO);
glBindFramebuffer(GL_FRAMEBUFFER, gBufferFBO);

// GBuffer 分量
- Albedo + Specular（RGBA）
- Normal（RGB 或编码成 2 分量）
- Position（或深度）

// 每个使用 glTexImage2D 创建并 attach 到 GL_COLOR_ATTACHMENTi
glFramebufferTexture2D(...);
```

可以解释一下这个多个颜色附件
### 为什么要多个 Color Attachment？

**延迟渲染核心思想是：先收集“材质 + 几何信息”，统一做光照**。

这些信息无法塞进一个颜色输出（Color Attachment），所以我们需要**多个颜色缓冲（GBuffer）**，每个用来存储不同的信息：

`GL_COLOR_ATTACHMENT0`：Albedo + Specular，表面颜色、材质参数

`GL_COLOR_ATTACHMENT1`：法线（Normal），光照方向计算

`GL_COLOR_ATTACHMENT2`：世界坐标 / 视空间位置，计算光照方向、距离衰减

`GL_DEPTH_ATTACHMENT`：深度值，光照计算时还原位置 / 屏幕空间裁剪

👉 所以：
> “法线”、“UV”、“颜色”等都被**输出到不同的颜色 attachment 中”，放在同一个 FBO 里。

### 是不是多个 FBO？答案是 ❌ **一个 FBO + 多个 Color Attachment**

你只需要一个 FBO，但绑定多个纹理：
```cpp
glGenFramebuffers(1, &gBufferFBO);
glBindFramebuffer(GL_FRAMEBUFFER, gBufferFBO);

// 创建多个颜色 attachment 纹理
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, ..., gAlbedoTexture);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, ..., gNormalTexture);
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, ..., gPositionTexture);

// 深度缓冲
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, ..., depthBuffer);

// 告诉 OpenGL 你会写入这几个颜色附件
GLenum attachments[3] = {
  GL_COLOR_ATTACHMENT0,
  GL_COLOR_ATTACHMENT1,
  GL_COLOR_ATTACHMENT2
};
glDrawBuffers(3, attachments);
```
所以：
-   **一个 FBO**：整合多个 attachment
-   **多个 Attachment（GBuffer）**：用于 Geometry Pass 时输出多个数据通道
-   **每个 GBuffer 是一个贴图（Texture）**，之后 Lighting Pass 会用它们作为输入

## 2. 实现 Geometry Pass（写入 GBuffer）

-   使用一个新的 Shader（`geometry_pass.vert / frag`）
    
-   输出：
```cpp
out vec4 gAlbedoSpec;
out vec3 gNormal;
out vec3 gPosition;
```
不做光照计算，只写数据到多个目标

记得用：
```cpp
GLenum attachments[3] = {GL_COLOR_ATTACHMENT0, 1, 2};
glDrawBuffers(3, attachments);
```
这里是 **OpenGL 多重渲染目标（MRT，Multiple Render Targets）** 的关键设置
### 这段代码的作用：

它告诉 OpenGL：
> “当前绑定的 FBO 上，我要把 Fragment Shader 的多个输出写入哪些颜色附件（Color Attachment）。”
## 分解解释：

### 🔸 `GLenum attachments[3] = {GL_COLOR_ATTACHMENT0, 1, 2};`

这里定义了一个列表，表示我们准备“激活”哪些 `Color Attachment`（颜色输出槽）。

正确写法应该是：
```cpp
GLenum attachments[3] = {     
GL_COLOR_ATTACHMENT0,     
GL_COLOR_ATTACHMENT1,     
GL_COLOR_ATTACHMENT2 
};
```
### `glDrawBuffers(3, attachments);`

这句调用的含义是：

> “当前这个 FBO 中，我的 Fragment Shader 输出要写入这三个颜色目标。”

所以如果你在 fragment shader 中这样写：
上面这个才是完整表达三个颜色目标：0、1、2。
```glsl
layout(location = 0) out vec4 gAlbedoSpec;
layout(location = 1) out vec3 gNormal;
layout(location = 2) out vec3 gPosition;
```
那么：

-   `gAlbedoSpec` → 写入 `GL_COLOR_ATTACHMENT0`
-   `gNormal` → 写入 `GL_COLOR_ATTACHMENT1`
-   `gPosition` → 写入 `GL_COLOR_ATTACHMENT2`

这样 GBuffer 的三个贴图就能一次性写完！
### 为什么要这么设置？

因为 OpenGL 默认只写入 `GL_COLOR_ATTACHMENT0`，如果你要**启用多个输出**（比如延迟渲染的 GBuffer），就必须告诉 OpenGL：“我要写入多个 attachment”。

----------

### 类比理解：

你可以把它想象成：

> "我这个帧缓冲有好几个写入通道，告诉 OpenGL我想启用哪几个，并且 Shader 中的输出要怎么对号入座。"

## 3. 实现 Lighting Pass（光照计算）

-   使用一个全屏 Quad（或屏幕坐标三角形）
-   绑定上一步的 GBuffer 为贴图输入
-   对每个光源执行屏幕空间光照：

```cpp
vec3 albedo = texture(gAlbedo, uv).rgb;
vec3 normal = texture(gNormal, uv).xyz;
vec3 pos = texture(gPosition, uv).xyz;
vec3 lightDir = normalize(lightPos - pos);
vec3 diffuse = max(dot(normal, lightDir), 0.0) * lightColor * albedo;

```
## 4. 合成 Pass（Tone Mapping + Gamma + 后处理）

-   输出一个最终的颜色 FBO 结果
-   应用 Gamma 校正、Bloom 等后处理

## 5. 调整深度 & 管线控制

-   你需要合理管理 `depth buffer`，GBuffer Pass 写入 `depth`，Light Pass 不写
-   光照 Pass 中禁用深度写入：
```cpp
glDisable(GL_DEPTH_TEST);
glDepthMask(GL_FALSE);
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbNzkxNjkwMDkwLC04NTc0OTg4ODQsLTE4Mj
k3NDI4MSw3Njc2MzgyMDQsNTAzOTU5NjMxXX0=
-->