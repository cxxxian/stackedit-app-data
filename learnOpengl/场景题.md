# 在开放世界中一条及远距离的射线的碰撞检测有什么优化策略
开放世界里远距离射线碰撞检测，面对海量物体和极大空间，常用优化策略主要是**尽快排除绝大多数无关物体**，减少实际检测计算。几个关键方法：

-   **层级加速结构**  
    使用 BVH、八叉树（Octree）、KD树等空间层级结构，快速锁定射线路径经过的空间区块，只检测相关区块里的物体。
    
-   **视锥剔除和距离剔除**  
    根据射线方向和距离限制，剔除离射线太远或者超出最大检测范围的物体。
    
-   **分段射线检测（Ray Marching / Ray Stepping）**  
    把射线分成一段段区间，先用简单几何体（如包围球、包围盒）做粗略检测，排除大块空白区域，再逐步细化检测。
    
-   **粗略代理体检测**  
    先用简单形状（AABB、包围球、胶囊）判断碰撞可能性，只有命中才做精细网格检测。
    
-   **空间哈希或网格加速**  
    将场景划分为固定大小网格，射线只检测经过的格子里的物体，避免全局遍历。
    
-   **多级 LOD / Proxy**  
    远处物体用简化模型甚至贴图代理检测，近距离才用高精度模型。
    
-   **异步检测和缓存**  
    远距离检测允许一定延迟，且缓存最近射线检测结果，减少重复计算。

# 在大世界中很多条很短光线的碰检测有什么优化策略
大世界里大量**短射线**（比如武器近战检测、视线检测、小范围感知）碰撞优化，主要思路是快速剔除大部分无关物体，减少检测次数，具体方法：

-   **空间分区加速结构**  
    使用八叉树、四叉树或均匀网格，把场景划分成小区块。短射线只检测所在区块及邻近区块，避免全局搜索。
    
-   **网格哈希（Spatial Hashing）**  
    用哈希表存储空间内物体，射线检测时只查对应哈希桶，支持动态场景且速度快。
    
-   **批量剔除（Broad Phase）**  
    先用简单包围盒（AABB）快速筛选潜在碰撞物，只有候选对象才做精细检测。
    
-   **碰撞层过滤（Layer Mask）**  
    通过层级规则跳过不相关物体，降低检测对数。
    
-   **连续碰撞检测（CCD）优化**  
    对高速短射线，结合运动学预测减少穿透和遗漏。
    
-   **多线程和GPU加速**  
    利用多核或Compute Shader并行处理大量射线，提高吞吐。
    
-   **缓存和复用**  
    对场景变化不大区域，缓存最近检测结果，减少重复计算。
    
# 实现一个单例模式

```cpp
class Singleton {
private:
    Singleton() {}                      // 构造函数私有，防止外部实例化
    ~Singleton() {}
    Singleton(const Singleton&) = delete;            // 禁止拷贝构造
    Singleton& operator=(const Singleton&) = delete; // 禁止赋值

public:
    static Singleton& getInstance() {
        static Singleton instance;     // 局部静态变量，线程安全且懒加载（C++11起）
        return instance;
    }

    void doSomething() {
        // 业务方法
    }
};
```
调用示例：
```cpp
Singleton::getInstance().doSomething();
```
这样保证整个程序运行期间只有一个 `Singleton` 实例。需要线程安全的懒初始化，且拷贝和赋值都被禁用了

= delete，可以让这个方法无法被使用

# 在延迟渲染中，如果场景很大、光源分布在不同地方，  那每个像素如何知道它应该被哪些光源照亮？不同地方怎么处理着色？

### 延迟渲染的基本流程回顾
-   **第一步：G-Buffer 阶段（几何通道）**  
    渲染每个像素时，存储它的材质信息，比如：
    
    -   世界坐标位置
        
    -   法线
        
    -   漫反射颜色、镜面反射等参数
        
-   **第二步：Lighting 阶段（光照）**  
    使用 G-Buffer 中的这些信息，来“模拟每个像素被光照照亮的情况”。
    
### 那问题来了：如果一个场景很大、光源分布不同区域…

怎么确定某个像素应该被哪些光源影响？  
因为你不可能让每个像素都去遍历上百个光源吧？

## 答案：我们做**光源剔除（Light Culling）**！

### 主要方法有：

----------

### 屏幕空间划分：**Tiled Deferred Shading（瓦片延迟渲染）**

-   把屏幕划成小块（比如每个 tile 是 16×16 像素）
    
-   对每个 tile，找出哪些光源可能影响这个区域
    
-   每个像素只用处理“对应 tile 的光源列表”，大大减少遍历数量
    

✅ 优点：快，适合很多小光源  
✅ 很多现代游戏都用它

----------

### ② 三维空间划分：**Clustered Deferred Shading（分簇延迟渲染）**

-   不只是按屏幕划分，而是按 **3D view-space** 分成小块（cluster）
    
-   每个 cluster 保存可能影响的光源列表
    
-   像素着色时根据其位置归属 cluster，然后只处理该 cluster 的光源
    

✅ 优点：比 tiled 更细、支持体积光照等高级效果

----------

### ③ 距离或范围过滤（简单光照剔除）

-   每个像素着色时，遍历所有光源，但只处理“距离它比较近”的
    
-   通常只适合少量光源的场景
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyMzgwMjY0OTEsLTIwMTc1NzQ5NjJdfQ
==
-->