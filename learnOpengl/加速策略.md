# 空间加速
## AABB
## KD树和BVH树的区别，优缺点

### KD树（k-d Tree）
### 核心思想：

-   是一种 **基于空间划分（Spatial Partitioning）** 的二叉树。
-   每个节点都将空间划分为两个子区域，划分面与坐标轴对齐（Axis-Aligned）。
-   每个叶子节点保存包含在该空间的**原始图元**（如三角形）。

### 优点：

-   查询速度快，尤其适合大量小图元、精细碰撞。
-   空间分得非常细，适合近距离光线追踪。
    

### 缺点：

-   三角形可能被切成多个部分，导致结构冗余。
-   动态场景效率差，难以更新（重构开销大）。

**解决问题**：如果kd树一个三角形被分在两个区域里面了，会怎么样吗
### 问题背景：

KD 树是按空间划分的，比如每一层用一个平面把空间一分为二。  
但有些三角形（或物体）**跨越了这个分割平面**：

#### 那么这个三角形到底属于左子树还是右子树？
答案是：**它同时属于两个子树**，**被复制进左右两边**。

### 那会怎么样？

#### 好处：

-   查询时不漏检，光线或碰撞物体无论在左边还是右边，都能检测到这个三角形。
    
#### 坏处：

-   **三角形被复制多次**，导致：
    -   节点中图元数增多；
    -   内存使用上涨；
    -   加速结构失去部分效率（每次查询都可能多进一层树）。

### BVH树（包围盒层级）

### 核心思想：

-   是一种 **基于物体分组（Object Partitioning）** 的树结构。
-   每个节点保存一个 **包围体（AABB、OBB等）**，包含其所有子物体。
-   递归构造，叶节点保存原始图元（如三角形）。

### 优点：

-   构建简单，内存开销小。
-   动态场景友好，可以使用 refit/update 方法快速更新包围盒。
-   对大型图元支持好，不切图元。

###  缺点：
-   查询效率略低（因为包围体可能重叠）。
-   精度不如 KD 树细致。

**为什么KD树更精准**
KD树比BVH更“精准”，主要体现在它对空间划分更细致，能更严格地限制查询范围。具体来说：
-   **KD树是基于空间划分**，用平面把整个空间切成左右两个半区，不断递归细分，形成一个细粒度的空间网格。每个叶子区域空间范围非常小，光线或查询对象只会访问非常有限的空间块，减少了不相关物体的干扰。

-   **而BVH是基于物体分组**，每个节点包围一组物体的包围盒，包围盒之间可能重叠较多，查询时因为重叠区域，光线或碰撞检测可能要访问多个包围盒，导致“冗余检测”。

所以总结为一句话：
对于精度：
KD更高，剔除更多无关物体。
BVH较低，存在冗余检测。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMzI1NTI2MDRdfQ==
-->