# 空间加速
## AABB
## KD树和BVH树的区别，优缺点

### KD树（k-d Tree）
### 核心思想：

-   是一种 **基于空间划分（Spatial Partitioning）** 的二叉树。
-   每个节点都将空间划分为两个子区域，划分面与坐标轴对齐（Axis-Aligned）。
-   每个叶子节点保存包含在该空间的**原始图元**（如三角形）。

### 优点：

-   查询速度快，尤其适合大量小图元、精细碰撞。
-   空间分得非常细，适合近距离光线追踪。
    

### 缺点：

-   三角形可能被切成多个部分，导致结构冗余。
-   动态场景效率差，难以更新（重构开销大）。

**解决问题**：如果kd树一个三角形被分在两个区域里面了，会怎么样吗
### 问题背景：

KD 树是按空间划分的，比如每一层用一个平面把空间一分为二。  
但有些三角形（或物体）**跨越了这个分割平面**：

#### 那么这个三角形到底属于左子树还是右子树？
答案是：**它同时属于两个子树**，**被复制进左右两边**。

### 那会怎么样？

#### 好处：

-   查询时不漏检，光线或碰撞物体无论在左边还是右边，都能检测到这个三角形。
    
#### 坏处：

-   **三角形被复制多次**，导致：
    -   节点中图元数增多；
    -   内存使用上涨；
    -   加速结构失去部分效率（每次查询都可能多进一层树）。

### BVH树（包围盒层级）

### 核心思想：

-   是一种 **基于物体分组（Object Partitioning）** 的树结构。
-   每个节点保存一个 **包围体（AABB、OBB等）**，包含其所有子物体。
-   递归构造，叶节点保存原始图元（如三角形）。

### 优点：

-   构建简单，内存开销小。
-   动态场景友好，可以使用 refit/update 方法快速更新包围盒。
-   对大型图元支持好，不切图元。

###  缺点：
-   查询效率略低（因为包围体可能重叠）。
-   精度不如 KD 树细致。

**为什么KD树更精准**
KD树比BVH更“精准”，主要体现在它对空间划分更细致，能更严格地限制查询范围。具体来说：
-   **KD树是基于空间划分**，用平面把整个空间切成左右两个半区，不断递归细分，形成一个细粒度的空间网格。每个叶子区域空间范围非常小，光线或查询对象只会访问非常有限的空间块，减少了不相关物体的干扰。

-   **而BVH是基于物体分组**，每个节点包围一组物体的包围盒，包围盒之间可能重叠较多，查询时因为重叠区域，光线或碰撞检测可能要访问多个包围盒，导致“冗余检测”。

所以总结为一句话：
对于精度：
KD更高，剔除更多无关物体。
BVH较低，存在冗余检测。

## 为什么 KD 树不适合动态场景？

### 1. **KD 树是基于空间划分的 → 每个三角形只能属于一个区域**

-   如果你移动一个三角形，它**可能会跨出原来的区域**
    
-   那就意味着它必须被**完全重新插入**到树中 → 很重
    
-   而且 KD 树的分割是**递归空间切割的结构** → 一改动会影响多个父子关系 → 代价极大
    

### 2. **没有“容错空间”**

-   比如一个物体刚好贴在切割面上，稍微一动就属于另一个区域了
    
-   这种结构对浮点误差/动画变化特别敏感
    

----------

## 而 BVH 就灵活很多：

### 1. **每个节点是一个包围盒（AABB）**

-   如果一个物体动了，你只需要：
    
    -   重新计算它的 AABB
        
    -   向上“更新它的祖先包围盒”
        

✔ 不需要整个重建结构  
✔ 只改它那一支 → 局部更新

### 2. **容许包围盒重叠 → 更健壮**

-   移动时可以暂时扩大包围盒
    
-   即使某个三角形“越界”，也可以暂时包进去
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjA2MTk5NjUzNywzMjU1MjYwNF19
-->