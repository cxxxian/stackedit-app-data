## C++ å¤šçº¿ç¨‹çš„åŸºæœ¬ç”¨æ³•ï¼š`std::thread`

ä» C++11 å¼€å§‹ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ `std::thread` åˆ›å»ºæ–°çº¿ç¨‹ã€‚

### ç¤ºä¾‹ï¼šåˆ›å»ºä¸€ä¸ªçº¿ç¨‹æ‰“å°æ•°å­—

```cpp
#include <iostream>
#include <thread>  
void printNumbers() {     
	for (int i = 1; i <= 5; ++i) {         
		std::cout << "å­çº¿ç¨‹è¾“å‡º: " << i << std::endl;     
	} 
}  
int main() {     
	std::thread t(printNumbers);// å¯åŠ¨æ–°çº¿ç¨‹æ‰§è¡Œ printNumbers     			
	t.join();// ç­‰å¾…çº¿ç¨‹æ‰§è¡Œå®Œæˆ     
	std::cout << "ä¸»çº¿ç¨‹ç»“æŸ" << std::endl;     
	return 0; 
}
```

### è¿è¡Œç»“æœï¼š

```makefile
å­çº¿ç¨‹è¾“å‡º: 1 
å­çº¿ç¨‹è¾“å‡º: 2
... 
ä¸»çº¿ç¨‹ç»“æŸ
```
## å¤šçº¿ç¨‹é™·é˜±ï¼š**å…±äº«æ•°æ®å’Œç«äº‰é—®é¢˜**

ä¸¤ä¸ªçº¿ç¨‹å¦‚æœåŒæ—¶è®¿é—®åŒä¸€ä»½æ•°æ®ï¼Œå°±å¯èƒ½å‡ºé”™ã€‚

### ç¤ºä¾‹ï¼ˆé”™è¯¯ç¤ºèŒƒï¼‰ï¼š

```cpp
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) counter++;// âŒ ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶ä¿®æ”¹å¯èƒ½å¯¼è‡´é”™è¯¯ 
}
```

### âœ… æ­£ç¡®å†™æ³•ï¼šåŠ é”ä¿æŠ¤å…±äº«å˜é‡

```cpp
#include <mutex>  
std::mutex mtx; 
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) {         		
		std::lock_guard<std::mutex> lock(mtx);         		
		counter++;     
	} 
}
```

> ğŸ”’ `std::mutex` å¯ä»¥ä¿æŠ¤ä¸€æ®µä»£ç åªè®©ä¸€ä¸ªçº¿ç¨‹è¿›å…¥ï¼Œé¿å…â€œæ•°æ®ç«äº‰â€ã€‚

## å¸¸ç”¨æ¦‚å¿µ

`std::thread`ï¼šå¯åŠ¨ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œå‡½æ•°
`.join()`ï¼šé˜»å¡ä¸»çº¿ç¨‹ï¼Œç­‰å­çº¿ç¨‹è·‘å®Œ
`.detach()`ï¼šåˆ†ç¦»çº¿ç¨‹ï¼Œä¸ç­‰å¾…å®ƒæ‰§è¡Œå®Œï¼ˆè°¨æ…ä½¿ç”¨ï¼‰


# ä¸é¡¹ç›®ç»“åˆï¼ˆå¼‚æ­¥åŠ è½½è´´å›¾ï¼‰
è¿™æ˜¯ä¸€æ®µæ™®é€šçš„åŠ è½½è´´å›¾æ–¹æ³•
```cpp
Texture::Texture(const std::string& path, unsigned int unit, unsigned int internalFormat) {
	mUnit = unit;

	//1 stbImage è¯»å–å›¾ç‰‡
	int channels;

	//--åè½¬yè½´
	stbi_set_flip_vertically_on_load(true);

	unsigned char* data = stbi_load(path.c_str(), &mWidth, &mHeight, &channels, STBI_rgb_alpha);

	//2 ç”Ÿæˆçº¹ç†å¹¶ä¸”æ¿€æ´»å•å…ƒç»‘å®š
	glGenTextures(1, &mTexture);
	//--æ¿€æ´»çº¹ç†å•å…ƒ--
	glActiveTexture(GL_TEXTURE0 + mUnit);
	//--ç»‘å®šçº¹ç†å¯¹è±¡--	
	glBindTexture(GL_TEXTURE_2D, mTexture);

	//3 ä¼ è¾“çº¹ç†æ•°æ®,å¼€è¾Ÿæ˜¾å­˜
	glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

	
//	glGenerateMipmap(GL_TEXTURE_2D);

	//***é‡Šæ”¾æ•°æ® 
	stbi_image_free(data);

	//4 è®¾ç½®çº¹ç†çš„è¿‡æ»¤æ–¹å¼
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);

	//5 è®¾ç½®çº¹ç†çš„åŒ…è£¹æ–¹å¼
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);//u
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);//v
}
```
### åŒºåˆ†**å“ªäº›éƒ¨åˆ†å¯ä»¥åœ¨åå°çº¿ç¨‹åšï¼Œå“ªäº›å¿…é¡»ä¸»çº¿ç¨‹åš**ï¼š
1. `stbi_load` å›¾åƒè§£ç 
âœ… å¯ä»¥
çº¯ CPU æ“ä½œï¼Œä¸ OpenGL æ— å…³

2. `glGenTextures` ç­‰ GL API
âŒ ä¸è¡Œï¼ˆé»˜è®¤ï¼‰
OpenGL ä¸Šä¸‹æ–‡åªç»‘å®šåœ¨ä¸»çº¿ç¨‹ä¸Š

3. `glTexImage2D` ä¸Šä¼  GPU
âŒ ä¸è¡Œï¼ˆåŒä¸Šï¼‰
GPU æ“ä½œå¿…é¡»ä¸»çº¿ç¨‹å®Œæˆ

4. `stbi_image_free`
âœ… å¯ä»¥
çº¯å†…å­˜é‡Šæ”¾ï¼Œéå›¾å½¢ API

æ‰€ä»¥ä»£ç é‡Œï¼Œ**åªæœ‰ `stbi_load(path)` è¿™ä¸€æ­¥å¯ä»¥æ”¾åˆ°åå°çº¿ç¨‹åš**ã€‚

**å¤šçº¿ç¨‹ç‰ˆæœ¬**ï¼š  
ä½ åªæƒ³è®©**`stbi_load` åœ¨åå°çº¿ç¨‹æ‰§è¡Œ**ï¼Œç„¶åä¸»çº¿ç¨‹å†è°ƒç”¨åŸæ¥çš„ `Texture` æ„é€ å‡½æ•°å®Œæˆä¸Šä¼ å³å¯ã€‚

----------

## æ”¹åŠ¨ç›®æ ‡ï¼š

åŸæ¥çš„ç»“æ„ï¼š

```cpp
Texture tex("brick.jpg", 0, GL_RGBA); // åŒæ­¥åŠ è½½å¹¶ä¸Šä¼ 
```

æˆ‘ä»¬è¦å˜æˆï¼š

```cpp
// åˆå§‹åŒ–é˜¶æ®µï¼ˆåªæ‰§è¡Œä¸€æ¬¡ï¼‰
Texture::loadAsync("brick.jpg", 0, GL_RGBA);

// ä¸»å¾ªç¯ä¸­æ¯å¸§æ£€æŸ¥
if (Texture::hasLoaded()) {
    std::vector<unsigned char> pixels;
    int w, h;
    Texture::getLoadedData(pixels, w, h);
    Texture tex(pixels, w, h, 0, GL_RGBA); // æ„é€ å¹¶ä¸Šä¼ 
}

```	

`texture.h`å¦‚ä¸‹ï¼š
```cpp
#pragma once
#include <string>
#include <vector>
#include <mutex>
#include <thread>
#include <atomic>

class Texture {
public:
    Texture(const std::vector<unsigned char>& pixels, int width, int height,
            unsigned int unit, unsigned int internalFormat);

    static void loadAsync(const std::string& path, unsigned int unit, unsigned int internalFormat);
    static bool hasLoaded();
    static void getLoadedData(std::vector<unsigned char>& pixels, int& w, int& h);

private:
    unsigned int mTexture = 0;
    unsigned int mUnit = 0;
    int mWidth = 0;
    int mHeight = 0;

    static std::vector<unsigned char> sPixels;
    static int sWidth, sHeight;
    static std::mutex sMutex;
    static std::atomic<bool> sReady;
};
```
`Texture.cpp`å¦‚ä¸‹ï¼š
```cpp
#define STB_IMAGE_IMPLEMENTATION
#include "Texture.h"
#include <glad/glad.h>
#include <stb_image.h>

std::vector<unsigned char> Texture::sPixels;
int Texture::sWidth = 0;
int Texture::sHeight = 0;
std::mutex Texture::sMutex;
std::atomic<bool> Texture::sReady = false;

Texture::Texture(const std::vector<unsigned char>& pixels, int width, int height,
                 unsigned int unit, unsigned int internalFormat) {
    mUnit = unit;
    mWidth = width;
    mHeight = height;

    glGenTextures(1, &mTexture);
    glActiveTexture(GL_TEXTURE0 + mUnit);
    glBindTexture(GL_TEXTURE_2D, mTexture);

    glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels.data());

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
}

void Texture::loadAsync(const std::string& path, unsigned int unit, unsigned int internalFormat) {
	//lambdaè¡¨è¾¾å¼
    std::thread([path]() {
        int w, h, channels;
        stbi_set_flip_vertically_on_load(true);
        unsigned char* data = stbi_load(path.c_str(), &w, &h, &channels, STBI_rgb_alpha);
        if (!data) return;

        std::lock_guard<std::mutex> lock(sMutex);
        sWidth = w;
        sHeight = h;
        sPixels.assign(data, data + w * h * 4);
        stbi_image_free(data);
        sReady = true;
    }).detach();
}

bool Texture::hasLoaded() {
    return sReady.load();
}

void Texture::getLoadedData(std::vector<unsigned char>& pixels, int& w, int& h) {
    std::lock_guard<std::mutex> lock(sMutex);
    pixels = sPixels;
    w = sWidth;
    h = sHeight;
    sReady = false;
}

```
è§£é‡Šä¸€ä¸‹ï¼š
`loadAsync`æ ¸å¿ƒç›®çš„æ˜¯**è®©è´´å›¾çš„è¯»å–ï¼ˆ`stbi_load`ï¼‰åœ¨åå°çº¿ç¨‹ä¸­æ‰§è¡Œï¼Œè€Œä¸æ˜¯é˜»å¡ä¸»çº¿ç¨‹**ã€‚
```cpp
void Texture::loadAsync(const std::string& path, unsigned int unit, unsigned int internalFormat)
```
è¿™ä¸ªå‡½æ•°ï¼š
-   æ˜¯ä¸€ä¸ª**é™æ€å‡½æ•°**ï¼ˆ`static`ï¼‰ï¼Œæ‰€ä»¥ä¸ä¾èµ–äº `Texture` å®ä¾‹ï¼›
-   ä¼šå¯åŠ¨ä¸€ä¸ª**çº¿ç¨‹**å»åŠ è½½è´´å›¾æ•°æ®ï¼›
-   ç»“æœæš‚æ—¶ç¼“å­˜åˆ°é™æ€å˜é‡ä¸­ï¼ˆæ¯”å¦‚ `sPixels`ã€`sWidth` ç­‰ï¼‰ï¼›
-   ç„¶åä¸»çº¿ç¨‹ç¨åå†ä¸Šä¼ ã€‚

```cpp
std::thread([path]() {
    ...
}).detach();
```
-   ç”¨ lambda åˆ›å»ºçº¿ç¨‹ï¼Œæ•è· `path` å˜é‡ï¼›
-   detach ä»£è¡¨çº¿ç¨‹åå°æ‰§è¡Œï¼Œè‡ªåŠ¨ç»“æŸï¼Œä¸»çº¿ç¨‹ä¸ä¼šç­‰å¾…ã€‚

### è®¾ç½® stb_image Yè½´åè½¬ï¼ˆå’ŒåŸæ¥ä¸€æ ·ï¼‰

```cpp
stbi_set_flip_vertically_on_load(true);
```
-   å› ä¸º OpenGL Yè½´å‘ä¸Šï¼Œä½†å›¾ç‰‡å¾€å¾€ Yè½´å‘ä¸‹ï¼Œæ‰€ä»¥è¿™é‡Œåšç¿»è½¬ï¼›
-   è¿™ä¸€ç‚¹å’Œä½ åŸæ¥çš„ä¸€æ¨¡ä¸€æ ·ã€‚

### ç”¨ `stbi_load` åŠ è½½è´´å›¾æ•°æ®
```cpp
unsigned char* data = stbi_load(path.c_str(), &w, &h, &channels, STBI_rgb_alpha);
```
-   ä»æ–‡ä»¶ä¸­åŠ è½½ä¸€å¼ å›¾ç‰‡ï¼›
-   `data` æ˜¯å›¾ç‰‡åƒç´ æ•°æ®ï¼Œ`w` å’Œ `h` æ˜¯å›¾åƒå®½é«˜ï¼›
-   `channels` è¡¨ç¤ºåŸå§‹é€šé“æ•°ï¼›
-   `STBI_rgb_alpha` å¼ºåˆ¶è¾“å‡º RGBA 4 é€šé“ï¼ˆæ¯åƒç´ 4å­—èŠ‚ï¼‰ï¼›
-   **è¿™æ®µå’ŒåŸæ¥çš„ä»£ç å®Œå…¨ä¸€æ ·**ã€‚

### å¼‚å¸¸æ£€æŸ¥

```cpp
if (!data) return;
```
-   å¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ï¼ˆæ‰¾ä¸åˆ°æ–‡ä»¶/åæ–‡ä»¶ï¼‰ï¼Œç›´æ¥è¿”å›ï¼›
-   é¿å…åé¢æ“ä½œç©ºæŒ‡é’ˆã€‚

### åŠ é”å¹¶ä¿å­˜æ•°æ®ï¼ˆé‡ç‚¹ï¼ï¼‰
```cpp
std::lock_guard<std::mutex> lock(sMutex);
```
-   åŠ é”ï¼Œä¿è¯ä¸‹é¢è¿™æ®µä»£ç æ˜¯**çº¿ç¨‹å®‰å…¨çš„**ï¼›
-   å› ä¸º `sPixels`ã€`sWidth`ã€`sHeight` æ˜¯é™æ€å…±äº«å˜é‡ï¼Œå¤šçº¿ç¨‹è®¿é—®å¿…é¡»åŠ é”ã€‚

### åŠ é”å¹¶ä¿å­˜æ•°æ®ï¼ˆé‡ç‚¹ï¼ï¼‰

cpp

å¤åˆ¶ç¼–è¾‘

`std::lock_guard<std::mutex> lock(sMutex);`

-   åŠ é”ï¼Œä¿è¯ä¸‹é¢è¿™æ®µä»£ç æ˜¯**çº¿ç¨‹å®‰å…¨çš„**ï¼›
    
-   å› ä¸º `sPixels`ã€`sWidth`ã€`sHeight` æ˜¯é™æ€å…±äº«å˜é‡ï¼Œå¤šçº¿ç¨‹è®¿é—®å¿…é¡»åŠ é”ã€‚

**ä¸ºä»€ä¹ˆè¦è®¾è®¡ä¸ºé™æ€å…±äº«ï¼Ÿ**
å› ä¸ºè¿™äº›å˜é‡è¢«è®¾ä¸º `static`ï¼Œæ„æ€æ˜¯ï¼š
-   å®ƒä»¬æ˜¯ `Texture` ç±»çº§åˆ«çš„**å…¨å±€å…±äº«çŠ¶æ€**ï¼›
-   ä¸ä¾èµ–æŸä¸ª `Texture` å¯¹è±¡æ˜¯å¦å­˜åœ¨ï¼›
-   åªéœ€è¦åœ¨ç¬¬ä¸€æ¬¡å£°æ˜æ—¶æ„é€ ä¸€æ¬¡ï¼Œæ•´ä¸ªç¨‹åºç”Ÿå‘½å‘¨æœŸåªå­˜åœ¨ä¸€ä»½ã€‚

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ**
> å› ä¸ºå¼‚æ­¥è´´å›¾åŠ è½½çš„è¿‡ç¨‹å‘ç”Ÿåœ¨æ²¡æœ‰ `Texture` å¯¹è±¡çš„å‰æä¸‹ã€‚  
> æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å…ˆåŠ è½½è´´å›¾ï¼Œå†åœ¨ä¸»çº¿ç¨‹ä¸­ç”¨è¿™äº›æ•°æ®æ„é€  `Texture` å¯¹è±¡ã€‚

è€Œå¦‚æœä¸è®¾ä¸º `static`ï¼Œä½ å°±å¿…é¡»å…ˆæœ‰ä¸ªå¯¹è±¡ï¼Œæ‰èƒ½å­˜æ•°æ®ï¼Œè¿™å°±è¡Œä¸é€šäº†ã€‚

**ä¸ºä»€ä¹ˆä¸€å®šè¦ åŠ é”ï¼ˆæˆ–ç”¨ atomicï¼‰**ï¼Ÿ

å³ä½¿ä½ åªæœ‰ä¸€ä¸ªåå°çº¿ç¨‹ï¼Œ**ä¸»çº¿ç¨‹å’Œåå°çº¿ç¨‹ä¹‹é—´ä»ç„¶ä¼šäº§ç”Ÿç«æ€æ¡ä»¶**ï¼ˆrace conditionï¼‰ï¼š
ä¸¾ä¸ªä¾‹å­ï¼šä½ ä¸åŠ é”å°±è®¿é—® `sPixels`ï¼Œå¯èƒ½ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µï¼š

![è¾“å…¥å›¾ç‰‡è¯´æ˜](/imgs/2025-07-08/TfKXmQZIgkj1sgaR.png)

----------

### ä¿å­˜è´´å›¾æ•°æ®ï¼ˆåŒºåˆ«æœ€å¤§çš„ä¸€éƒ¨åˆ†ï¼‰

```cpp
sWidth = w; 
sHeight = h;
sPixels.assign(data, data + w * h * 4);
```

è¿™æ˜¯è¿™æ®µä»£ç **å’Œä½ åŸæ¥çš„æ„é€ å‡½æ•°æœ€å¤§ä¸åŒçš„åœ°æ–¹**ï¼š

#### ä½ åŸæ¥æ˜¯ï¼š

```cpp
glTexImage2D(..., data);
stbi_image_free(data);
```

ä½ æ˜¯ç›´æ¥ä¸Šä¼  GPUï¼Œä¸ä¿å­˜æ•°æ®ã€‚

#### è€Œç°åœ¨ï¼š

```cpp
sPixels.assign(data, data + w * h * 4);
```
-   æŠŠ `data` ä¸­çš„åƒç´ å¤åˆ¶è¿›ä¸€ä¸ª `std::vector<unsigned char>` ä¸­ï¼Œä¿å­˜ä¸‹æ¥ï¼›
-   `assign(data, data + w * h * 4)` æ˜¯æ ‡å‡†å†™æ³•ï¼Œç›¸å½“äºï¼š
```cpp
for (int i = 0; i < w * h * 4; ++i){
	sPixels[i] = data[i];
}
```

ä¸ºä»€ä¹ˆè¦è¿™æ ·ï¼Ÿ

> å› ä¸º `data` æ˜¯ `stbi_load` malloc å‡ºæ¥çš„ï¼Œå¦‚æœæˆ‘ä»¬ä¸åŠæ—¶æ‹·è´ã€åˆé©¬ä¸Š freeï¼Œå°±ä¼šä¸¢å¤±æ•°æ®æˆ–è®¿é—®éæ³•å†…å­˜ã€‚  
> æ‰€ä»¥æˆ‘ä»¬å…ˆ copy åˆ°è‡ªå·±çš„å®¹å™¨ä¸­ï¼ˆvectorï¼‰ï¼Œå† freeã€‚

### é‡Šæ”¾åŸå§‹æ•°æ®

```cpp
stbi_image_free(data);
```

-   åŸå§‹ `data` æ˜¯ `stbi_load` åˆ†é…çš„å †å†…å­˜ï¼›
-   æˆ‘ä»¬å·²ç»æ‹·è´è¿› `sPixels`ï¼Œæ‰€ä»¥ç°åœ¨å¯ä»¥å®‰å…¨é‡Šæ”¾ï¼›
-   å’Œä½ åŸæ¥é‡Šæ”¾æ–¹å¼ä¸€æ ·ã€‚


### è®¾ç½®æ ‡å¿—ä½ï¼šæ•°æ®å‡†å¤‡å¥½äº†ï¼

```cpp
sReady = true;
```
-   `sReady` æ˜¯ä¸€ä¸ª `std::atomic<bool>` ç±»å‹çš„å…¨å±€æ ‡å¿—ï¼›
-   ä»£è¡¨è´´å›¾æ•°æ®å·²ç»å‡†å¤‡å¥½ï¼Œå¯ä»¥ä»ä¸»çº¿ç¨‹ä¸­ä¸Šä¼  GPU äº†ï¼›
-   ä¸»çº¿ç¨‹é€šè¿‡è°ƒç”¨ `hasLoaded()` æ£€æŸ¥è¿™ä¸ªæ ‡å¿—ã€‚

# æ¥ä¸‹æ¥è¿›é˜¶ï¼ŒåŠ å…¥å¼‚æ­¥åŠ è½½å¤šå¼ è´´å›¾
æ­¤æ—¶è¦å¼•å…¥ä¸€ä¸ªå…±äº«é˜Ÿåˆ—æ¥å­˜å‚¨åŠ è½½å¥½çš„è´´å›¾

è´´å›¾æ•°æ®ç»“æ„è®¾è®¡ï¼šTextureData.h
```cpp
#pragma once
#include <vector>
#include <string>
struct TextureData {     
	std::string name;// ç”¨äºè¯†åˆ«ï¼ˆè·¯å¾„æˆ– IDï¼‰     	
	std::vector<unsigned char> pixels;// åƒç´ æ•°æ®
	int width = 0;
	int height = 0;
	int channels = 4;// é€šå¸¸æ˜¯ RGBA 
};
```
å¼‚æ­¥åŠ è½½å™¨ï¼šTextureLoader.h / cpp
è¿™é‡Œæ¶‰åŠäº†ä¸€ä¸ª`mQueue`ï¼Œç”¨æ¥å­˜å‚¨åŠ è½½å¥½çš„è´´å›¾
```cpp
#pragma once
#include "TextureData.h"
#include <string>
#include <vector>
#include <queue>
#include <mutex>
#include <thread>
#include <condition_variable>
class TextureLoader {
public:
	void loadAsync(const std::string& path);
	bool hasTexture();
	TextureData popTexture(); // çº¿ç¨‹å®‰å…¨åœ°å–å‡ºä¸€å¼ å·²åŠ è½½çš„è´´å›¾  
private:
	std::queue<TextureData> mQueue;
	std::mutex mMutex; 
};
```
```cpp
#include "TextureLoader.h"
#include <stb_image.h>
#include <iostream>

void TextureLoader::loadAsync(const std::string& path) {
    std::thread([this, path]() {
        int w, h, c;
        stbi_set_flip_vertically_on_load(true);
        unsigned char* data = stbi_load(path.c_str(), &w, &h, &c, 4);
        if (!data) {
            std::cerr << "Failed to load: " << path << std::endl;
            return;
        }

        TextureData tex;
        tex.name = path;
        tex.width = w;
        tex.height = h;
        tex.channels = 4;
        tex.pixels.assign(data, data + w * h * 4);
        stbi_image_free(data);

        {
            std::lock_guard<std::mutex> lock(mMutex);
            mQueue.push(tex);
        }
    }).detach();
}

bool TextureLoader::hasTexture() {
    std::lock_guard<std::mutex> lock(mMutex);
    return !mQueue.empty();
}

TextureData TextureLoader::popTexture() {
    std::lock_guard<std::mutex> lock(mMutex);
    TextureData tex = mQueue.front();
    mQueue.pop();
    return tex;
}

```
ä¸Šä¼ çº¹ç†ç±»ï¼šTexture.h
```cpp
#pragma once
#include "TextureData.h"
#include <glad/glad.h>

class Texture {
public:
    GLuint id = 0;

    Texture(const TextureData& data) {
        glGenTextures(1, &id);
        glBindTexture(GL_TEXTURE_2D, id);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, data.width, data.height, 0,
                     GL_RGBA, GL_UNSIGNED_BYTE, data.pixels.data());

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    }

    void bind(int unit) const {
        glActiveTexture(GL_TEXTURE0 + unit);
        glBindTexture(GL_TEXTURE_2D, id);
    }
};

```
ä½¿ç”¨ç¤ºä¾‹ï¼šmain.cpp
```cpp
#include "TextureLoader.h"
#include "Texture.h"
#include <GLFW/glfw3.h>
#include <glad/glad.h>
#include <iostream>
#include <map>

int main() {
    glfwInit();
    GLFWwindow* window = glfwCreateWindow(800, 600, "Async Texture Load", nullptr, nullptr);
    glfwMakeContextCurrent(window);
    gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);

    TextureLoader loader;

    // å¯åŠ¨å¤šä¸ªå¼‚æ­¥ä»»åŠ¡
    loader.loadAsync("brick.jpg");
    loader.loadAsync("wood.jpg");
    loader.loadAsync("metal.jpg");

    std::map<std::string, Texture> textureMap;

    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();

        // æ¯å¸§è½®è¯¢æ˜¯å¦æœ‰è´´å›¾å‡†å¤‡å¥½
        while (loader.hasTexture()) {
            TextureData texData = loader.popTexture();
            textureMap[texData.name] = Texture(texData);
            std::cout << "å·²ä¸Šä¼ ï¼š" << texData.name << std::endl;
        }

        glClear(GL_COLOR_BUFFER_BIT);
        // ä½¿ç”¨ textureMap["xxx"] ç»‘å®šç»˜åˆ¶

        glfwSwapBuffers(window);
    }

    glfwTerminate();
    return 0;
}

```

### æ€»ç»“

æ”¯æŒå¤šè´´å›¾å¹¶å‘åŠ è½½ï¼Œæ¯å¼ å›¾å¼€å¯ä¸€ä¸ªçº¿ç¨‹ï¼Œäº’ä¸å¹²æ‰°
ä¸»çº¿ç¨‹å®‰å…¨ä¸Šä¼ ï¼Œæ‰€æœ‰ `glTexImage2D` åœ¨ä¸»çº¿ç¨‹

# ä½¿ç”¨çº¿ç¨‹æ± 

çº¿ç¨‹æ± çš„æ ¸å¿ƒæ€æƒ³æ˜¯â€œä»»åŠ¡ç­‰ç€çº¿ç¨‹å¹²æ´»ï¼Œè€Œä¸æ˜¯çº¿ç¨‹ç­‰ç€ä»»åŠ¡æ¥â€ï¼Œ  
å®ƒç”¨**å›ºå®šæ•°é‡çš„çº¿ç¨‹**åå¤å¤„ç†**ä»»æ„æ•°é‡çš„ä»»åŠ¡**ï¼Œé«˜æ•ˆã€çµæ´»ã€å¯æ§ã€‚

æ ¸å¿ƒç»“æ„å›é¡¾ï¼ˆThreadPool ç±»ï¼‰
```cpp
class ThreadPool {
public:
    ThreadPool(size_t threadCount);
    ~ThreadPool();

    template<typename Func>
    void enqueue(Func task);

private:
    std::vector<std::thread> mWorkers;// å·¥ä½œçº¿ç¨‹æ± 
    std::queue<std::function<void()>> mTasks;// ç­‰å¾…ä»»åŠ¡é˜Ÿåˆ—
    std::mutex mMutex;// ä¿æŠ¤ä»»åŠ¡é˜Ÿåˆ—
    std::condition_variable mCond;// é€šçŸ¥æœºåˆ¶
    bool mStop = false;// åœæ­¢æ ‡å¿—

    void workerLoop();// æ¯ä¸ªçº¿ç¨‹å¾ªç¯ä½“
};

```

ç¬¬ä¸€æ­¥ï¼šçº¿ç¨‹æ± åˆå§‹åŒ– â€”â€” æ„é€ å‡½æ•°

```cpp
ThreadPool::ThreadPool(size_t count) {
    for (size_t i = 0; i < count; ++i) {
        mWorkers.emplace_back([this]() { this->workerLoop(); });
    }
}
```

**å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ**

-   ä½ è¯´äº†è¦ `count` ä¸ªçº¿ç¨‹ï¼›
-   æ¯ä¸ªçº¿ç¨‹éƒ½ä¼šæ‰§è¡Œ `this->workerLoop()`ï¼›
-   æŠŠæ‰€æœ‰çº¿ç¨‹éƒ½å­˜è¿› `mWorkers`ï¼›
-   æ‰€ä»¥åˆå§‹åŒ–çº¿ç¨‹æ± åï¼Œæœ‰ä¸€å †çº¿ç¨‹åœ¨è¿è¡Œ `workerLoop()` å¹¶â€œæŒ‚èµ·ç­‰å¾…â€ã€‚

ç¬¬äºŒæ­¥ï¼šçº¿ç¨‹å¾ªç¯ä½“ â€”â€” `workerLoop()`
```cpp
void ThreadPool::workerLoop() {
    while (true) {
        std::function<void()> task;

        {
            std::unique_lock<std::mutex> lock(mMutex);
            mCond.wait(lock, [this]() {
                return mStop || !mTasks.empty(); // ç­‰å¾…æœ‰ä»»åŠ¡æˆ–éœ€è¦é€€å‡º
            });

            if (mStop && mTasks.empty()) return;

            task = std::move(mTasks.front());
            mTasks.pop();
        }

        task(); // æ‰§è¡Œä»»åŠ¡
    }
}
```

å…³é”®ç‚¹è§£é‡Šï¼š
`mCond.wait(...)`ï¼šå½“å‰çº¿ç¨‹æŒ‚èµ·ï¼Œç›´åˆ°æœ‰ä»»åŠ¡æˆ–è¢«é€šçŸ¥é€€å‡º

`if (mStop && mTasks.empty()) return;`ï¼šå½“æ ‡è®°ä¸ºåœæ­¢ã€ä¸”æ— ä»»åŠ¡æ—¶ï¼Œé€€å‡ºçº¿ç¨‹

`task = mTasks.front();`ï¼šå–å‡ºä¸€ä¸ªä»»åŠ¡å‡½æ•°å¯¹è±¡

`task();`ï¼šæ‰§è¡Œå®ƒï¼ˆå¯èƒ½æ˜¯è´´å›¾åŠ è½½ã€IOã€é€»è¾‘è¿ç®—ç­‰ï¼‰

ç¬¬ä¸‰æ­¥ï¼šä»»åŠ¡æäº¤ â€”â€” `enqueue`
```cpp
template<typename Func>
void ThreadPool::enqueue(Func task) {
    {
        std::lock_guard<std::mutex> lock(mMutex);
        mTasks.push(std::function<void()>(task));
    }
    mCond.notify_one(); // å”¤é†’ä¸€ä¸ªçº¿ç¨‹
}
```
è¿™æ®µä»£ç å¹²äº†ä»€ä¹ˆï¼Ÿ
`lock_guard`ï¼šåŠ é”ç¡®ä¿çº¿ç¨‹å®‰å…¨ï¼ˆé˜²æ­¢å¤šä¸ªçº¿ç¨‹åŒæ—¶æ“ä½œé˜Ÿåˆ—ï¼‰
`mTasks.push(...)`ï¼šæŠŠä»»åŠ¡å¡è¿›ä»»åŠ¡é˜Ÿåˆ—ï¼ˆè¿™ä¸ªä»»åŠ¡æ˜¯ä¸ª lambda / functionï¼‰
`notify_one()`ï¼šéšæœºå”¤é†’ä¸€ä¸ªåœ¨ç­‰å¾…çš„çº¿ç¨‹ï¼Œè®©å®ƒå»å¤„ç†è¿™ä¸ªä»»åŠ¡

ç¬¬å››æ­¥ï¼šçº¿ç¨‹æ± é”€æ¯ â€”â€” ææ„å‡½æ•°
```cpp
ThreadPool::~ThreadPool() {
    {
        std::lock_guard<std::mutex> lock(mMutex);
        mStop = true;
    }
    mCond.notify_all(); // å”¤é†’æ‰€æœ‰çº¿ç¨‹ï¼Œè®©å®ƒä»¬æ£€æµ‹ mStop

    for (auto& worker : mWorkers) {
        if (worker.joinable())
            worker.join(); // ç­‰æ‰€æœ‰çº¿ç¨‹æ‰§è¡Œå®Œæ¯•
    }
}
```
è¿™æ®µåšäº†ä»€ä¹ˆï¼Ÿ
-   æ ‡è®° `mStop = true`ï¼Œå‘Šè¯‰æ‰€æœ‰çº¿ç¨‹â€œå‡†å¤‡å…³æœºâ€ï¼›
-   ç”¨ `notify_all()` å”¤é†’æ‰€æœ‰çº¿ç¨‹ï¼ˆé˜²æ­¢å®ƒä»¬ä¸€ç›´ç¡ï¼‰ï¼›
-   æ¯ä¸ªçº¿ç¨‹é†’æ¥å‘ç° `mStop == true && queue empty`ï¼Œå°±è‡ªç„¶é€€å‡ºï¼›
-   `join()` ä¿è¯ä¸»çº¿ç¨‹ç­‰æ‰€æœ‰çº¿ç¨‹å®‰å…¨é€€å‡ºå†é‡Šæ”¾èµ„æºã€‚
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE0MTA0MTgwOTcsODcxNTM0NDI4XX0=
-->