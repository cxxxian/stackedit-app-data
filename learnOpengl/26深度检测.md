用工程depthTest
在main.cpp中声明如下，因为我们希望有两个纹理和位置不一样的三角形
```
Texture* textureFir = nullptr;
Texture* textureSec = nullptr;
glm::mat4 transformFir(1.0);
glm::mat4 transformSec(1.0);
```
构造两个Texture，此处都绑上0号位置，后面再解释
```
void prepareTexture() {
    textureSec = new Texture("assets/textures/test.jpg", 0);
    textureFir = new Texture("assets/textures/goku.jpg", 0);
}
```
在render中，利用以前做的bind
```
void render(){
    //执行opengl画布清理操作
    glClear(GL_COLOR_BUFFER_BIT);

    //1 绑定当前的program
    shader->begin();

    shader->setInt("sampler", 0);//此处值为0是因为我们的纹理绑定在0号位上
    shader->setMatrix4x4("transform", transformFir);
    shader->setMatrix4x4("viewMatrix", camera->getViewMatrix());
    shader->setMatrix4x4("projectionMatrix", camera->getProjectionMatrix());


    textureFir->bind();
    //2 绑定当前的vao
    glBindVertexArray(vao);
    //3 发出绘制指令
    //第一次绘制
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
    //第二次绘制
    textureSec->bind();
    transformSec = glm::translate(glm::mat4(1.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    shader->setMatrix4x4("transform", transformSec);
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

    shader->end();
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTUxNDA3MTQ4MCwtMjA4ODc0NjYxMl19
-->