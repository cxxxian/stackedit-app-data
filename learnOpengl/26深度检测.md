# 问题引入
用工程depthTest
在main.cpp中声明如下，因为我们希望有两个纹理和位置不一样的三角形
```
Texture* textureFir = nullptr;
Texture* textureSec = nullptr;
glm::mat4 transformFir(1.0);
glm::mat4 transformSec(1.0);
```
构造两个Texture，此处都绑上0号位置，后面再解释
```
void prepareTexture() {
    textureSec = new Texture("assets/textures/test.jpg", 0);
    textureFir = new Texture("assets/textures/goku.jpg", 0);
}
```
在render中，利用以前做的bind函数可以当前绑定的纹理。
所以现在我们输出了两个位置不同的三角形，并且绑定上了不同的纹理
```
void render(){
    //执行opengl画布清理操作
    glClear(GL_COLOR_BUFFER_BIT);

    //1 绑定当前的program
    shader->begin();

    shader->setInt("sampler", 0);//此处值为0是因为我们的纹理绑定在0号位上
    shader->setMatrix4x4("transform", transformFir);
    shader->setMatrix4x4("viewMatrix", camera->getViewMatrix());
    shader->setMatrix4x4("projectionMatrix", camera->getProjectionMatrix());


    textureFir->bind();
    //2 绑定当前的vao
    glBindVertexArray(vao);
    //3 发出绘制指令
    //第一次绘制
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
    //第二次绘制
    textureSec->bind();
    transformSec = glm::translate(glm::mat4(1.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    shader->setMatrix4x4("transform", transformSec);
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

    shader->end();
}
```
输出如下：
![输入图片说明](/imgs/2024-11-19/iloWZHG2cpMfBxvq.png)
这时候引入我们的深度检测问题，当右边（第二个绘制）三角形往后移动一个单位，正常来说要被第一个挡住
利用以下代码将第二张图后移
```
transformSec = glm::translate(glm::mat4(1.0f), glm::vec3(1.0f, 0.0f, -1.0f));
```
输出如下：
变小是因为此时用的是透视投影，但是并没有被挡住，因为此时并没有进行深度检测
![输入图片说明](/imgs/2024-11-19/qYSClIiFMabjzSK8.png)
## problem
![输入图片说明](/imgs/2024-11-19/EweqBSTLtE55lo0C.png)
# 深度检测
## 深度值
![输入图片说明](/imgs/2024-11-19/GHOgPKlkeHYXYWm2.png)
<!--stackedit_data:
eyJoaXN0b3J5IjpbOTEwMjg3NzMyLC01OTc1OTI4MzMsLTE3Mz
kyOTk2OTAsLTIwODg3NDY2MTJdfQ==
-->