![输入图片说明](/imgs/2025-02-20/9TZD0p2ONh163QNC.png)

![输入图片说明](/imgs/2025-02-20/Y78LYgrwZb33YKib.png)

![输入图片说明](/imgs/2025-02-20/TAyiJxyE2WadK0bT.png)

![输入图片说明](/imgs/2025-02-20/VRLJieiky9cBwbGu.png)

由于法线是用`xyz`构成的，所以我们可以把法线存入图片，就像颜色贴图`rgb`一样
然后进行法线与`rgb`转换

![输入图片说明](/imgs/2025-02-20/FZTo67buQqfcHFvz.png)

# 代码实验
## 1.新建一个带有法线贴图的材质（从Phong改过来）
### 1.1创建材质
创建`phongNormalMaterial.h`，并声明一个纹理贴图用作法线贴图`mNormalMap`
```cpp
#pragma once
#include "../material.h"
#include "../../texture.h"

class PhongNormalMaterial :public Material {
public:
	PhongNormalMaterial();
	~PhongNormalMaterial();

public:
	Texture*	mDiffuse{ nullptr };
	Texture*	mSpecularMask{ nullptr };

	Texture*	mNormalMap{ nullptr };
	float		mShiness{ 1.0f };
};
```
并且去`material.h`添加相应枚举
```cpp
enum class MaterialType {
	...
	PhongNormalMaterial
};
```

### 1.2创建shader
从`phong.vert`和`phong.frag`复制过来，创建`phongNormal.vert`和`phongNormal.frag`
`phongNormal.vert`无需做修改，因为它和法线没啥关系
`phongNormal.frag`中，可以看到我们原本传入`calculateDirectionalLight`方法中的参数`normalN`，是根据`shader`中的顶点插值得出的
现在我们希望用上自己的法线贴图
利用纹理采样的得到`rgb`值，然后将`0~1`转化为`-1~1`
最后归一化即可得到`normalN`进行使用
```glsl
uniform sampler2D normalMapSampler;
void main()
{
	...
	//计算光照的通用数据
	//vec3 normalN = normalize(normal);
	vec3 normalN = texture(normalMapSampler, uv).rgb;
	normalN = normalN * 2.0 - vec3(1.0);//从0~1变成-1~1
	normalN = normalize(normalN);
	
	vec3 viewDir = normalize(worldPosition - cameraPosition);

	result += calculateDirectionalLight(objectColor, directionalLight,normalN, viewDir);
	...
}
```
### 1.3renderer中修改（pickShader，renderObject）
在`render.h`中声明一个`shader`对象
```cpp
private:
	...
	Shader* mPhongNormalShader{ nullptr };
```
到`render.cpp`中进行初始化
```cpp
Renderer::Renderer() {
	...
	mPhongNormalShader = new Shader("assets/shaders/advanced/phongNormal.vert", "assets/shaders/advanced/phongNormal.frag");
}
```
到`pickShader`方法中完善
```cpp
Shader* Renderer::pickShader(MaterialType type) {
	Shader* result = nullptr;

	switch (type) {
		...
	case MaterialType::PhongNormalMaterial:
		result = mPhongNormalShader;
		break;
	...
	}
	return result;
}
```
最后去到`renderObject`方法中添加相应的`case`
和`phongMaterial`没有什么区别，只是要多传输一个法线贴图
```cpp
case MaterialType::PhongNormalMaterial: {
	PhongNormalMaterial* phongMat = (PhongNormalMaterial*)material;

	//diffuse贴图帧更新
	//将纹理采样器与纹理单元进行挂钩
	shader->setInt("sampler", 0);
	//将纹理与纹理单元进行挂钩
	phongMat->mDiffuse->bind();
	
	//法线贴图
	shader->setInt("normalMapSampler", 1);
	phongMat->mNormalMap->bind();
	...
}
	break;
```

## 2.创建一个平面，使用法线贴图纹理
创建一个平面，
我们还是采用双`pass`渲染
```cpp
void prepare() {
	...
	//pass 01
	auto planeGeo = Geometry::createPlane(5, 5);
	auto planeMat = new PhongNormalMaterial();
	planeMat->mDiffuse = new Texture("assets/textures/normal/brickwall.jpg", 0, GL_SRGB_ALPHA);
	planeMat->mNormalMap = new Texture("assets/textures/normal/normal_map.png", 1);
	planeMat->mShiness = 32; //光斑大小
	auto planeMesh = new Mesh(planeGeo, planeMat);
	sceneOff->addChild(planeMesh);

	//pass 02
	auto sgeo = Geometry::createScreenPlane();
	auto smat = new ScreenMaterial();
	smat->mScreenTexture = fbo->mColorAttachment;
	//smat->mScreenTexture = new Texture("assets/textures/wall.jpg", 0, GL_SRGB_ALPHA);
	auto smesh = new Mesh(sgeo, smat);
	scene->addChild(smesh);
	...
}
```
用上法线贴图后真实了很多

![输入图片说明](/imgs/2025-02-20/gNADZ2bXwwC0CNpf.png)

我们做一个实验，现在的平面是朝向`+z`轴的，我们的法线贴图也是朝向`+z`轴的，现在把平面放倒朝向`+y`轴，平行光也调整过来直射`-y`方向
运行会发现黑不拉几的

![输入图片说明](/imgs/2025-02-20/ID06XQjrdqfhKr7j.png)

# TBN
## TBN向量空间介绍

![输入图片说明](/imgs/2025-02-20/e1rym9JyiOARUogc.png)

![输入图片说明](/imgs/2025-02-20/pp0qragApJbbKHXB.png)

其实就是法线的坐标通过`TBN`表示出来，
然后我们只需要求的`T`和`B`就可以把法线坐标转化到世界坐标系下，`N`其实就是三角形面片的三个点的法线向量相加除`3`
法线的世界坐标 = `TBN`组成的矩阵 * `n`（`n`是法线在`TBN`坐标系下的坐标）
`TBN`组成的矩阵可以通过由`T`，`B`，`N`三个列向量组成矩阵得到
## TBN向量计算方法
解释一下这个示例图，我们构建的`TB`坐标系，不是随便构建的，比如`u1`是`0.6`，那么在T方向上u1作垂线就得在`60%`上，其他坐标同理

![输入图片说明](/imgs/2025-02-20/CIvwfmz2hlfMdFyW.png)

![输入图片说明](/imgs/2025-02-20/AWyL45zitN3Dwy6d.png)

此时我们就把`TB`矩阵表示出来了，所以重点就是等式左边那坨怎么求
`E`的部分很好求，其实就是两个坐标相减得出的向量
所以`E1 = (u2, v2) - (u1, v1)`
所以现在主要工作在于求逆矩阵

![输入图片说明](/imgs/2025-02-20/fH6uiaStGj2TXb3L.png)

![输入图片说明](/imgs/2025-02-20/B49hR8NEOfgjQ1hY.png)

![输入图片说明](/imgs/2025-02-20/g1Q3ajh5OijkoqzY.png)

![输入图片说明](/imgs/2025-02-20/effPECC4unYRfaDD.png)

`T`要乘上`ModelMatrix`是因为当模型变换时`T`也要跟随变换，
而`N`不能直接乘`ModelMatrix`是因为，我们之前有做过，当一个球体比如沿着`x`缩小时，`N`并不会保持垂直缩小，所以我们要专门计算一个`NormalMatrix`（以前推到过）
最后`B`当然就可以直接通过`TN`的叉乘得到
通过以上计算就可以得到`TBN`矩阵
 
 ## 构建TBN矩阵实验
 ### 1.Geometry类，加入带tangent（切线）的构造函数（tangent作为顶点属性）
 在`geometry.h`中加入`mTangentVbo`以及一个带`tangent`的构造函数
```cpp
private:
	GLuint mTangentVbo{ 0 };

public:
	Geometry(
	const std::vector<float>& positions,
	const std::vector<float>& normals,
	const std::vector<float>& uvs,
	const std::vector<unsigned int>& indices,
	const std::vector<float>& tangents
);
```
在`geometry.cpp`中实现如下，其他的都和原来一样，只是加入了关于`mTangentVbo`的创建以及有关`vao`的使用
```cpp
Geometry::Geometry(
	const std::vector<float>& positions,
	const std::vector<float>& normals,
	const std::vector<float>& uvs,
	const std::vector<unsigned int>& indices,
	const std::vector<float>& tangents
) {
	...
	glGenBuffers(1, &mTangentVbo);
	glBindBuffer(GL_ARRAY_BUFFER, mTangentVbo);
	glBufferData(GL_ARRAY_BUFFER, tangents.size() * sizeof(float), tangents.data(), GL_STATIC_DRAW);
	...

	glBindBuffer(GL_ARRAY_ BUFFER, mTangentVbo);
	glEnableVertexAttribArray(3);
	glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 3, (void*)0);
	...
}
```

 ### 2.修改PhongNormalShader，加入tangent相关计算
 ![输入图片说明](/imgs/2025-02-20/sv0j4mJOcf3smk5T.png)

先明确，我们现在构造的是简单几何的情况，比如平面的每一个点的法线的朝向都是一样的，
但是球体就不一样了，球体的顶点的法线方向会受到和它连接的三角面片的影响，是所有和它连接的三角面片共同作用影响的

所以我们这次制作简单情况的话，即平面的情况
那么它的`n`就是`normal =  normalMatrix * aNormal;`
然后`tangent`又与`normal`垂直，可以通过叉乘算出`bitangent`（也就是`B`）
但是这里问题来了

```glsl
...
layout (location = 2) in vec3 aNormal;
layout (location = 3) in vec3 aTangent;

...
out mat3 tbn;
...
void main()
{
	...
	normal =  normalMatrix * aNormal;
	vec3 tangent = normalize(mat3(modelMatrix) * aTangent);
	vec3 bitangent = normalize(cross(normal, tangent));
	tbn = mat3(tangent, bitangent, normal);
}
```

 ### 3.prepare函数中，准备实验数据与环境
 ### 4.计算tangent向量，并且作为attribute加入到Geometry构造当中
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTYzODg0MTQzNCwtMTMyNDYxMDMwNCwxMD
g5MDU0MjYzLC0xNDUyNTEwNjU0LDEzMjU1NjczMDgsLTE3ODgy
Mzg2NSwxNTk0ODA1MTcsLTEyNzY5ODgxNTEsLTUyMDQ4Mzk2LD
E1NjIxNzI5NDIsLTY4MDY2ODM4MCwxNTQwODkwOTMzLDgwMTQx
NDQyMF19
-->