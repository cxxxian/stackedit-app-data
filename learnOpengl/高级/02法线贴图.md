![输入图片说明](/imgs/2025-02-20/9TZD0p2ONh163QNC.png)

![输入图片说明](/imgs/2025-02-20/Y78LYgrwZb33YKib.png)

![输入图片说明](/imgs/2025-02-20/TAyiJxyE2WadK0bT.png)

![输入图片说明](/imgs/2025-02-20/VRLJieiky9cBwbGu.png)

由于法线是用`xyz`构成的，所以我们可以把法线存入图片，就像颜色贴图`rgb`一样
然后进行法线与`rgb`转换

![输入图片说明](/imgs/2025-02-20/FZTo67buQqfcHFvz.png)

# 代码实验
## 1.新建一个带有法线贴图的材质（从Phong改过来）
### 1.1创建材质
创建`phongNormalMaterial.h`，并声明一个纹理贴图用作法线贴图`mNormalMap`
```cpp
#pragma once
#include "../material.h"
#include "../../texture.h"

class PhongNormalMaterial :public Material {
public:
	PhongNormalMaterial();
	~PhongNormalMaterial();

public:
	Texture*	mDiffuse{ nullptr };
	Texture*	mSpecularMask{ nullptr };

	Texture*	mNormalMap{ nullptr };
	float		mShiness{ 1.0f };
};
```
并且去`material.h`添加相应枚举
```cpp
enum class MaterialType {
	...
	PhongNormalMaterial
};
```

### 1.2创建shader
从`phong.vert`和`phong.frag`复制过来，创建`phongNormal.vert`和`phongNormal.frag`
`phongNormal.vert`无需做修改，因为它和法线没啥关系
`phongNormal.frag`中，可以看到我们原本传入`calculateDirectionalLight`方法中的参数`normalN`，是根据`shader`中的顶点插值得出的
现在我们希望用上自己的法线贴图
利用纹理采样的得到`rgb`值，然后将`0~1`转化为`-1~1`
最后归一化即可得到`normalN`进行使用
```glsl
uniform sampler2D normalMapSampler;
void main()
{
	...
	//计算光照的通用数据
	//vec3 normalN = normalize(normal);
	vec3 normalN = texture(normalMapSampler, uv).rgb;
	normalN = normalN * 2.0 - vec3(1.0);//从0~1变成-1~1
	normalN = normalize(normalN);
	
	vec3 viewDir = normalize(worldPosition - cameraPosition);

	result += calculateDirectionalLight(objectColor, directionalLight,normalN, viewDir);
	...
}
```
### 1.3renderer中修改（pickShader，renderObject）
在`render.h`中声明一个`shader`对象
```cpp
private:
	...
	Shader* mPhongNormalShader{ nullptr };
```
到`render.cpp`中进行初始化
```cpp
Renderer::Renderer() {
	...
	mPhongNormalShader = new Shader("assets/shaders/advanced/phongNormal.vert", "assets/shaders/advanced/phongNormal.frag");
}
```
到`pickShader`方法中完善
```cpp
Shader* Renderer::pickShader(MaterialType type) {
	Shader* result = nullptr;

	switch (type) {
		...
	case MaterialType::PhongNormalMaterial:
		result = mPhongNormalShader;
		break;
	...
	}
	return result;
}
```
最后去到`renderObject`方法中添加相应的`case`
和`phongMaterial`没有什么区别，只是要多传输一个法线贴图
```cpp
case MaterialType::PhongNormalMaterial: {
	PhongNormalMaterial* phongMat = (PhongNormalMaterial*)material;

	//diffuse贴图帧更新
	//将纹理采样器与纹理单元进行挂钩
	shader->setInt("sampler", 0);
	//将纹理与纹理单元进行挂钩
	phongMat->mDiffuse->bind();
	
	//法线贴图
	shader->setInt("normalMapSampler", 1);
	phongMat->mNormalMap->bind();
	...
}
	break;
```

## 2.创建一个平面，使用法线贴图纹理
创建一个平面，
我们还是采用双`pass`渲染
```cpp
void prepare() {
	...
	//pass 01
	auto planeGeo = Geometry::createPlane(5, 5);
	auto planeMat = new PhongNormalMaterial();
	planeMat->mDiffuse = new Texture("assets/textures/normal/brickwall.jpg", 0, GL_SRGB_ALPHA);
	planeMat->mNormalMap = new Texture("assets/textures/normal/normal_map.png", 1);
	planeMat->mShiness = 32; //光斑大小
	auto planeMesh = new Mesh(planeGeo, planeMat);
	sceneOff->addChild(planeMesh);

	//pass 02
	auto sgeo = Geometry::createScreenPlane();
	auto smat = new ScreenMaterial();
	smat->mScreenTexture = fbo->mColorAttachment;
	//smat->mScreenTexture = new Texture("assets/textures/wall.jpg", 0, GL_SRGB_ALPHA);
	auto smesh = new Mesh(sgeo, smat);
	scene->addChild(smesh);
	...
}
```
用上法线贴图后真实了很多

![输入图片说明](/imgs/2025-02-20/gNADZ2bXwwC0CNpf.png)

我们做一个实验，现在的平面是朝向`+z`轴的，我们的法线贴图也是朝向`+z`轴的，现在把平面放倒朝向`+y`轴，平行光也调整过来直射`-y`方向
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTMyNTYzNTQ2NiwtMTI3Njk4ODE1MSwtNT
IwNDgzOTYsMTU2MjE3Mjk0MiwtNjgwNjY4MzgwLDE1NDA4OTA5
MzMsODAxNDE0NDIwXX0=
-->