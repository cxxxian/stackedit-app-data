![输入图片说明](/imgs/2025-02-20/9TZD0p2ONh163QNC.png)

![输入图片说明](/imgs/2025-02-20/Y78LYgrwZb33YKib.png)

![输入图片说明](/imgs/2025-02-20/TAyiJxyE2WadK0bT.png)

![输入图片说明](/imgs/2025-02-20/VRLJieiky9cBwbGu.png)

由于法线是用`xyz`构成的，所以我们可以把法线存入图片，就像颜色贴图`rgb`一样
然后进行法线与`rgb`转换

![输入图片说明](/imgs/2025-02-20/FZTo67buQqfcHFvz.png)

# 代码实验
## 1.新建一个带有法线贴图的材质（从Phong改过来）
### 1.1创建材质
创建`phongNormalMaterial.h`，并声明一个纹理贴图用作法线贴图`mNormalMap`
```cpp
#pragma once
#include "../material.h"
#include "../../texture.h"

class PhongNormalMaterial :public Material {
public:
	PhongNormalMaterial();
	~PhongNormalMaterial();

public:
	Texture*	mDiffuse{ nullptr };
	Texture*	mSpecularMask{ nullptr };

	Texture*	mNormalMap{ nullptr };
	float		mShiness{ 1.0f };
};
```
并且去`material.h`添加相应枚举
```cpp
enum class MaterialType {
	...
	PhongNormalMaterial
};
```

### 1.2创建shader
从`phong.vert`和`phong.frag`复制过来，创建`phongNormal.vert`和`phongNormal.frag`
`phongNormal.vert`无需做修改，因为它和法线没啥关系
`phongNormal.frag`中，ke
```glsl
uniform sampler2D normalMapSampler;
void main()
{
	...
	//计算光照的通用数据
	//vec3 normalN = normalize(normal);
	vec3 normalN = texture(normalMapSampler, uv).rgb;
	normalN = normalN * 2.0 - vec3(1.0);//从0~1变成-1~1
	normalN = normalize(normalN);
	
	vec3 viewDir = normalize(worldPosition - cameraPosition);

	result += calculateDirectionalLight(objectColor, directionalLight,normalN, viewDir);
	...
}
```
### 1.3renderer中修改（pickShader，renderObject）
## 2.创建一个平面，使用法线贴图纹理
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzNTA4MTk5NjMsLTY4MDY2ODM4MCwxNT
QwODkwOTMzLDgwMTQxNDQyMF19
-->