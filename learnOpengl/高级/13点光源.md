![输入图片说明](/imgs/2025-03-02/CMuTrzTPjFm95tjE.png)

![输入图片说明](/imgs/2025-03-02/QkZFzolDUY6MCfOK.png)

![输入图片说明](/imgs/2025-03-02/MV2YivenkBhoEIhT.png)

![输入图片说明](/imgs/2025-03-02/C5dNtfZLgovEQ03W.png)

![输入图片说明](/imgs/2025-03-02/QTL3EpopCCleo94k.png)

![输入图片说明](/imgs/2025-03-02/X6jhIM1SssuaazZG.png)

所以根据`opengl`的规则，其实可以解答疑惑，为什么`cubeMap`图片采样的时候不需要反转，但是正常`texture2D`需要，因为`cubeMap`就是把左上角当成`(0, 0)`点进行采样，而`texture2D`是把左下角当作`(0, 0)`点进行采样

![输入图片说明](/imgs/2025-03-02/UpW1FIaH2HZZNajE.png)

所以我们就可以依照规则求出`lightMatrix`，通过投影矩阵乘上视角矩阵，视角矩阵是通过规则得来

我们以前是将深度值直接写入到`shadowMap`当中，而`depth`是通过`ndc`求得，由下图可知会存在精度问题

![输入图片说明](/imgs/2025-03-02/M1IJtEt2lB0Y5vfA.png)

所以我们采用物体到光源得距离作为深度参考，这样就可以转化为线性问题

![输入图片说明](/imgs/2025-03-02/IxZrgsyEuis0DEZu.png)

`frag`中还有一个变量叫做`gl_FragDepth`，这样我们就可以输出自己计算的深度值而不是自动输出深度值了

![输入图片说明](/imgs/2025-03-02/FZE495sRtTJ8Lnui.png)

![输入图片说明](/imgs/2025-03-02/ugpdr4B9izy6CQGr.png)

# 实践（准备工作）
## 1 准备三件套：phongPointShadowMaterial + pointLightShadow + phongPointShadow.vert/frag
正常从原先基础复制即可，暂时不做修改
### 建立新的shadowPass的Shader
还有一个重要的事情，原本我们做`shadowMap`利用的是`shadow.vert/frag`，但是我们现在点光源渲染的`shadowMap`和以前不一样了，要渲染到`cubeMap`上面，而且使用的深度也是我们自己的自定义线性深度
所以重新建一个`shadowDistance.vert/frag`，用来专门对应此种`shadow Map`
## 2 加入架构：
### 在Light中加入PointLightShadow的生成
在`pointLight.cpp`中的构造函数加入`PointLightShadow`的生成
```cpp
#include "pointLight.h"
#include "shadow/pointLightShadow.h"

PointLight::PointLight() {
	mShadow = new PointLightShadow();
}
```
此时的`PointLightShadow`还是我们从`DirectionalLightShadow`复制过来的，后续再做修改
### 在render函数中兼容这些功能
在`render.h`中生成并到`render.cpp`中初始化两个`shader`
```cpp
Renderer::Renderer() {
	...
	mShadowDistanceShader = new Shader("assets/shaders/advanced/shadowDistance.vert", "assets/shaders/advanced/shadowDistance.frag");
	mPhongPointShadowShader = new Shader("assets/shaders/advanced/phongPointShadow.vert", "assets/shaders/advanced/phongPointShadow.frag");
}
```
此处`mShadowDistanceShader`是用来渲染`shadowMap`对应的`shader`
`mPhongPointShadowShader`才是用来渲染物体的`shader`
所以需要把`mPhongPointShadowShader`加入`pickShader`函数
```cpp
Shader* Renderer::pickShader(MaterialType type) {
	Shader* result = nullptr;
	switch (type) {
	...
	case MaterialType::PhongPointShadowMaterial:
		result = mPhongPointShadowShader;
		break;
	...
	}

	return result;
}
```
接下来修改`render`方面的函数，我们以前制作的`render`和`renderObject`和`renderShadowMap`都是只支持`DirectionalLight`的，现在我们想制作点光源，就先把`DirectionalLight`直接做成`PointLight`
```cpp
void render(
	Scene* scene,
	Camera* camera,
	PointLight* pointLight,
	AmbientLight* ambLight,
	unsigned int fbo = 0
);

void renderObject(
	Object* object,
	Camera* camera,
	PointLight* pointLight,
	AmbientLight* ambLight
);

void renderShadowMap(Camera* camera, const std::vector<Mesh*>& meshes, PointLight* pointLight);
```
不过此时肯定会报一大堆错，慢慢来改
先去`shader`修改相应代码
把原本的`directionalLight`和`calculateDirectionalLight`改成`pointLight`和`calculatePointLight`
```glsl
uniform PointLight pointLight;
void main()
{
	...
	result += calculatePointLight(objectColor, pointLight, normalN, viewDir);
	...
}
```
然后`shader`改完就要去`render`那边修改对应`cpu`端需要传过来的东西
就是一些光源相关的参数，阴影我们暂时先不处理，因为还没做好点光源对应的`shadowMap`的渲染
```cpp
case MaterialType::PhongPointShadowMaterial: {
	...
	//光源参数的uniform更新
	//pointLight 的更新
	shader->setVector3("pointLight.color", pointLight->mColor);
	shader->setFloat("pointLight.specularIntensity", pointLight->mSpecularIntensity);
	shader->setVector3("pointLight.position", pointLight->getPosition());

	shader->setFloat("pointLight.k2", pointLight->mK2);
	shader->setFloat("pointLight.k1", pointLight->mK1);
	shader->setFloat("pointLight.kc", pointLight->mKc)
	...
}
	break;
```
转到`main.cpp`构建场景，并把相应的关于平行光全换成点光源
构建了一个由一个大立方体，包裹了很多小立方体
```cpp
void prepare() {
	fbo = new Framebuffer(WIDTH, HEIGHT);

	renderer = new Renderer();
	sceneOff = new Scene();
	scene = new Scene();

	//pass 01
	auto roomGeo = Geometry::createBox(20, true);
	auto roomMat = new PhongPointShadowMaterial();
	roomMat->mDiffuse = new Texture("assets/textures/wall.jpg", 0, GL_SRGB_ALPHA);;
	roomMat->mShiness = 32;

	auto roomMesh = new Mesh(roomGeo, roomMat);
	sceneOff->addChild(roomMesh);

	//box 们
	auto boxGeo = Geometry::createBox(2);
	auto boxMat = new PhongPointShadowMaterial();
	boxMat->mDiffuse = new Texture("assets/textures/box.png", 0, GL_SRGB_ALPHA);;
	boxMat->mShiness = 32;

	std::vector<glm::vec3> positions = {
		{-3.5683, -2.7041, -7.0375},
		{-3.0233, 5.2973, 2.0394},
		{3.3926, 6.9407, 3.3232},
		{9.8015, -9.8498, 7.3877},
		{0.8651, -7.4239, 1.6375},
		{2.8383, 6.4861, -8.7925},
		{3.0698, -8.5348, -4.8735},
		{6.1476, 2.2643, -5.0017},
		{6.7825, -4.7561, -4.6169},
		{-8.0400, -1.3347, -7.2126},
	};

	for (int i = 0; i < positions.size(); i++) {
		auto boxMesh = new Mesh(boxGeo, boxMat);
		boxMesh->setPosition(positions[i]);
		sceneOff->addChild(boxMesh);
	}

	//pass 02 postProcessPass:后处理pass
	auto sgeo = Geometry::createScreenPlane();
	auto smat = new ScreenMaterial();
	smat->mScreenTexture = fbo->mColorAttachment;
	auto smesh = new Mesh(sgeo, smat);
	scene->addChild(smesh);


	pointLight = new PointLight();
	pointLight->setPosition(glm::vec3(0.0f, 0.0f, 0.0f));
	pointLight->mSpecularIntensity = 1.0f;
	pointLight->mK2 = 0.0017f;
	pointLight->mK1 = 0.07f;
	pointLight->mKc = 1.0f;

	ambLight = new AmbientLight();
	ambLight->mColor = glm::vec3(0.1f);

}
```
然后我们要去修改一下`createBox`函数，因为原来的法线都是朝向外面的，现在我们要进到内部研究光照，肯定就要把法线转到里面，要不然就没有光照计算的效果了
```cpp
static Geometry* createBox(float size, bool invNormal = false);
```
默认是`false`的，如果是`true`就证明需要进行反转法线,
```cpp
Geometry* Geometry::createBox(float size, bool invNormal) {
	...
	float inv = invNormal ? -1.0 : 1.0;
	float normals[] = {
		//前面
		0.0f, 0.0f, 1.0f * inv,
		0.0f, 0.0f, 1.0f * inv,
		0.0f, 0.0f, 1.0f * inv,
		0.0f, 0.0f, 1.0f * inv,
		//后面
		0.0f, 0.0f, -1.0f * inv,
		0.0f, 0.0f, -1.0f * inv,
		0.0f, 0.0f, -1.0f * inv,
		0.0f, 0.0f, -1.0f * inv,

		//上面
		0.0f, 1.0f * inv, 0.0f,
		0.0f, 1.0f * inv, 0.0f,
		0.0f, 1.0f * inv, 0.0f,
		0.0f, 1.0f * inv, 0.0f,

		//下面
		0.0f, -1.0f * inv, 0.0f,
		0.0f, -1.0f * inv, 0.0f,
		0.0f, -1.0f * inv, 0.0f,
		0.0f, -1.0f * inv, 0.0f,

		//右面
		1.0f * inv, 0.0f, 0.0f,
		1.0f * inv, 0.0f, 0.0f,
		1.0f * inv, 0.0f, 0.0f,
		1.0f * inv, 0.0f, 0.0f,

		//左面
		-1.0f * inv, 0.0f, 0.0f,
		-1.0f * inv, 0.0f, 0.0f,
		-1.0f * inv, 0.0f, 0.0f,
		-1.0f * inv, 0.0f, 0.0f,
	};
	...
}

```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTI4NTE5MDgzOCw1NzY2MDI4NywtNzYxOD
EzNzA2LDE0OTkyMTIzNjAsMTU3NDMyNTk5NSwtMTE5MTQxMDIz
LDE5MTE2ODUxNjksLTE5ODcwMjc1NDgsNTY2NzczMDgyLDUwND
M5Njk2OCwtMTM4NTYzOTU5LC0zNTg2Nzk2MTAsMzU2OTQxMzY1
LDg1OTgxODQ1NywtNTEyNjQ2MTMwLC0yMDg4NzQ2NjEyLC0yMD
g4NzQ2NjEyXX0=
-->