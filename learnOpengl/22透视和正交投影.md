![输入图片说明](/imgs/2024-11-02/SKjmPkNGHvDO3avf.png)
在盒子外面的我们就视为看不到的物体。
# 正交投影
![输入图片说明](/imgs/2024-11-02/TLJtOSGJDG9bW5Yu.png)![输入图片说明](/imgs/2024-11-02/3ZBjs4E8VkrQAUD3.png)
由于缩放是根据坐标系的中心点，所以我们要先**把物体移动到坐标系的中心位置**
![输入图片说明](/imgs/2024-11-02/XN3OChcHxH1lwEJf.png)
## 平移到中心点
![输入图片说明](/imgs/2024-11-02/StscMZrYpJHNJ0jk.png)
## 缩放到[-1,1]
![输入图片说明](/imgs/2024-11-02/3qJEf3fJdPoPSofb.png)
![输入图片说明](/imgs/2024-11-02/eSPuZwd70cLAmryJ.png)
## 总结
modelMatrix：物体在世界坐标系下的变换
viewMatrix：世界坐标转到摄像机坐标系下
projectionMatrix：正交投影到盒子上并转为NDC坐标（[-1, 1]）
![输入图片说明](/imgs/2024-11-02/qpL2Cm7ONyRU8xlW.png)
## 实验
在main.cpp中声明一个`orthoMatrix`
```
glm::mat4 orthoMatrix(1.0);
```
并在main.cpp做一个`prepareOrtho()`函数，该方法用来生成一个投影盒子，将内部顶点转化到NDC坐标中
注意此处，NDC的z轴和摄像头的z轴相反，是为了让眼前的z成为正值，所以NDC坐标系是左手坐标系，OpenGL的世界坐标系为右手
参数依次为left，right，up，down，near，far
可以从上图的投影推导得知
```
void prepareOrtho() {
    orthoMatrix = glm::ortho(-2.0f, 2.0f, -2.0f, 2.0f, 2.0f, -2.0f);
}
```
在main函数中调用这个`prepareOrtho()`函数
```
int main() {
	...
    prepareShader();
    prepareVAO();
    prepareTexture();
    prepareCamera();
    prepareOrtho();
    while (app->update()) {
        render();
        //渲染操作
    }
    app->destroy();
    delete texture;
    return 0;
}
```
去`vertex.glsl`并使用`projectionMatrix`
```
uniform mat4 projectionMatrix;

void main()
{
    vec4 position = vec4(aPos, 1.0);
    position = projectionMatrix * viewMatrix * transform * position;
    gl_Position = position;
    color = aColor;
    uv = aUV;
}
```
然后在render中绑定
```
void render(){
    //执行opengl画布清理操作
    glClear(GL_COLOR_BUFFER_BIT);

    //1 绑定当前的program
    shader->begin();

    shader->setInt("sampler", 0);//此处值为0是因为我们的纹理绑定在0号位上
    shader->setMatrix4x4("transform", transform);
    shader->setMatrix4x4("viewMatrix", viewMatrix);
    shader->setMatrix4x4("projectionMatrix", orthoMatrix);
	...
}
```
### 非NDC数据
所以我们有了view和ortho矩阵，我们就可以将原本的三角形的数据修改为非NDC的形式
```
	//原来的
	/*float positions[] = {
        -0.5f, -0.5f, 0.0f,
        0.5f, -0.5f, 0.0f,
        0.0f, 0.5f, 0.0f
    };
    */
    //new
    float positions[] = {
        -1.0f, 0.0f, 0.0f,
        1.0f, 0.0f, 0.0f,
        0.0f, 1.0f, 0.0f
    };
```
观察输出的三角形，左边的点应该为（-0.5f, 0.0f, 0.0f），上面的点为（0.0f, 0.5f, 0.0f），
这是因为我们的顶点数据被投影盒子转化为NDC坐标了，需要**除以二**
被下面这个函数所作用
```
void prepareOrtho() {
    orthoMatrix = glm::ortho(-2.0f, 2.0f, -2.0f, 2.0f, 2.0f, -2.0f);
}
```
![输入图片说明](/imgs/2024-11-02/B93UoXdfAoD1GHXH.png)
如果把非NDC坐标改成这样，那这样三角形会显示不出来，因为已经超过可视盒子的范围外了
```
float positions[] = {
        -1.0f, 0.0f, -5.0f,
        1.0f, 0.0f, -5.0f,
        0.0f, 1.0f, -5.0f
};
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIzNzQwMjQ5OSwtMzQyMjQ1MjksOTM5ND
Y1NjkzLC0xOTk3NTE4Njk5LDg5MzMyODMxLC0xNTYzODE1MDIz
LDExOTk5MTExMTgsNjE3NzUxNTc4LDE1ODcwMzQ2MzUsMTI2OT
k4MDM5MV19
-->