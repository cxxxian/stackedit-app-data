![输入图片说明](/imgs/2024-11-02/SKjmPkNGHvDO3avf.png)
在盒子外面的我们就视为看不到的物体。
# 正交投影
![输入图片说明](/imgs/2024-11-02/TLJtOSGJDG9bW5Yu.png)![输入图片说明](/imgs/2024-11-02/3ZBjs4E8VkrQAUD3.png)
由于缩放是根据坐标系的中心点，所以我们要先**把物体移动到坐标系的中心位置**
![输入图片说明](/imgs/2024-11-02/XN3OChcHxH1lwEJf.png)
## 平移到中心点
![输入图片说明](/imgs/2024-11-02/StscMZrYpJHNJ0jk.png)
## 缩放到[-1,1]
![输入图片说明](/imgs/2024-11-02/3qJEf3fJdPoPSofb.png)
![输入图片说明](/imgs/2024-11-02/eSPuZwd70cLAmryJ.png)
## 总结
modelMatrix：物体在世界坐标系下的变换
viewMatrix：世界坐标转到摄像机坐标系下
projectionMatrix：正交投影到盒子上并转为NDC坐标（[-1, 1]）
![输入图片说明](/imgs/2024-11-02/qpL2Cm7ONyRU8xlW.png)
## 实验
在main.cpp中声明一个`orthoMatrix`
```
glm::mat4 orthoMatrix(1.0);
```
并在main.cpp做一个`prepareOrtho()`函数，该方法用来生成一个投影盒子，将内部顶点转化到NDC坐标中
```
void prepareOrtho() {
    orthoMatrix = glm::ortho(-2.0f, 2.0f, -2.0f, 2.0f, 2.0f, -2.0f);
}
```
在main函数中调用这个`prepareOrtho()`函数
```
int main() {
	...
    prepareShader();
    prepareVAO();
    prepareTexture();
    prepareCamera();
    prepareOrtho();
    while (app->update()) {
        render();
        //渲染操作
    }
    app->destroy();
    delete texture;
    return 0;
}
```
去`vertex.glsl声明并使用projectionMatrix
```
uniform mat4 projectionMatrix;

void main()
{
    vec4 position = vec4(aPos, 1.0);
    position = projectionMatrix * viewMatrix * transform * position;
    gl_Position = position;
    color = aColor;
    uv = aUV;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQxMzQ0NDI2Niw4OTMzMjgzMSwtMTU2Mz
gxNTAyMywxMTk5OTExMTE4LDYxNzc1MTU3OCwxNTg3MDM0NjM1
LDEyNjk5ODAzOTFdfQ==
-->