![输入图片说明](/imgs/2024-11-02/SKjmPkNGHvDO3avf.png)
在盒子外面的我们就视为看不到的物体。
# 正交投影
![输入图片说明](/imgs/2024-11-02/TLJtOSGJDG9bW5Yu.png)![输入图片说明](/imgs/2024-11-02/3ZBjs4E8VkrQAUD3.png)
由于缩放是根据坐标系的中心点，所以我们要先**把物体移动到坐标系的中心位置**
![输入图片说明](/imgs/2024-11-02/XN3OChcHxH1lwEJf.png)
## 平移到中心点
![输入图片说明](/imgs/2024-11-02/StscMZrYpJHNJ0jk.png)
## 缩放到[-1,1]
![输入图片说明](/imgs/2024-11-02/3qJEf3fJdPoPSofb.png)
![输入图片说明](/imgs/2024-11-02/eSPuZwd70cLAmryJ.png)
## 总结
modelMatrix：物体在世界坐标系下的变换
viewMatrix：世界坐标转到摄像机坐标系下
projectionMatrix：正交投影到盒子上并转为NDC坐标（[-1, 1]）
![输入图片说明](/imgs/2024-11-02/qpL2Cm7ONyRU8xlW.png)
## 实验
在main.cpp中声明一个`orthoMatrix`
```
glm::mat4 orthoMatrix(1.0);
```
并在main.cpp做一个`prepareOrtho()`函数，该方法用来生成一个投影盒子，将内部顶点转化到NDC坐标中
注意此处，NDC的z轴和摄像头的z轴相反，是为了让眼前的z成为正值
```
void prepareOrtho() {
    orthoMatrix = glm::ortho(-2.0f, 2.0f, -2.0f, 2.0f, 2.0f, -2.0f);
}
```
在main函数中调用这个`prepareOrtho()`函数
```
int main() {
	...
    prepareShader();
    prepareVAO();
    prepareTexture();
    prepareCamera();
    prepareOrtho();
    while (app->update()) {
        render();
        //渲染操作
    }
    app->destroy();
    delete texture;
    return 0;
}
```
去`vertex.glsl`并使用`projectionMatrix`
```
uniform mat4 projectionMatrix;

void main()
{
    vec4 position = vec4(aPos, 1.0);
    position = projectionMatrix * viewMatrix * transform * position;
    gl_Position = position;
    color = aColor;
    uv = aUV;
}
```
然后在render中绑定
```
void render(){
    //执行opengl画布清理操作
    glClear(GL_COLOR_BUFFER_BIT);

    //1 绑定当前的program
    shader->begin();

    shader->setInt("sampler", 0);//此处值为0是因为我们的纹理绑定在0号位上
    shader->setMatrix4x4("transform", transform);
    shader->setMatrix4x4("viewMatrix", viewMatrix);
    shader->setMatrix4x4("projectionMatrix", orthoMatrix);
	...
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbOTM5NDY1NjkzLC0xOTk3NTE4Njk5LDg5Mz
MyODMxLC0xNTYzODE1MDIzLDExOTk5MTExMTgsNjE3NzUxNTc4
LDE1ODcwMzQ2MzUsMTI2OTk4MDM5MV19
-->