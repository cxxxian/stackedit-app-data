目标：
1. shader中加入点光源数组，使用循环语句
2. render端加入点光源数组，进行遍历更新uniform
3. 主函数更改

## 目标一
在`phong.frag`中，将原本的变量改为数组
```glsl
#define POINT_LIGHT_NUM 4
uniform PointLight pointLights[POINT_LIGHT_NUM];
```
在`main`函数中就可以利用`for`循环进行点光源计算并累加到`result`
```glsl
void main()
{
    ...
    for(int i = 0; i < POINT_LIGHT_NUM; i++){
        result += calculatePointLight(pointLights[i], normalN, viewDir);
    }
  ...
}
```

## 目标二
到`renderer.h`将`render`函数修改，`pointLight`改为数组`pointLights`
此处两个细节：
一个是取地址`&`，通过&就不会将原数组拷贝一遍进行使用，增高效率
一个是`const`，因为我们不希望数据被更改
```cpp
void render(const std::vector<Mesh*>& meshes, 
	Camera* camera, 
	DirectionalLight* dirLight,
	const std::vector<PointLight*>& pointLights,
	SpotLight* spotLight, 
	AmbientLight* ambLight);
```
`renderer.cpp`实现如下：
```cpp
#include <string>
void Renderer::render(const std::vector<Mesh*>& meshes, Camera* camera, DirectionalLight* dirLight, const std::vector<PointLight*>& pointLights, SpotLight* spotLight, AmbientLight* ambLight)
{
	...
	std::string baseName = "pointLights[";
	baseName.append(std::to_string(i));
	baseName.append("]");

	//pointLight的更新
	for (int i = 0; i < pointLights.size(); i++) {
		auto pointLight = pointLights[i];
		shader->setVector3(baseName + ".color", pointLight->mColor);
		shader->setVector3(baseName + ".position", pointLight->GetPosition());
		shader->setFloat(baseName + ".specularIntensity", pointLight->mSpecularIntensity);
		shader->setFloat(baseName + ".k2", pointLight->mK2);
		shader->setFloat(baseName + ".k1", pointLight->mK1);
		shader->setFloat(baseName + ".kc", pointLight->mKc);
	}
	...
	}
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjc3NTczNDgzLC0zMDU0MDk3MjEsLTIwOD
g3NDY2MTJdfQ==
-->