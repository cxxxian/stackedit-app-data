# framebuffer概念

![输入图片说明](/imgs/2025-02-12/XP5wjtAq69EFjrAx.png)

![输入图片说明](/imgs/2025-02-12/xQjgYrtFiKjrbglM.png)

![输入图片说明](/imgs/2025-02-12/7ntBrcUI7IdRxa42.png)

![输入图片说明](/imgs/2025-02-12/msLOH4AUEsrb3zIh.png)

## 关于framebuffer的API

![输入图片说明](/imgs/2025-02-12/UFLVu85I7Q43jBBJ.png)

![输入图片说明](/imgs/2025-02-13/xWF690NS8REfsKtB.png)

由于我们最后并没有传输任何的数据进去，所以最后一个值是`NULL`

![输入图片说明](/imgs/2024-10-24/uqbMnbfp9BktGoX0.png)

![输入图片说明](/imgs/2025-02-13/kaChTHPzT9Fp47y1.png)

# 完成覆盖平面的矩形几何与材质
## 矩形几何
在`geometry.h`中，创建一个方法用来绘制几何体
```cpp
static Geometry* createScreenPlane();
```
实现如下，比较特殊的地方是此处的`positions`数组
我们将直接设计为二维坐标，直接应用为`NDC`坐标，因为我们要直接对应上屏幕空间，自然也不需要`Z`轴数值了
```cpp
Geometry* Geometry::createScreenPlane()
{
	Geometry* geometry = new Geometry();
	geometry->mIndicesCount = 6;

	//构建数据positions, uvs
	//此处的position只用了二维坐标是因为，我们会直接将此坐标当作NDC坐标传入，而不是之前的三维空间坐标
	float positions[] = {
		-1.0f, 1.0f,
		-1.0f, -1.0f,
		1.0f, -1.0f,
		1.0f, 1.0f
	};
	float uvs[] = {
		0.0f, 1.0f,
		0.0f, 0.0f,
		1.0f, 0.0f,
		1.0f, 1.0f,
	};
	unsigned int indices[] = {
		0, 1, 2,
		0, 2, 3
	};

	//创建vbo，vao等
	//2 VBO创建
	GLuint& posVbo = geometry->mPosVbo, uvVbo = geometry->mUvVbo;
	glGenBuffers(1, &posVbo);
	glBindBuffer(GL_ARRAY_BUFFER, posVbo);
	glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW);

	glGenBuffers(1, &uvVbo);
	glBindBuffer(GL_ARRAY_BUFFER, uvVbo);
	glBufferData(GL_ARRAY_BUFFER, sizeof(uvs), uvs, GL_STATIC_DRAW);

	//EBO创建
	glGenBuffers(1, &geometry->mEbo);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, geometry->mEbo);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

	//VAO创建
	glGenVertexArrays(1, &geometry->mVao);
	glBindVertexArray(geometry->mVao);

	glBindBuffer(GL_ARRAY_BUFFER, posVbo);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (void*)0);

	glBindBuffer(GL_ARRAY_BUFFER, uvVbo);
	glEnableVertexAttribArray(1);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (void*)0);

	//加入ebo到当前的vao
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, geometry->mEbo);

	glBindVertexArray(0);

	return geometry;
}
```

## 材质
### shader
我们先设计一个`screen.vert`，从`depth.vert`直接复制过来修改即可。
```glsl
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aUV;
layout (location = 2) in vec3 aNormal;

out vec2 uv;
out vec3 normal;

uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

void main()
{
	vec4 transformPosition = vec4(aPos, 1.0);

	transformPosition = modelMatrix * transformPosition;

	gl_Position = projectionMatrix * viewMatrix * transformPosition;
	
	uv = aUV;
	normal =  aNormal;
}
```
以上是`depth.vert`，根据我们的设计，`aPos`只需要二维即可，也不需要`normal`向量了，并且因为我们直接使用`NDC`坐标，所以`modelMatrix，viewMatrix，projectionMatrix`这三个变换也都不需要了，全部删掉，
所以最后的`gl_Position`只需要这样计算即可：
`gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);`
`z`值直接赋为`0.0`，然后保证齐次性最后补上一个`1.0`
```glsl
#version 460 core
layout (location = 0) in vec2 aPos;
layout (location = 1) in vec2 aUV;

out vec2 uv;

void main()
{
	gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);

	uv = aUV;
}
```
至于`screen.frag`，我们创建一个`uniform sampler2D screenTexSampler`，作为纹理采样器，直接将纹理作为颜色输出
```glsl
#version 460 core
out vec4 FragColor;

in vec2 uv;
uniform sampler2D screenTexSampler;

void main()
{

	FragColor = texture(screenTexSampler, uv);
}
```
### material
创建一个`ScreenMaterial`，并在`material`中加上对应枚举
```cpp
enum class MaterialType {
	PhongMaterial,
	WhiteMaterial,
	DepthMaterial,
	OpacityMaskMaterial,
	ScreenMaterial
};
```
`ScreenMaterial.h`如下
此处的`mScreenTexture`，到时候`vbo`绘制的颜色缓存会作为贴图赋值给它
```cpp
#pragma once
#include "material.h"
#include "../texture.h"

class ScreenMaterial :public Material {
public:
	ScreenMaterial();
	~ScreenMaterial();

public:
	Texture* mScreenTexture{ nullptr };
};
```

### 加入render流程
先创建`shader`变量并初始化
在`render.h`中
```cpp
private:
	//生成多种不同的shader对象
	//根据材质类型的不同，挑选使用哪一个shader对象
	Shader* mPhongShader{ nullptr };
	Shader* mWhiteShader{ nullptr };
	Shader* mDepthShader{ nullptr };
	Shader* mOpacityMaskShader{ nullptr };
	Shader* mScreenShader{ nullptr };
```
到`render.cpp`中初始化
```cpp
Renderer::Renderer() {
	mPhongShader = new Shader("assets/shaders/phong.vert", "assets/shaders/phong.frag");
	mWhiteShader = new Shader("assets/shaders/white.vert", "assets/shaders/white.frag");
	mDepthShader = new Shader("assets/shaders/depth.vert", "assets/shaders/depth.frag");
	mOpacityMaskShader = new Shader("assets/shaders/phongOpacityMask.vert", "assets/shaders/phongOpacityMask.frag");
	mScreenShader = new Shader("assets/shaders/screen.vert", "assets/shaders/screen.frag");
}
```
完善`pickShader`方法
```cpp
Shader* Renderer::pickShader(MaterialType type) {
	Shader* result = nullptr;

	switch (type) {
	...
	case MaterialType::ScreenMaterial:
		result = mScreenShader;
		break;
	default:
		std::cout << "Unknown material type to pick shader" << std::endl;
		break;
	}

	return result;
}
```
由于我们的shader中只有一个`uniform`变量要传输，所以很简洁
```cpp
最后我们完善渲染流程
//针对单个object进行渲染
void Renderer::renderObject(
	Object* object,
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
		...
		case MaterialType::ScreenMaterial: {
			ScreenMaterial* screenMat = (ScreenMaterial*)material;
			shader->setInt("screenTexSampler", 0);
			screenMat->mScreenTexture->bind();
		}
			break;
		default:
			break;
		}
		//3 绑定vao
		glBindVertexArray(geometry->getVao());

		//4 执行绘制命令
		glDrawElements(GL_TRIANGLES, geometry->getIndicesCount(), GL_UNSIGNED_INT, 0);
	}

}
```
最后我们到`main.cpp`中，创建一个`ScreenPlane`
```cpp
void prepare() {
	renderer = new Renderer();
	scene = new Scene();

	auto Geo = Geometry::createScreenPlane();
	auto Mat = new ScreenMaterial();
	Mat->mScreenTexture = new Texture("assets/textures/grass.jpg", 0);
	auto mesh = new Mesh(Geo, Mat);
	scene->addChild(mesh);
	...
}
```
所以最终我们做到了渲染一个铺满屏幕的平面，动相机也没有反应，因为我们当初设计的该平面是直接根据`NDC`坐标对应屏幕空间，没有任何相机变换矩阵

![输入图片说明](/imgs/2025-02-13/N591PZSH7CiwpYzB.png)

# Texture类加入构造空白纹理的构造函数
在`texture.h`中加入一个构造函数，
因为我们先前制作者的两个构造函数：
一个是从硬盘上读取纹理，还有一个是从内存中解析纹理。
我们x
```cpp
Texture(unsigned int width, unsigned int height, unsigned int unit);
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4NDg2NTMxMzYsLTExMzI0MzI4ODksLT
EyMDg3MDc5MzEsLTEwNTQ2MzYwOTQsLTE1MDQ3OTQ3MDEsLTE5
NDk1OTU1NDMsLTEwMDA4NjEyMjEsMjg1NzUzODcxLC03ODQyMz
IyMTAsMjAwMTUyNzg0LDM5MTYyMjM3MCwtMTU0OTgxNjczOF19

-->