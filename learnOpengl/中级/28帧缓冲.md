## framebuffer概念

![输入图片说明](/imgs/2025-02-12/XP5wjtAq69EFjrAx.png)

![输入图片说明](/imgs/2025-02-12/xQjgYrtFiKjrbglM.png)

![输入图片说明](/imgs/2025-02-12/7ntBrcUI7IdRxa42.png)

![输入图片说明](/imgs/2025-02-12/msLOH4AUEsrb3zIh.png)

## 关于framebuffer的API

![输入图片说明](/imgs/2025-02-12/UFLVu85I7Q43jBBJ.png)

![输入图片说明](/imgs/2025-02-13/xWF690NS8REfsKtB.png)

由于我们最后并没有传输任何的数据进去，所以最后一个值是`NULL`

![输入图片说明](/imgs/2024-10-24/uqbMnbfp9BktGoX0.png)

![输入图片说明](/imgs/2025-02-13/kaChTHPzT9Fp47y1.png)

# 完成覆盖平面的矩形几何与材质
### 矩形几何
在`geometry.h`中，创建一个方法用来绘制几何体
```cpp
static Geometry* createScreenPlane();
```
实现如下，比较特殊的地方是此处的`positions`数组
我们将直接设计为二维坐标，直接应用为`NDC`坐标，因为我们要直接对应上屏幕空间，自然也不需要`Z`轴数值了
```cpp
Geometry* Geometry::createScreenPlane()
{
	Geometry* geometry = new Geometry();
	geometry->mIndicesCount = 6;

	//构建数据positions, uvs
	//此处的position只用了二维坐标是因为，我们会直接将此坐标当作NDC坐标传入，而不是之前的三维空间坐标
	float positions[] = {
		-1.0f, 1.0f,
		-1.0f, -1.0f,
		1.0f, -1.0f,
		1.0f, 1.0f
	};
	float uvs[] = {
		0.0f, 1.0f,
		0.0f, 0.0f,
		1.0f, 0.0f,
		1.0f, 1.0f,
	};
	unsigned int indices[] = {
		0, 1, 2,
		0, 2, 3
	};

	//创建vbo，vao等
	//2 VBO创建
	GLuint& posVbo = geometry->mPosVbo, uvVbo = geometry->mUvVbo;
	glGenBuffers(1, &posVbo);
	glBindBuffer(GL_ARRAY_BUFFER, posVbo);
	glBufferData(GL_ARRAY_BUFFER, sizeof(positions), positions, GL_STATIC_DRAW);

	glGenBuffers(1, &uvVbo);
	glBindBuffer(GL_ARRAY_BUFFER, uvVbo);
	glBufferData(GL_ARRAY_BUFFER, sizeof(uvs), uvs, GL_STATIC_DRAW);

	//EBO创建
	glGenBuffers(1, &geometry->mEbo);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, geometry->mEbo);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);

	//VAO创建
	glGenVertexArrays(1, &geometry->mVao);
	glBindVertexArray(geometry->mVao);

	glBindBuffer(GL_ARRAY_BUFFER, posVbo);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (void*)0);

	glBindBuffer(GL_ARRAY_BUFFER, uvVbo);
	glEnableVertexAttribArray(1);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (void*)0);

	//加入ebo到当前的vao
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, geometry->mEbo);

	glBindVertexArray(0);

	return geometry;
}
```

### 材质
我们先设计一个`screen.vert`，从`depth.vert`直接复制过来修改即可。
```glsl
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aUV;
layout (location = 2) in vec3 aNormal;

out vec2 uv;
out vec3 normal;

uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;

void main()
{
	vec4 transformPosition = vec4(aPos, 1.0);

	transformPosition = modelMatrix * transformPosition;

	gl_Position = projectionMatrix * viewMatrix * transformPosition;
	
	uv = aUV;
	normal =  aNormal;
}
```
以上是`depth.vert`，根据我们的设计，`aPos`只需要二维即可，也不需要`normal`向量了，并且因为我们直接使用`NDC`坐标，所以`modelMatrix，viewMatrix，projectionMatrix`这三个变换也都不需要了
```glsl
#version 460 core
layout (location = 0) in vec2 aPos;
layout (location = 1) in vec2 aUV;

out vec2 uv;


void main()
{
	gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0);

	uv = aUV;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTEyNzMxMDI2OSwyODU3NTM4NzEsLTc4ND
IzMjIxMCwyMDAxNTI3ODQsMzkxNjIyMzcwLC0xNTQ5ODE2NzM4
XX0=
-->