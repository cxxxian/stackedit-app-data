# 原理解释

## 法线

![输入图片说明](/imgs/2025-02-18/GetKwgz7ByxxkhAz.png)

解释一下模型为什么法线需要朝上？
因为如果法线朝前的话，根据光照系统的设计，正面会亮，背面则会黑，法线朝上就不会有正反面的区分

## 风力

![输入图片说明](/imgs/2025-02-18/gjyrtOUQ2Ik0ltCU.png)

如何实现风力摆动
利用`rgb`通道
把最上面的`r`值设置为`1`，最下面设置为`0`，我们就得到了一个权重因子，并且`OpenGL`还会自己做插值得出中间数值

# 实例加载与几何更改
## 1.Geometry增加构造函数，加入Color的Attribute
在`geometry.h`
创建一个带有`colors`属性的构造函数，以及创建`color`的`vbo`
```cpp
public:
	Geometry(
		const std::vector<float>& positions,
		const std::vector<float>& normals,
		const std::vector<float>& uvs,
		const std::vector<float>& colors,
		const std::vector<unsigned int>& indices
	);
private:
	GLuint mVao{ 0 };
	GLuint mPosVbo{ 0 };
	GLuint mUvVbo{ 0 };
	GLuint mColorVbo{ 0 };
	GLuint mNormalVbo{ 0 };
	GLuint mEbo{ 0 };
```
在`geometry.cpp`中实现构造方法，有`color`的`vbo`和`vao`对应的创建
```cpp
Geometry::Geometry(const std::vector<float>& positions, const std::vector<float>& normals, const std::vector<float>& uvs, const std::vector<float>& colors, const std::vector<unsigned int>& indices)
{
	mIndicesCount = indices.size();

	glGenBuffers(1, &mPosVbo);
	glBindBuffer(GL_ARRAY_BUFFER, mPosVbo);
	glBufferData(GL_ARRAY_BUFFER, positions.size() * sizeof(float), positions.data(), GL_STATIC_DRAW);

	glGenBuffers(1, &mUvVbo);
	glBindBuffer(GL_ARRAY_BUFFER, mUvVbo);
	glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(float), uvs.data(), GL_STATIC_DRAW);

	glGenBuffers(1, &mNormalVbo);
	glBindBuffer(GL_ARRAY_BUFFER, mNormalVbo);
	glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(float), normals.data(), GL_STATIC_DRAW);

	glGenBuffers(1, &mColorVbo);
	glBindBuffer(GL_ARRAY_BUFFER, mColorVbo);
	glBufferData(GL_ARRAY_BUFFER, colors.size() * sizeof(float), colors.data(), GL_STATIC_DRAW);

	//3 EBO创建
	glGenBuffers(1, &mEbo);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mEbo);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);

	//4 VAO创建
	glGenVertexArrays(1, &mVao);
	glBindVertexArray(mVao);

	glBindBuffer(GL_ARRAY_BUFFER, mPosVbo);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 3, (void*)0);

	glBindBuffer(GL_ARRAY_BUFFER, mUvVbo);
	glEnableVertexAttribArray(1);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (void*)0);

	glBindBuffer(GL_ARRAY_BUFFER, mNormalVbo);
	glEnableVertexAttribArray(2);
	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 3, (void*)0);

	glBindBuffer(GL_ARRAY_BUFFER, mNormalVbo);
	glEnableVertexAttribArray(3);
	glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 3, (void*)0);

	//5.4 加入ebo到当前的vao
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mEbo);

	glBindVertexArray(0);
}
```
## 2.创建实例读取模型的Loader
我们原来的`Loader`只支持读取模型并创建`Mesh`，但是我们现在希望读取出来的是`InstanceMesh`

### 2.1更改Mesh为InstancedMesh（遍历模型层级，设置matrix数组）
所以把原本的`assimpLoader`复制过来修改类名即可
由于创建实例我们需要确定有多少个数量。
这三个方法是嵌套调用的，`load`调用`processNode`，`processNode`调用`processMesh`，所以三个方法都要加上`instanceCount`

```cpp
public:
	static Object* load(const std::string& path, int instanceCount);

private:
	static void processNode(aiNode* ainode, 
		Object* parent, 
		const aiScene* scene,
		const std::string& rootPath,
		int instanceCount
	);

	static InstancedMesh* processMesh(
		aiMesh* aimesh, 
		const aiScene* scene,
		const std::string& rootPath,
		int instanceCount
	);
```
然后将`Mesh`为`InstancedMesh`
```cpp
static InstancedMesh* processMesh(
	aiMesh* aimesh, 
	const aiScene* scene,
	const std::string& rootPath,
	int instanceCount
);
```
现在开始解决一个小问题（遍历模型层级，设置`matrix`数组）
为什么要这么做，因为我们读取的模型类似于树形结构，这时候我们设置位置矩阵就会出现问题了，
因为我们以前是直接声明一个几何体，直接创建位置矩阵赋给它，但是现在我们具有层级关系了，比如说我们的`InstanceMesh`在第三层，前两层都只是普通的`Object`，我们就要先遍历前两层才能设置得到`InstanceMesh`的`matrix`，设置在`Object`上肯定是错误的

在`main.cpp`中创建一个方法
```cpp
void setInstanceMatrix(Object* obj, int index, glm::mat4 matrix) {
	if (obj->getType() == ObjectType::InstancedMesh) {
		InstancedMesh* im = (InstancedMesh*)obj;
		im->mInstanceMatrices[index] = matrix;
	 }
	auto children = obj->getChildren();
	for (int i = 0; i < children.size(); i++) {
		setInstanceMatrix(children[i], index, matrix);
	}
}
```
所以我们就可以在`main.cpp`中进行初始化以及调用
初始化位置矩阵，并调用`setInstanceMatrix`分别绑定给`InstancedMesh`的`im->mInstanceMatrices[index]`身上
```cpp
void prepare() {
	...
	auto sphereGeo = Geometry::createSphere(4.0f);
	auto sphereMat = new PhongInstanceMaterial();
	sphereMat->mDiffuse = new Texture("assets/textures/earth.png", 0);

	auto grassModel = AssimpInstanceLoader::load("assets/fbx//grassNew.obj", 2);
	auto transform0 = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));
	auto transform1 = glm::translate(glm::mat4(1.0f), glm::vec3(100.0f, 0.0f, 0.0f));
	setInstanceMatrix(grassModel, 0, transform0);
	setInstanceMatrix(grassModel, 1, transform1);
	...
}
```
然后很重要，我们此时只是设置了实例的`Matrix`，我们还未更新到`vbo`中，
就像以前的几何体实例绘制一样
以前的如下，设置完矩阵后需要进行`vbo`的更新
```cpp
sphereMesh->mInstanceMatrices[0] = transform0;
sphereMesh->mInstanceMatrices[1] = transform1;
sphereMesh->mInstanceMatrices[2] = transform2;
sphereMesh->updateMatrices();
```
但是我们现在是读取的模型，有树状层级结构，所以又要进行一次层级遍历
同样在`main.cpp`中设计方法
```cpp
void updateInstanceMatrix(Object* obj) {
	if (obj->getType() == ObjectType::InstancedMesh) {
		InstancedMesh* im = (InstancedMesh*)obj;
		im->updateMatrices();
	}
	auto children = obj->getChildren();
	for (int i = 0; i < children.size(); i++) {
		updateInstanceMatrix(children[i]);
	}
}
```
然后我们到`prepare`中调用，在设置好`matrix`后调用即可
```cpp
void prepare() {
	...
	auto grassModel = AssimpInstanceLoader::load("assets/fbx//grassNew.obj", 2);
	auto transform0 = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));
	auto transform1 = glm::translate(glm::mat4(1.0f), glm::vec3(100.0f, 0.0f, 0.0f));
	setInstanceMatrix(grassModel, 0, transform0);
	setInstanceMatrix(grassModel, 1, transform1);
	updateInstanceMatrix(grassModel);
	...
}
```
还有一个问题，既然要绘制实例物体，就得对应使用Instance材质，但是目前我们`AssimpInstanceLoader`的`processMesh`里面还使用的是`PhongMaterial`
```cpp
InstancedMesh* AssimpInstanceLoader::processMesh(aiMesh* aimesh, const aiScene* scene, const std::string& rootPath, int instanceCount) {
	...
	auto geometry = new Geometry(positions, normals, uvs, colors, indices);
	auto material = new PhongMaterial();
	...
}
```
也很简单，直接换成`phongInstanceMaterial`就好
修改如下：
```cpp
auto geometry = new Geometry(positions, normals, uvs, colors, indices);
auto material = new PhongInstanceMaterial();
```

### 2.2更改Geometry生成加入ColorAttribute
加入对颜色的解析，以及使用新的构造函数生成`geometry`
```cpp
InstancedMesh* AssimpInstanceLoader::processMesh(aiMesh* aimesh, const aiScene* scene, const std::string& rootPath, int instanceCount) {
	std::vector<float> positions;
	std::vector<float> normals;
	std::vector<float> uvs;
	std::vector<float> colors;
	std::vector<unsigned int> indices;

	for (int i = 0; i < aimesh->mNumVertices; i++) {
	...

		//第i个顶点的颜色
		//关注其第0个颜色
		if (aimesh->HasVertexColors(0)) {
			colors.push_back(aimesh->mColors[0][i].r);
			colors.push_back(aimesh->mColors[0][i].g);
			colors.push_back(aimesh->mColors[0][i].b);
		}

	...

	auto geometry = new Geometry(positions, normals, uvs, colors, indices);
	auto material = new PhongMaterial();

	...
	
	return new InstancedMesh(geometry ,material, instanceCount);
}
```
## 3.编写统一赋材质的函数
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE0MDY1MjAxMTAsLTU1MDM5NTkwOSwtNz
Q2OTM1MTg0LC0xNzU3MzYxNTA1LC03OTQzOTk1NDYsLTE4Nzk3
NzE1MjYsODg4NTE3NjEsLTUxNjE0NDYzNSwtMTkzMjE1NzQyM1
19
-->