# 原理解释

## 法线

![输入图片说明](/imgs/2025-02-18/GetKwgz7ByxxkhAz.png)

解释一下模型为什么法线需要朝上？
因为如果法线朝前的话，根据光照系统的设计，正面会亮，背面则会黑，法线朝上就不会有正反面的区分

## 风力

![输入图片说明](/imgs/2025-02-18/gjyrtOUQ2Ik0ltCU.png)

如何实现风力摆动
利用`rgb`通道
把最上面的`r`值设置为`1`，最下面设置为`0`，我们就得到了一个权重因子，并且`OpenGL`还会自己做插值得出中间数值

# 代码实现
## 1.Geometry增加构造函数，加入Color的Attribute
在`geometry.h`
创建一个带有`colors`属性的构造函数，以及创建`color`的`vbo`
```cpp
public:
	Geometry(
		const std::vector<float>& positions,
		const std::vector<float>& normals,
		const std::vector<float>& uvs,
		const std::vector<float>& colors,
		const std::vector<unsigned int>& indices
	);
private:
	GLuint mVao{ 0 };
	GLuint mPosVbo{ 0 };
	GLuint mUvVbo{ 0 };
	GLuint mColorVbo{ 0 };
	GLuint mNormalVbo{ 0 };
	GLuint mEbo{ 0 };
```
在`geometry.cpp`中实现构造方法，有`color`的`vbo`和`vao`对应的创建
```cpp
Geometry::Geometry(const std::vector<float>& positions, const std::vector<float>& normals, const std::vector<float>& uvs, const std::vector<float>& colors, const std::vector<unsigned int>& indices)
{
	mIndicesCount = indices.size();

	glGenBuffers(1, &mPosVbo);
	glBindBuffer(GL_ARRAY_BUFFER, mPosVbo);
	glBufferData(GL_ARRAY_BUFFER, positions.size() * sizeof(float), positions.data(), GL_STATIC_DRAW);

	glGenBuffers(1, &mUvVbo);
	glBindBuffer(GL_ARRAY_BUFFER, mUvVbo);
	glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(float), uvs.data(), GL_STATIC_DRAW);

	glGenBuffers(1, &mNormalVbo);
	glBindBuffer(GL_ARRAY_BUFFER, mNormalVbo);
	glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(float), normals.data(), GL_STATIC_DRAW);

	glGenBuffers(1, &mColorVbo);
	glBindBuffer(GL_ARRAY_BUFFER, mColorVbo);
	glBufferData(GL_ARRAY_BUFFER, colors.size() * sizeof(float), colors.data(), GL_STATIC_DRAW);

	//3 EBO创建
	glGenBuffers(1, &mEbo);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mEbo);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);

	//4 VAO创建
	glGenVertexArrays(1, &mVao);
	glBindVertexArray(mVao);

	glBindBuffer(GL_ARRAY_BUFFER, mPosVbo);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 3, (void*)0);

	glBindBuffer(GL_ARRAY_BUFFER, mUvVbo);
	glEnableVertexAttribArray(1);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (void*)0);

	glBindBuffer(GL_ARRAY_BUFFER, mNormalVbo);
	glEnableVertexAttribArray(2);
	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 3, (void*)0);

	glBindBuffer(GL_ARRAY_BUFFER, mNormalVbo);
	glEnableVertexAttribArray(3);
	glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 3, (void*)0);

	//5.4 加入ebo到当前的vao
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mEbo);

	glBindVertexArray(0);
}
```
## 2.创建实例读取模型的Loader
我们原来的`Loader`只支持读取模型并创建`Mesh`，但是我们现在希望读取出来的是`InstanceMesh`

### 2.1更改Mesh为InstancedMesh（遍历模型层级，设置matrix数组）
所以把原本的`assimpLoader`复制过来修改类名即可
由于创建实例我们需要确定有多少个数量。
这三个方法是嵌套调用的，`load`调用`processNode`，`processNode`调用`processMesh`，所以三个方法都要加上`instanceCount`

```cpp
public:
	static Object* load(const std::string& path, int instanceCount);

private:
	static void processNode(aiNode* ainode, 
		Object* parent, 
		const aiScene* scene,
		const std::string& rootPath,
		int instanceCount
	);

	static InstancedMesh* processMesh(
		aiMesh* aimesh, 
		const aiScene* scene,
		const std::string& rootPath,
		int instanceCount
	);
```
然后将`Mesh`为`InstancedMesh`
```cpp
static InstancedMesh* processMesh(
	aiMesh* aimesh, 
	const aiScene* scene,
	const std::string& rootPath,
	int instanceCount
);
```
现在开始解决一个小问题（遍历模型层级，设置`matrix`数组）
为什么要这么做，因为我们读取的模型类似于树形结构，这时候我们设置位置矩阵就会出现问题了，
因为我们以前是直接声明一个几何体，直接创建位置矩阵赋给它，但是现在我们具有层级关系了，比如说我们的`InstanceMesh`在第三层，前两层都只是普通的`Object`，我们就要先遍历前两层才能设置得到`InstanceMesh`的`matrix`，设置在`Object`上肯定是错误的

在`main.cpp`中创建一个方法
```cpp
void setInstanceMatrix(Object* obj, int index, glm::mat4 matrix) {
	if (obj->getType() == ObjectType::InstancedMesh) {
		InstancedMesh* im = (InstancedMesh*)obj;
		im->mInstanceMatrices[index] = matrix;
	 }
	auto children = obj->getChildren();
	for (int i = 0; i < children.size(); i++) {
		setInstanceMatrix(children[i], index, matrix);
	}
}
```
所以我们就可以在`main.cpp`中进行初始化以及调用
初始化位置矩阵，并调用`setInstanceMatrix`分别绑定给`InstancedMesh`的`im->mInstanceMatrices[index]`身上
```cpp
void prepare() {
	...
	auto sphereGeo = Geometry::createSphere(4.0f);
	auto sphereMat = new PhongInstanceMaterial();
	sphereMat->mDiffuse = new Texture("assets/textures/earth.png", 0);

	auto grassModel = AssimpInstanceLoader::load("assets/fbx//grassNew.obj", 2);
	auto transform0 = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));
	auto transform1 = glm::translate(glm::mat4(1.0f), glm::vec3(100.0f, 0.0f, 0.0f));
	setInstanceMatrix(grassModel, 0, transform0);
	setInstanceMatrix(grassModel, 1, transform1);
	...
}
```
然后很重要，我们此时只是设置了实例的`Matrix`，我们还未更新到`vbo`中，
就像以前的几何体实例绘制一样
以前的如下，设置完矩阵后需要进行`vbo`的更新
```cpp
sphereMesh->mInstanceMatrices[0] = transform0;
sphereMesh->mInstanceMatrices[1] = transform1;
sphereMesh->mInstanceMatrices[2] = transform2;
sphereMesh->updateMatrices();
```
但是我们现在是读取的模型，有树状层级结构，所以又要进行一次层级遍历
同样在`main.cpp`中设计方法
```cpp
void updateInstanceMatrix(Object* obj) {
	if (obj->getType() == ObjectType::InstancedMesh) {
		InstancedMesh* im = (InstancedMesh*)obj;
		im->updateMatrices();
	}
	auto children = obj->getChildren();
	for (int i = 0; i < children.size(); i++) {
		updateInstanceMatrix(children[i]);
	}
}
```
然后我们到`prepare`中调用，在设置好`matrix`后调用即可
```cpp
void prepare() {
	...
	auto grassModel = AssimpInstanceLoader::load("assets/fbx//grassNew.obj", 2);
	auto transform0 = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));
	auto transform1 = glm::translate(glm::mat4(1.0f), glm::vec3(100.0f, 0.0f, 0.0f));
	setInstanceMatrix(grassModel, 0, transform0);
	setInstanceMatrix(grassModel, 1, transform1);
	updateInstanceMatrix(grassModel);
	...
}
```
还有一个问题，既然要绘制实例物体，就得对应使用Instance材质，但是目前我们`AssimpInstanceLoader`的`processMesh`里面还使用的是`PhongMaterial`
```cpp
InstancedMesh* AssimpInstanceLoader::processMesh(aiMesh* aimesh, const aiScene* scene, const std::string& rootPath, int instanceCount) {
	...
	auto geometry = new Geometry(positions, normals, uvs, colors, indices);
	auto material = new PhongMaterial();
	...
}
```
也很简单，直接换成`phongInstanceMaterial`就好
修改如下：
```cpp
auto geometry = new Geometry(positions, normals, uvs, colors, indices);
auto material = new PhongInstanceMaterial();
```

### 2.2更改Geometry生成加入ColorAttribute
加入对颜色的解析，以及使用新的构造函数生成`geometry`
```cpp
InstancedMesh* AssimpInstanceLoader::processMesh(aiMesh* aimesh, const aiScene* scene, const std::string& rootPath, int instanceCount) {
	std::vector<float> positions;
	std::vector<float> normals;
	std::vector<float> uvs;
	std::vector<float> colors;
	std::vector<unsigned int> indices;

	for (int i = 0; i < aimesh->mNumVertices; i++) {
	...

		//第i个顶点的颜色
		//关注其第0个颜色
		if (aimesh->HasVertexColors(0)) {
			colors.push_back(aimesh->mColors[0][i].r);
			colors.push_back(aimesh->mColors[0][i].g);
			colors.push_back(aimesh->mColors[0][i].b);
		}

	...

	auto geometry = new Geometry(positions, normals, uvs, colors, indices);
	auto material = new PhongMaterial();

	...
	
	return new InstancedMesh(geometry ,material, instanceCount);
}
```

做完以上的工作，将`grassModel`加到场景中渲染，就可以了
```cpp
void prepare() {
	...
	auto grassModel = AssimpInstanceLoader::load("assets/fbx//grassNew.obj", 2);
	auto transform0 = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));
	auto transform1 = glm::translate(glm::mat4(1.0f), glm::vec3(5.0f, 0.0f, 0.0f));
	setInstanceMatrix(grassModel, 0, transform0);
	setInstanceMatrix(grassModel, 1, transform1);
	updateInstanceMatrix(grassModel);

	scene->addChild(grassModel);
	...
}
```
但是可以看到目前还没有材质信息，因为我们模型本来就不带材质

![输入图片说明](/imgs/2025-02-18/Se3VazPTSRtzbRQA.png)

## 3.编写统一赋材质的函数
### 3.1新建一个GrassInstanceMaterial
`grassInstanceMaterial.h`如下：
```cpp
#pragma once
#include "material.h"
#include "../texture.h"

class GrassInstanceMaterial :public Material {
public:
	GrassInstanceMaterial();
	~GrassInstanceMaterial();

public:
	Texture*	mDiffuse{ nullptr };
	Texture*	mSpecularMask{ nullptr };
	float		mShiness{ 1.0f };
};
```
`grassInstanceMaterial.cpp`如下：
```cpp
#include "grassInstanceMaterial.h"

GrassInstanceMaterial::GrassInstanceMaterial() {
	mType = MaterialType::GrassInstanceMaterial;
}

GrassInstanceMaterial::~GrassInstanceMaterial() {
}
```
并去`material.h`中加入相应枚举类
### 3.2新建一套shader
直接用`phongInstance.vert`和`phongInstance.frag`复制过来即可

然后去`render.h`中创建对应`shader`对应
```cpp
private:
	...
	Shader* mGrassInstanceShader{ nullptr };
```
然后去`render.cpp`初始化
```cpp
Renderer::Renderer() {
	...
	mGrassInstanceShader = new Shader("assets/shaders/grassInstance.vert", "assets/shaders/grassInstance.frag");
}
```
完善`pickShader`方法
```cpp
Shader* Renderer::pickShader(MaterialType type) {
	Shader* result = nullptr;
	switch (type) {
	...
	case MaterialType::GrassInstanceMaterial:
		result = mGrassInstanceShader;
		break;
	...
	}
	return result;
}
```
最后是`renderObject`方法，加入相应`case`
```cpp
//针对单个object进行渲染
void Renderer::renderObject(
	Object* object,
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	...
		case MaterialType::GrassInstanceMaterial: {
			GrassInstanceMaterial* grassMat = (GrassInstanceMaterial*)material;
			InstancedMesh* im = (InstancedMesh*)mesh;

			//diffuse贴图帧更新
			//将纹理采样器与纹理单元进行挂钩
			shader->setInt("sampler", 0);
			//将纹理与纹理单元进行挂钩
			grassMat->mDiffuse->bind();

			//mvp
			shader->setMatrix4x4("modelMatrix", mesh->getModelMatrix());
			shader->setMatrix4x4("viewMatrix", camera->getViewMatrix());
			shader->setMatrix4x4("projectionMatrix", camera->getProjectionMatrix());

			auto normalMatrix = glm::mat3(glm::transpose(glm::inverse(mesh->getModelMatrix())));
			shader->setMatrix3x3("normalMatrix", normalMatrix);

			//光源参数的uniform更新
			//directionalLight 的更新
			shader->setVector3("directionalLight.color", dirLight->mColor);
			shader->setVector3("directionalLight.direction", dirLight->mDirection);
			shader->setFloat("directionalLight.specularIntensity", dirLight->mSpecularIntensity);


			shader->setFloat("shiness", grassMat->mShiness);

			shader->setVector3("ambientColor", ambLight->mColor);

			//相机信息更新
			shader->setVector3("cameraPosition", camera->mPosition);

			//透明度
			shader->setFloat("opacity", material->mOpacity);
		}
												break;
		default:
			break;
		}
	...	
	}
}
```
现在想想正面应用上材质呢，因为我们读取模型没有专门做赋予材质的功能，只能用模型本身自带的材质
所以我们刚刚做了一套关于草的`material`
依旧是使用层级遍历，给每一个`InstancedMesh`换上`grassInstanceMaterial`即可
先声明一个`grassMaterial`
```cpp
#include "glframework/material/grassInstanceMaterial.h"
GrassInstanceMaterial* grassMaterial = nullptr;
```
然后再设计一个层级遍历替换材质的方法
```cpp
void setInstanceMaterial(Object* obj, Material* material) {
	if (obj->getType() == ObjectType::InstancedMesh) {
		InstancedMesh* im = (InstancedMesh*)obj;
		im->mMaterial = material;
	}
	auto children = obj->getChildren();
	for (int i = 0; i < children.size(); i++) {
		setInstanceMaterial(children[i], material);
	}
}
```
最后在`prepare`方法中使用即可
初始化`grassMaterial`，应用上草的贴图，然后调用`setInstanceMaterial`进行层级遍历替换贴图
```cpp
void prepare() {
	...
	auto grassModel = AssimpInstanceLoader::load("assets/fbx//grassNew.obj", 2);
	auto transform0 = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));
	auto transform1 = glm::translate(glm::mat4(1.0f), glm::vec3(5.0f, 0.0f, 0.0f));
	setInstanceMatrix(grassModel, 0, transform0);
	setInstanceMatrix(grassModel, 1, transform1);
	updateInstanceMatrix(grassModel);

	grassMaterial = new GrassInstanceMaterial();
	grassMaterial->mDiffuse = new Texture("assets/textures/GRASS.PNG", 0);
	setInstanceMaterial(grassModel, grassMaterial);

	scene->addChild(grassModel);
	...
}
```
效果如下，就替换上啦

![输入图片说明](/imgs/2025-02-18/J1P6V9Sv5e84kqyU.png)

## 4.透明与排序
### 4.1GrassInstanceMaterial与shader加入透明蒙版
在`grassInstance.frag`中加上透明蒙版，以及采样作为`alpha`值
```glsl
uniform sampler2D opacityMask;//透明蒙版
void main()
{
	...
	vec3 objectColor  = texture(sampler, uv).xyz;
	float alpha =  texture(opacityMask, uv).r;
	...
	FragColor = vec4(finalColor,alpha * opacity);
}
```
然后去`grassInstanceMaterial.h`加上透明蒙版材质
```cpp
public:
	Texture*	mOpacityMask{ nullptr };
```

有了这个之后我们就可以去`render.cpp`中的`renderObject`方法中使用
将`mOpacityMask`进行绑定以及传输到`gpu`
```cpp
void Renderer::renderObject(
	Object* object,
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	...
		case MaterialType::GrassInstanceMaterial: {
			...
			//diffuse贴图帧更新
			//将纹理采样器与纹理单元进行挂钩
			shader->setInt("sampler", 0);
			//将纹理与纹理单元进行挂钩
			grassMat->mDiffuse->bind();

			shader->setInt("opacityMask", 1);
			//将纹理与纹理单元进行挂钩
			grassMat->mOpacityMask->bind();

			...
		}
		
	}
}
```
最后在`main.cpp`中`prepare`给`mOpacityMask`赋值即可
```cpp
void prepare() {
	...
	auto grassModel = AssimpInstanceLoader::load("assets/fbx//grassNew.obj", 2);
	auto transform0 = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, 0.0f));
	auto transform1 = glm::translate(glm::mat4(1.0f), glm::vec3(5.0f, 0.0f, 0.0f));
	setInstanceMatrix(grassModel, 0, transform0);
	setInstanceMatrix(grassModel, 1, transform1);
	updateInstanceMatrix(grassModel);

	grassMaterial = new GrassInstanceMaterial();
	grassMaterial->mDiffuse = new Texture("assets/textures/GRASS.PNG", 0);
	grassMaterial->mOpacityMask = new Texture("assets/textures/grassMask.png", 1);

	setInstanceMaterial(grassModel, grassMaterial);

	scene->addChild(grassModel);
	...
}
```
问题1.
并没有应用透明蒙版的效果
是因为我们没有开启`mBlend`

![输入图片说明](/imgs/2025-02-18/KhSyF9Pr9MKURp9a.png)

开启`mBlend`之后会发现有剪裁问题，这是因为我们没有关闭深度写入

![输入图片说明](/imgs/2025-02-18/CaGdzhPOkjOqZP4S.png)

所以最后`grassMaterial`的参数设计如下：
```cpp
grassMaterial = new GrassInstanceMaterial();
grassMaterial->mDiffuse = new Texture("assets/textures/GRASS.PNG", 0);
grassMaterial->mOpacityMask = new Texture("assets/textures/grassMask.png", 1);
grassMaterial->mBlend = true;
grassMaterial->mDepthWrite = false;
setInstanceMaterial(grassModel, grassMaterial);
```

成功！

![输入图片说明](/imgs/2025-02-18/QuQKRZkWNf7yA28s.png)

### 4.2实例绘制的透明排序问题解决
我们先构建一个实验场景
构建了一个`20*20`由草构成的方阵
```cpp
void prepare() {
	...
	int rNum = 20;
	int cNum = 20;

	auto grassModel = AssimpInstanceLoader::load("assets/fbx//grassNew.obj", rNum * cNum);
	glm::mat4 translate;
	
	for (int r = 0; r < rNum; r++) {
		for (int c = 0; c < cNum; c++) {
			translate = glm::translate(glm::mat4(1.0f), glm::vec3(0.2 * r, 0.0f, 0.2 * c));
			setInstanceMatrix(grassModel, r * cNum + c, translate);
		}
	}
	updateInstanceMatrix(grassModel);

	grassMaterial = new GrassInstanceMaterial();
	grassMaterial->mDiffuse = new Texture("assets/textures/GRASS.PNG", 0);
	grassMaterial->mOpacityMask = new Texture("assets/textures/grassMask.png", 1);
	grassMaterial->mBlend = true;
	grassMaterial->mDepthWrite = false;
	setInstanceMaterial(grassModel, grassMaterial);

	scene->addChild(grassModel);
	...
}
```

![输入图片说明](/imgs/2025-02-18/N9Zryc250UY8s5J8.png)

会发现很奇怪，其实就是绘制顺序的问题，现在没有做过任何处理的话就是乱序绘制，后面的晚绘制的话会把前面的先绘制的颜色抢掉

以前学过的，绘制需要从后往前绘制，要不然颜色会有问题（即使关闭了深度写入）
对于一个`InstancedMesh`，例如绘制一百个实例，我们无法知道他们分别具体的位置。
解决办法就是，排序实例的`mInstanceMatrices`数组
而且`OpenGL`有一个默认规则，那就是比如我们`mInstanceMatrices`中有`N`个元素，它就会按照从`0~N`号的顺序进行获取，然后从`0`号开始绘制到`N`号。
那么既然`OpenGL`可以保证从`0~N`的顺序绘制，那我们只要将`mInstanceMatrices`

在`instancedMesh`中创建一个方法用来做排序。
```cpp
#include <algorithm>
void InstancedMesh::sortMatrices(glm::mat4 viewMatrix)
{
	std::sort(
		mInstanceMatrices.begin(),
		mInstanceMatrices.end(),
		[viewMatrix](const glm::mat4& a, const glm::mat4 b) {

			//1 计算a的相机系的Z
			auto modelMatrixA = a;
			auto worldPositionA = modelMatrixA * glm::vec4(0.0, 0.0, 0.0, 1.0);
			auto cameraPositionA = viewMatrix * worldPositionA;

			//2 计算b的相机系的Z
			auto modelMatrixB = b;
			auto worldPositionB = modelMatrixB * glm::vec4(0.0, 0.0, 0.0, 1.0);
			auto cameraPositionB = viewMatrix * worldPositionB;

			return cameraPositionA.z < cameraPositionB.z;
		}
	);
}
```
由于sort中的参数需要用到`mInstanceMatrices.begin()`，我们就直接把之前的指针声明换成`vector`声明
```cpp
glm::mat4* mInstanceMatrices{nullptr}
```
改为：
```cpp
std::vector<glm::mat4> mInstanceMatrices{}
```
然后就引入一堆要更换的东西
构造函数初始化`mInstanceMatrices`使用`resize`进行预留空间
```cpp
InstancedMesh::InstancedMesh(
	Geometry* geometry,
	Material* material,
	unsigned int instanceCount
) :Mesh(geometry, material) {
	...
	mInstanceMatrices.resize(instanceCount);
	...
}
```
数据内容使用`mInstanceMatrices.data()`
```cpp
void InstancedMesh::updateMatrices()
{
	...
	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(glm::mat4) * mInstanceCount, mInstanceMatrices.data());
	...
}
```
做完排序方法后，我们就去`render.cpp`中进行调用，因为随着我们摄像机移动肯定要重新计算排序
调用`sortMatrices`之后再进行位置矩阵更新`updateMatrices`
```cpp
void Renderer::renderObject(
	Object* object,
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	...
		case MaterialType::GrassInstanceMaterial: {
			GrassInstanceMaterial* grassMat = (GrassInstanceMaterial*)material;
			InstancedMesh* im = (InstancedMesh*)mesh;

			im->sortMatrices(camera->getViewMatrix());
			im->updateMatrices();

			...
		}
			break;
		...
		
	}
}
```
遮挡关系就正常了

![输入图片说明](/imgs/2025-02-18/m2xv52sXuRe11znt.png)

## 5.随机与法线修整
### 5.1实例的变换矩阵中加入绕y轴的随机旋转
`srand`函数用来获取一个随机数种子
然后我们使用`rand() % 90`来获取一个随机的`90`度以内的旋转
最后`transform = translate * rotate`计算出变化矩阵
这里意为先旋转后平移，这也是一般变换的顺序
```cpp
void prepare() {
	...
	glm::mat4 translate;
	glm::mat4 rotate;
	glm::mat4 transform;

	srand(glfwGetTime());
	for (int r = 0; r < rNum; r++) {
		for (int c = 0; c < cNum; c++) {
			translate = glm::translate(glm::mat4(1.0f), glm::vec3(0.2 * r, 0.0f, 0.2 * c));
			rotate = glm::rotate(glm::radians((float)(rand() % 90)), glm::vec3(0.0f, 1.0f, 0.0f));
			transform = translate * rotate;
			setInstanceMatrix(grassModel, r * cNum + c, transform);
		}
	}
	updateInstanceMatrix(grassModel);

	...

	scene->addChild(grassModel);
	...
}
```

可以看到已经有扰乱的感觉了

![输入图片说明](/imgs/2025-02-18/0rE78XiJ1zdTOlXh.png)

### 5.2实例的vertexShader中，进行NormalMatrix的计算
```cpp
auto normalMatrix = glm::mat3(glm::transpose(glm::inverse(mesh->getModelMatrix())));
shader->setMatrix3x3("normalMatrix", normalMatrix);
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwMjc2OTA1MTQsMTE5NDU5NzQ1MCw2NT
YzNTM0NjYsNzQ0NTkwODExLC00NzAxMDMxNDMsLTM4MzQwMjk2
MiwzMzU2MjQyOTQsODI1MjI3ODc4LDE4OTAwMjk5NjUsMTEyNT
Y4Mjc0NywxMzAyMzM3NDE5LC0xNDA2NTIwMTEwLC01NTAzOTU5
MDksLTc0NjkzNTE4NCwtMTc1NzM2MTUwNSwtNzk0Mzk5NTQ2LC
0xODc5NzcxNTI2LDg4ODUxNzYxLC01MTYxNDQ2MzUsLTE5MzIx
NTc0MjNdfQ==
-->