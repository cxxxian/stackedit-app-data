# 原理解释

## 法线

![输入图片说明](/imgs/2025-02-18/GetKwgz7ByxxkhAz.png)

解释一下模型为什么法线需要朝上？
因为如果法线朝前的话，根据光照系统的设计，正面会亮，背面则会黑，法线朝上就不会有正反面的区分

## 风力

![输入图片说明](/imgs/2025-02-18/gjyrtOUQ2Ik0ltCU.png)

如何实现风力摆动
利用`rgb`通道
把最上面的`r`值设置为`1`，最下面设置为`0`，我们就得到了一个权重因子，并且`OpenGL`还会自己做插值得出中间数值

# 实例加载与几何更改
## 1.Geometry增加构造函数，加入Color的Attribute
在`geometry.h`
创建一个带有`colors`属性的构造函数，以及创建`color`的`vbo`
```cpp
public:
	Geometry(
		const std::vector<float>& positions,
		const std::vector<float>& normals,
		const std::vector<float>& uvs,
		const std::vector<float>& colors,
		const std::vector<unsigned int>& indices
	);
private:
	GLuint mVao{ 0 };
	GLuint mPosVbo{ 0 };
	GLuint mUvVbo{ 0 };
	GLuint mColorVbo{ 0 };
	GLuint mNormalVbo{ 0 };
	GLuint mEbo{ 0 };
```
在`geometry.cpp`中实现构造方法，有`color`的`vbo`和`vao`对应的创建
```cpp
Geometry::Geometry(const std::vector<float>& positions, const std::vector<float>& normals, const std::vector<float>& uvs, const std::vector<float>& colors, const std::vector<unsigned int>& indices)
{
	mIndicesCount = indices.size();

	glGenBuffers(1, &mPosVbo);
	glBindBuffer(GL_ARRAY_BUFFER, mPosVbo);
	glBufferData(GL_ARRAY_BUFFER, positions.size() * sizeof(float), positions.data(), GL_STATIC_DRAW);

	glGenBuffers(1, &mUvVbo);
	glBindBuffer(GL_ARRAY_BUFFER, mUvVbo);
	glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(float), uvs.data(), GL_STATIC_DRAW);

	glGenBuffers(1, &mNormalVbo);
	glBindBuffer(GL_ARRAY_BUFFER, mNormalVbo);
	glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(float), normals.data(), GL_STATIC_DRAW);

	glGenBuffers(1, &mColorVbo);
	glBindBuffer(GL_ARRAY_BUFFER, mColorVbo);
	glBufferData(GL_ARRAY_BUFFER, colors.size() * sizeof(float), colors.data(), GL_STATIC_DRAW);

	//3 EBO创建
	glGenBuffers(1, &mEbo);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mEbo);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);

	//4 VAO创建
	glGenVertexArrays(1, &mVao);
	glBindVertexArray(mVao);

	glBindBuffer(GL_ARRAY_BUFFER, mPosVbo);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 3, (void*)0);

	glBindBuffer(GL_ARRAY_BUFFER, mUvVbo);
	glEnableVertexAttribArray(1);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (void*)0);

	glBindBuffer(GL_ARRAY_BUFFER, mNormalVbo);
	glEnableVertexAttribArray(2);
	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 3, (void*)0);

	glBindBuffer(GL_ARRAY_BUFFER, mNormalVbo);
	glEnableVertexAttribArray(3);
	glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(float) * 3, (void*)0);

	//5.4 加入ebo到当前的vao
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mEbo);

	glBindVertexArray(0);
}
```
## 2.创建实例读取模型的Loader
我们原来的`Loader`只支持读取模型并创建`Mesh`，但是我们现在希望读取出来的是`InstanceMesh`

### 2.1更改Mesh为InstancedMesh
所以把原本的`assimpLoader`复制过来修改类名即可
由于创建实例我们需要确定有多少个数量。
这三个方法是嵌套调用的，load调用
```cpp
public:
	static Object* load(const std::string& path, int instanceCount);

private:
	static void processNode(aiNode* ainode, 
		Object* parent, 
		const aiScene* scene,
		const std::string& rootPath,
		int instanceCount
	);

	static InstancedMesh* processMesh(
		aiMesh* aimesh, 
		const aiScene* scene,
		const std::string& rootPath,
		int instanceCount
	);
```
### 2.2更改Geometry生成加入ColorAttribute
## 3.编写统一赋材质的函数
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQyOTAyMjU5MiwtNTE2MTQ0NjM1LC0xOT
MyMTU3NDIzXX0=
-->