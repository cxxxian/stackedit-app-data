![输入图片说明](/imgs/2025-02-15/1kcIg0ADvqMmLevC.png)

# 制作蒙鼓人

创建`cube.vert`
```glsl
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aUV;

out vec2 uv;

uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;


void main()
{
	vec4 transformPosition = vec4(aPos, 1.0);

	transformPosition = modelMatrix * transformPosition;


	gl_Position = projectionMatrix * viewMatrix * transformPosition;
	
	uv = aUV;
}
```
和`cube.frag`
```glsl
#version 460 core
out vec4 FragColor;

in vec2 uv;

uniform sampler2D diffuse;

void main()
{

	FragColor = vec4(texture(diffuse, uv).rgb, 1.0);
}
```
创建`cubeMaterial.h`
```cpp
#pragma once
#include "material.h"

class CubeMaterial :public Material {
public:
	CubeMaterial();
	~CubeMaterial();
public:
	Texture* mDiffuse{ nullptr };
};
```
以上`mDiffuse`和`shader`中的`diffuse`都只是为了演示方便，后续会删除

和`cubeMaterial.cpp`
```cpp
#include "cubeMaterial.h"

CubeMaterial::CubeMaterial() {
	mType = MaterialType::CubeMaterial;
}

CubeMaterial::~CubeMaterial() {

}
```
然后在`material.h `枚举中添加对应枚举元素
```cpp
enum class MaterialType {
	PhongMaterial,
	WhiteMaterial,
	DepthMaterial,
	OpacityMaskMaterial,
	ScreenMaterial,
	CubeMaterial
};
```
然后去到`render.h`，添加`shader`对象
```cpp
private:
	//生成多种不同的shader对象
	//根据材质类型的不同，挑选使用哪一个shader对象
	Shader* mPhongShader{ nullptr };
	Shader* mWhiteShader{ nullptr };
	Shader* mDepthShader{ nullptr };
	Shader* mOpacityMaskShader{ nullptr };
	Shader* mScreenShader{ nullptr };
	Shader* mCubeShader{ nullptr };
```
并到`render.cpp`声明并且完善`pickShader`函数
```cpp
Renderer::Renderer() {
	mPhongShader = new Shader("assets/shaders/phong.vert", "assets/shaders/phong.frag");
	mWhiteShader = new Shader("assets/shaders/white.vert", "assets/shaders/white.frag");
	mDepthShader = new Shader("assets/shaders/depth.vert", "assets/shaders/depth.frag");
	mOpacityMaskShader = new Shader("assets/shaders/phongOpacityMask.vert", "assets/shaders/phongOpacityMask.frag");
	mScreenShader = new Shader("assets/shaders/screen.vert", "assets/shaders/screen.frag");
	mCubeShader = new Shader("assets/shaders/cube.vert", "assets/shaders/cube.frag");
}
```
```cpp
Shader* Renderer::pickShader(MaterialType type) {
	Shader* result = nullptr;

	switch (type) {
	...
	case MaterialType::CubeMaterial:
		result = mCubeShader;
		break;
	...
	}

	return result;
}
```
最后在`renderObject`加入对应`case`，这里有一句关键代码
`mesh->setPosition(camera->mPosition);`
有了这一句，我们通过`CubeMaterial`渲染出来的几何体就会包裹住摄像机，达到期望（蒙鼓人）的效果
```cpp
//针对单个object进行渲染
void Renderer::renderObject(
	Object* object,
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	...

		switch (material->mType) {
		...
			break;
		case MaterialType::CubeMaterial: {
			CubeMaterial* cubeMat = (CubeMaterial*)material;
			mesh->setPosition(camera->mPosition);
			//mvp
			shader->setMatrix4x4("modelMatrix", mesh->getModelMatrix());
			shader->setMatrix4x4("viewMatrix", camera->getViewMatrix());
			shader->setMatrix4x4("projectionMatrix", camera->getProjectionMatrix());

			shader->setInt("diffuse", 0);
			cubeMat->mDiffuse->bind();
			
		}
			break;
		default:
			break;
		}
		...
	}
}
```

我们先制作一个演示立方体，长度为`1`是为了对应`uv`
```cpp
#include "glframework/material/cubeMaterial.h"
void prepare() {
	renderer = new Renderer();
	scene = new Scene();

	framebuffer = new Framebuffer(WIDTH, HEIGHT);

	auto boxGeo = Geometry::createBox(1.0f);
	auto boxMat = new CubeMaterial();
	boxMat->mDiffuse = new Texture("assets/textures/grass.jpg", 0);
	auto boxMesh = new Mesh(boxGeo, boxMat);
	scene->addChild(boxMesh);
	...
}
```
运行后会发现，我们被一个立方体包裹住了，无论怎么移动摄像机都在立方体正中央

![输入图片说明](/imgs/2025-02-16/00b80vRcbBAnL2Vn.png)

但是我们此时只是单纯实现了一个蒙鼓人效果，我们最终要使用的是天空盒贴图，而不是单纯的`diffuse`贴图可以解决的

# 制作CubeMap纹理对象，chuang'jian
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTU3ODA3OTQ3OSwxNzQ1NDc1NzEzLDMyOD
M4NjUzLC0xMzg0NTYxOCw0NDk2MzEwMTIsNTI3NTI2NTE0LC0x
Nzc1NTg2NTc1LDIyNzQ3NzEwMV19
-->