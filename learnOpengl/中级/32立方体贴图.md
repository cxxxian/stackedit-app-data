![输入图片说明](/imgs/2025-02-15/1kcIg0ADvqMmLevC.png)

# 制作蒙鼓人

创建`cube.vert`
```glsl
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aUV;

out vec2 uv;

uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;


void main()
{
	vec4 transformPosition = vec4(aPos, 1.0);

	transformPosition = modelMatrix * transformPosition;


	gl_Position = projectionMatrix * viewMatrix * transformPosition;
	
	uv = aUV;
}
```
和`cube.frag`
```glsl
#version 460 core
out vec4 FragColor;

in vec2 uv;

uniform sampler2D diffuse;

void main()
{

	FragColor = vec4(texture(diffuse, uv).rgb, 1.0);
}
```
创建`cubeMaterial.h`
```cpp
#pragma once
#include "material.h"

class CubeMaterial :public Material {
public:
	CubeMaterial();
	~CubeMaterial();
public:
	Texture* mDiffuse{ nullptr };
};
```
以上`mDiffuse`和`shader`中的`diffuse`都只是为了演示方便，后续会删除

和`cubeMaterial.cpp`
```cpp
#include "cubeMaterial.h"

CubeMaterial::CubeMaterial() {
	mType = MaterialType::CubeMaterial;
}

CubeMaterial::~CubeMaterial() {

}
```
然后在`material.h `枚举中添加对应枚举元素
```cpp
enum class MaterialType {
	PhongMaterial,
	WhiteMaterial,
	DepthMaterial,
	OpacityMaskMaterial,
	ScreenMaterial,
	CubeMaterial
};
```
然后去到`render.h`，添加`shader`对象
```cpp
private:
	//生成多种不同的shader对象
	//根据材质类型的不同，挑选使用哪一个shader对象
	Shader* mPhongShader{ nullptr };
	Shader* mWhiteShader{ nullptr };
	Shader* mDepthShader{ nullptr };
	Shader* mOpacityMaskShader{ nullptr };
	Shader* mScreenShader{ nullptr };
	Shader* mCubeShader{ nullptr };
```
并到`render.cpp`声明并且完善`pickShader`函数
```cpp
Renderer::Renderer() {
	mPhongShader = new Shader("assets/shaders/phong.vert", "assets/shaders/phong.frag");
	mWhiteShader = new Shader("assets/shaders/white.vert", "assets/shaders/white.frag");
	mDepthShader = new Shader("assets/shaders/depth.vert", "assets/shaders/depth.frag");
	mOpacityMaskShader = new Shader("assets/shaders/phongOpacityMask.vert", "assets/shaders/phongOpacityMask.frag");
	mScreenShader = new Shader("assets/shaders/screen.vert", "assets/shaders/screen.frag");
	mCubeShader = new Shader("assets/shaders/cube.vert", "assets/shaders/cube.frag");
}
```
```cpp
Shader* Renderer::pickShader(MaterialType type) {
	Shader* result = nullptr;

	switch (type) {
	...
	case MaterialType::CubeMaterial:
		result = mCubeShader;
		break;
	...
	}

	return result;
}
```
最后在`renderObject`加入对应`case`，这里有一句关键代码
`mesh->setPosition(camera->mPosition);`
有了这一句，我们通过`CubeMaterial`渲染出来的几何体就会包裹住摄像机，达到期望（蒙鼓人）的效果
```cpp
//针对单个object进行渲染
void Renderer::renderObject(
	Object* object,
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	...

		switch (material->mType) {
		...
			break;
		case MaterialType::CubeMaterial: {
			CubeMaterial* cubeMat = (CubeMaterial*)material;
			mesh->setPosition(camera->mPosition);
			//mvp
			shader->setMatrix4x4("modelMatrix", mesh->getModelMatrix());
			shader->setMatrix4x4("viewMatrix", camera->getViewMatrix());
			shader->setMatrix4x4("projectionMatrix", camera->getProjectionMatrix());

			shader->setInt("diffuse", 0);
			cubeMat->mDiffuse->bind();
			
		}
			break;
		default:
			break;
		}
		...
	}
}
```

我们先制作一个演示立方体，长度为`1`是为了对应`uv`
```cpp
#include "glframework/material/cubeMaterial.h"
void prepare() {
	renderer = new Renderer();
	scene = new Scene();

	framebuffer = new Framebuffer(WIDTH, HEIGHT);

	auto boxGeo = Geometry::createBox(1.0f);
	auto boxMat = new CubeMaterial();
	boxMat->mDiffuse = new Texture("assets/textures/grass.jpg", 0);
	auto boxMesh = new Mesh(boxGeo, boxMat);
	scene->addChild(boxMesh);
	...
}
```
运行后会发现，我们被一个立方体包裹住了，无论怎么移动摄像机都在立方体正中央

![输入图片说明](/imgs/2025-02-16/00b80vRcbBAnL2Vn.png)

但是我们此时只是单纯实现了一个蒙鼓人效果，我们最终要使用的是天空盒贴图，而不是单纯的`diffuse`贴图可以解决的

# 制作CubeMap纹理对象，创建过程加入到Texture类当中
和以前的贴图读取不同之处，我们以前一次只读取一张贴图，只激活了对应的一个纹理单元，如下：
```cpp
unsigned char* data = stbi_load(path.c_str(), &mWidth, &mHeight, &channels, STBI_rgb_alpha);

//2 生成纹理并且激活单元绑定
glGenTextures(1, &mTexture);
//--激活纹理单元--
glActiveTexture(GL_TEXTURE0 + mUnit);
//--绑定纹理对象--
glBindTexture(GL_TEXTURE_2D, mTexture);

//3 传输纹理数据,开辟显存
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

glGenerateMipmap(GL_TEXTURE_2D);

//***释放数据 
stbi_image_free(data);
```
而天空盒需要有六张纹理，即需要开辟六块对应的显存空间
所以举一反三制作构造函数，
原本读取一个路径的构造方法如下：
```cpp
Texture(const std::string& path, unsigned int unit);
```
那读取六个的话就变成路径数组即可
```cpp
Texture(const std::vector<std::string>& paths, unsigned int unit);
```

所以可以写出构造函数如下：
```cpp
//右左上下后前（+x -x +y -y +z -z）提前固定好顺序
Texture::Texture(const std::vector<std::string>& paths, unsigned int unit)
{
	mUnit = unit;

	//1 创建CubeMap对象
	glGenTextures(1, &mTexture);
	glActiveTexture(GL_TEXTURE0 + mUnit);
	glBindTexture(GL_TEXTURE_CUBE_MAP, mTexture);

	//2 循环读取六张贴图，并且放置到cubemap的六个GPU空间内
	int channels;
	int width = 0, height = 0;
	unsigned char* data = nullptr;
	for (int i = 0; i < paths.size(); i++) {
		data = stbi_load(paths[i].c_str(), &width, &height, &channels, STBI_rgb_alpha);
		if (data != nullptr) {
			//data不等于nullptr就把每张纹理传输并开辟显存
			glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
			stbi_image_free(data);

		}
		else {
			std::cout << "Error: CubeMap Texture failed to load at path -" << paths[i] << std::endl;
			stbi_image_free(data);
		}
	}

	//4 设置纹理参数
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);//u
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);//v

} 
```
### 1
把`OpenGL`理解为状态机，我们现在把`mTexture`绑定到`GL_TEXTURE_CUBE_MAP`槽上，那么以后针对`GL_TEXTURE_CUBE_MAP`槽所作的操作都会应用到`mTexture`上

![输入图片说明](/imgs/2025-02-16/To9xsN5HNuQjlSJq.png)

### 2
开辟显存对应的名字，此时注意，我们是朝向`-z`轴的，所以`NEGATIVE_Z`是正面

![输入图片说明](/imgs/2025-02-16/R2Vg2tV8aYDwNB8E.png)

### 3

![输入图片说明](/imgs/2025-02-16/lcjjTanbL8VsN5Au.png)
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwOTM0Njc1MTcsMTcxNDg2ODk5MywtMT
k1MDIyNTE2MiwxNTM1NTI4MzIxLC03NDU4NjQ1MzMsLTE2MjU1
NTk0NDAsMTc0NTQ3NTcxMywzMjgzODY1MywtMTM4NDU2MTgsND
Q5NjMxMDEyLDUyNzUyNjUxNCwtMTc3NTU4NjU3NSwyMjc0Nzcx
MDFdfQ==
-->