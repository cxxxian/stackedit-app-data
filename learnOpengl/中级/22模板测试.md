![输入图片说明](/imgs/2025-02-08/dD2ags72nH0RsSxG.png)

## 模板测试API介绍

![输入图片说明](/imgs/2025-02-08/QSmym7ZiF54lEOkm.png)

![输入图片说明](/imgs/2025-02-08/MqTacdIRgu3xuMvB.png)

![输入图片说明](/imgs/2025-02-08/72dXvPIpPSiyLnzY.png)

![输入图片说明](/imgs/2025-02-08/x05n4EaaO9Eb8jnz.png)

解释一下上图，mask发挥类似于蒙版的效果，
当`value = 4`，`ref = 1`， `mask = 0x01`时，
此像素不会被渲染，保持原样。
如果希望`mask`不起作用，那就将`mask = 0xFF`，意为`1111 1111`

![输入图片说明](/imgs/2025-02-08/aP0XTtJ2JZlDdbrh.png)

当`GL_REPLACE`时，3改为5
当`GL_INCR`时，3改为4

![输入图片说明](/imgs/2025-02-08/nWw5U5gkTdg7s2lI.png)

这个与上面`glStencilOp`的`mask`区分，这个是用来，我们判断完是否写入后，要不要将值更新到模板信息中，后面实际的应用中还有解释

## 实际应用
制作一个立方体周围被白框包裹的效果
实现思路：
1. 正常制作一个立方体A
2. 绘制一个更大的立方体B，A绘制过的地方B不进行绘制

![输入图片说明](/imgs/2025-02-08/Ga80JsNkeSEyDtrh.png)

### 实际coding
1. 搭建场景
```cpp
void prepare() {
	renderer = new Renderer();
	scene = new Scene();
	
	//1 内部立方体
	auto geometry = Geometry::createBox(4.0f);
	auto materialA = new PhongMaterial();
	materialA->mDiffuse = new Texture("assets/textures/goku.jpg", 0);
	auto meshA = new Mesh(geometry, materialA);

	scene->addChild(meshA);
	//2 外部勾边立方体
	auto materialABound = new WhiteMaterial();
	auto meshABound = new Mesh(geometry, materialABound);
	meshABound->setPosition(meshA->getPosition());
	meshABound->setScale(glm::vec3(1.2f));

	scene->addChild(meshABound);
	...
}
```

2. 渲染前统一设置模板测试状态（开启测试、设置基本写入状态、打开模板测试）
在`render.cpp`中，在`render`函数即渲染最初期预先初始化好相关状态
```cpp
void Renderer::render(
	Scene* scene, 
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	...
	// 开启测试、设置基本写入状态，打开模板测试写入
	glEnable(GL_STENCIL_TEST);
	glStencilFunc(GL_KEEP, GL_KEEP, GL_KEEP);
	glStencilMask(0xFF);//保证模板缓冲可以被清理

	//2 清理画布 
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
	...
}
```
3. 按照物体渲染顺序，更改模板测试参数

这里**很重要**的点：
1. 要重新设置`glStencilOp`，因为我们原本初始状态三个都是`GL_KEEP`
2. 以及渲染外圈包围的立方体时，可以将`Mask`关闭，因为即使我们将外圈的白边写入`1`的模板信息，然后紧接着我们又进行清除了，所以没有必要
```cpp
//针对单个object进行渲染
void Renderer::renderObject(
	Object* object,
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	...
	//2 遍历object的子节点，对每个子节点都需要调用renderObject
	auto children = object->getChildren();
	for (int i = 0; i < children.size(); i++) {
		if (i == 0) {
			glStencilFunc(GL_ALWAYS, 1, 0xFF);//如何测试
			glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);//成功，失败后如何
			glStencilMask(0xFF);//控制缓冲写入
		}
		else if(i == 1){
			glStencilFunc(GL_NOTEQUAL, 1, 0xFF);
			glStencilMask(0x00);//逻辑优势：边界覆盖的区域不应该写入1（因为没必要）
		}
		renderObject(children[i], camera, dirLight, ambLight);
	}
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjY0MDEyNTU3LDM4MzY0Nzg4NywtMTI2ND
gwNjkzMCwxODcxMjkxODUxLDQ3MDE5MDU1LC0xMzkwNDM0OTA5
LDEyOTQ4NTg0ODUsLTEwMDAwMDU5LDE3MjM2MzMxNjksLTE4OT
M3NzYwOTUsLTE3MTAyMjIxNzldfQ==
-->