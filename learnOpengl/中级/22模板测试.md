![输入图片说明](/imgs/2025-02-08/dD2ags72nH0RsSxG.png)

## 模板测试API介绍

![输入图片说明](/imgs/2025-02-08/QSmym7ZiF54lEOkm.png)

![输入图片说明](/imgs/2025-02-08/MqTacdIRgu3xuMvB.png)

![输入图片说明](/imgs/2025-02-08/72dXvPIpPSiyLnzY.png)

![输入图片说明](/imgs/2025-02-08/x05n4EaaO9Eb8jnz.png)

解释一下上图，mask发挥类似于蒙版的效果，
当`value = 4`，`ref = 1`， `mask = 0x01`时，
此像素不会被渲染，保持原样。
如果希望`mask`不起作用，那就将`mask = 0xFF`，意为`1111 1111`

![输入图片说明](/imgs/2025-02-08/aP0XTtJ2JZlDdbrh.png)

当`GL_REPLACE`时，3改为5
当`GL_INCR`时，3改为4

![输入图片说明](/imgs/2025-02-08/nWw5U5gkTdg7s2lI.png)

这个与上面`glStencilOp`的`mask`区分，这个是用来，我们判断完是否写入后，要不要将值更新到模板信息中，后面实际的应用中还有解释

## 实际应用
制作一个立方体周围被白框包裹的效果
实现思路：
1. 正常制作一个立方体A
2. 绘制一个更大的立方体B，A绘制过的地方B不进行绘制

![输入图片说明](/imgs/2025-02-08/Ga80JsNkeSEyDtrh.png)

### 实际coding
1. 搭建场景
```cpp
void prepare() {
	renderer = new Renderer();
	scene = new Scene();
	
	//1 内部立方体
	auto geometry = Geometry::createBox(4.0f);
	auto materialA = new PhongMaterial();
	materialA->mDiffuse = new Texture("assets/textures/goku.jpg", 0);
	auto meshA = new Mesh(geometry, materialA);

	scene->addChild(meshA);
	//2 外部勾边立方体
	auto materialABound = new WhiteMaterial();
	auto meshABound = new Mesh(geometry, materialABound);
	meshABound->setPosition(meshA->getPosition());
	meshABound->setScale(glm::vec3(1.2f));

	scene->addChild(meshABound);
	...
}
```

2. 渲染前统一设置模板测试状态（开启测试、设置基本写入状态、打开模板测试）
在`render.cpp`中，在`render`函数即渲染最初期预先初始化好相关状态
```cpp
void Renderer::render(
	Scene* scene, 
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	...
	// 开启测试、设置基本写入状态，打开模板测试写入
	glEnable(GL_STENCIL_TEST);
	glStencilFunc(GL_KEEP, GL_KEEP, GL_KEEP);
	glStencilMask(0xFF);//保证模板缓冲可以被清理

	//2 清理画布 
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
	...
}
```
3. 按照
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyNzg5NDgxMDgsMzgzNjQ3ODg3LC0xMj
Y0ODA2OTMwLDE4NzEyOTE4NTEsNDcwMTkwNTUsLTEzOTA0MzQ5
MDksMTI5NDg1ODQ4NSwtMTAwMDAwNTksMTcyMzYzMzE2OSwtMT
g5Mzc3NjA5NSwtMTcxMDIyMjE3OV19
-->