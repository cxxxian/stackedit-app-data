![输入图片说明](/imgs/2025-02-08/dD2ags72nH0RsSxG.png)

## 模板测试API介绍

![输入图片说明](/imgs/2025-02-08/QSmym7ZiF54lEOkm.png)

![输入图片说明](/imgs/2025-02-08/MqTacdIRgu3xuMvB.png)

![输入图片说明](/imgs/2025-02-08/72dXvPIpPSiyLnzY.png)

![输入图片说明](/imgs/2025-02-08/x05n4EaaO9Eb8jnz.png)

解释一下上图，mask发挥类似于蒙版的效果，
当`value = 4`，`ref = 1`， `mask = 0x01`时，
此像素不会被渲染，保持原样。
如果希望`mask`不起作用，那就将`mask = 0xFF`，意为`1111 1111`

![输入图片说明](/imgs/2025-02-08/aP0XTtJ2JZlDdbrh.png)

当`GL_REPLACE`时，3改为5
当`GL_INCR`时，3改为4

![输入图片说明](/imgs/2025-02-08/nWw5U5gkTdg7s2lI.png)

## 实际应用
制作一个立方体周围被白框包裹的效果
实现思路：
1. 正常制作一个立方体A
2. 绘制一个更大的立方体B，A绘制过的地方B不进行绘制

![输入图片说明](/imgs/2025-02-08/Ga80JsNkeSEyDtrh.png)

### 实际coding
1. 搭建场景
```cpp
void prepare() {
	renderer = new Renderer();
	scene = new Scene();
	
	//1 内部立方体
	auto geometry = Geometry::createBox(4.0f);
	auto materialA = new PhongMaterial();
	materialA->mDiffuse = new Texture("assets/textures/goku.jpg", 0);
	auto meshA = new Mesh(geometry, materialA);

	scene->addChild(meshA);
	//2 外部勾边立方体
	auto materialABound = new WhiteMaterial();
	auto meshABound = new Mesh(geometry, materialABound);
	meshABound->setPosition(meshA->getPosition());
	meshABound->setScale(glm::vec3(1.2f));

	scene->addChild(meshABound);
	...
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTg3MTI5MTg1MSw0NzAxOTA1NSwtMTM5MD
QzNDkwOSwxMjk0ODU4NDg1LC0xMDAwMDA1OSwxNzIzNjMzMTY5
LC0xODkzNzc2MDk1LC0xNzEwMjIyMTc5XX0=
-->