![输入图片说明](/imgs/2025-02-07/Mn4Ca6sAaf5jYKT8.png)

![输入图片说明](/imgs/2025-02-07/CzpWimBLyWbsil3O.png)

![输入图片说明](/imgs/2025-02-07/lO8gXgdIms2vuBN7.png)

以下是使用`ndc`得出的深度值，是非线性关系，我们将深度值输出为`rgb`颜色，
所以在离很近的时候变化剧烈（灰色），远的时候基本为白色（变化不明显）
```glsl
void main()
{
	...

	finalColor = vec3(gl_FragCoord.z, gl_FragCoord.z, gl_FragCoord.z);

	FragColor = vec4(finalColor, 1.0);
}
```
以下是通过自己设计的线性灰度公式
```glsl
uniform float near;
uniform float far;

void main()
{
	...

	float Zndc = gl_FragCoord.z * 2.0 - 1.0;
	float linearDepth = 2.0 * near / (far + near - Zndc * (far - near));

	finalColor = vec3(linearDepth, linearDepth, linearDepth);

	FragColor = vec4(finalColor, 1.0);
}
```
此时我们设计了`uniform`变量的`near`和`far`，所以我们要去`camera`那边取得（先前的`near`和`far`都设计在`camera`类中）并传过来`shader`中
```cpp
void Renderer::renderObject(
	Object* object,
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	...

			//相机信息更新
			shader->setVector3("cameraPosition", camera->mPosition);
			shader->setFloat("near", camera->mNear);
			shader->setFloat("far", camera->mFar);

		}
			break;
		...
}

```
此时运行后屏幕一片黑？？？WHY？？？
因为我们的farp
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTMyMDUxMjM4MCwtNzU4NTY2MDg4LDE5NT
Y1NzkyNDgsLTEwNDc4NTkyNzAsMTcxMjgxNjcxMSwxNTQ4NDAy
MTc2XX0=
-->