![输入图片说明](/imgs/2025-02-07/Mn4Ca6sAaf5jYKT8.png)

![输入图片说明](/imgs/2025-02-07/CzpWimBLyWbsil3O.png)

![输入图片说明](/imgs/2025-02-07/lO8gXgdIms2vuBN7.png)

以下是使用`ndc`得出的深度值，是非线性关系，我们将深度值输出为`rgb`颜色，
所以在离很近的时候变化剧烈（灰色），远的时候基本为白色（变化不明显）
```glsl
void main()
{
	...

	finalColor = vec3(gl_FragCoord.z, gl_FragCoord.z, gl_FragCoord.z);

	FragColor = vec4(finalColor, 1.0);
}
```
以下是通过自己设计的线性灰度公式
```glsl
uniform float near;
uniform float far;

void main()
{
	...

	float Zndc = gl_FragCoord.z * 2.0 - 1.0;
	float linearDepth = 2.0 * near / (far + near - Zndc * (far - near));

	finalColor = vec3(linearDepth, linearDepth, linearDepth);

	FragColor = vec4(finalColor, 1.0);
}
```
此时我们设计了`uniform`变量的`near`和`far`，所以我们要去`camera`那边取得（先前的`near`和`far`都设计在`camera`类中）并传过来`shader`中
```
void Renderer::renderObject(
	Object* object,
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	//1 判断是Mesh还是Object，如果是Mesh需要渲染
	if (object->getType() == ObjectType::Mesh) {
		auto mesh = (Mesh*)object;
		auto geometry = mesh->mGeometry;
		auto material = mesh->mMaterial;

		//设置渲染状态
		if (material->mDepthTest) {
			glEnable(GL_DEPTH_TEST);
			glDepthFunc(material->mDepthFunc);
		}
		else {
			glDisable(GL_DEPTH_TEST);
		}

		if (material->mDepthWrite) {
			glDepthMask(GL_TRUE);
		}
		else {
			glDepthMask(GL_FALSE);
		}

		//1 决定使用哪个Shader 
		Shader* shader = pickShader(material->mType);

		//2 更新shader的uniform
		shader->begin();

		switch (material->mType) {
		case MaterialType::PhongMaterial: {
			PhongMaterial* phongMat = (PhongMaterial*)material;

			//diffuse贴图帧更新
			//将纹理采样器与纹理单元进行挂钩
			shader->setInt("sampler", 0);
			//将纹理与纹理单元进行挂钩
			phongMat->mDiffuse->bind();

			//高光蒙版的帧更新
			/*shader->setInt("specularMaskSampler", 1);
			phongMat->mSpecularMask->bind();*/

			//mvp
			shader->setMatrix4x4("modelMatrix", mesh->getModelMatrix());
			shader->setMatrix4x4("viewMatrix", camera->getViewMatrix());
			shader->setMatrix4x4("projectionMatrix", camera->getProjectionMatrix());

			auto normalMatrix = glm::mat3(glm::transpose(glm::inverse(mesh->getModelMatrix())));
			shader->setMatrix3x3("normalMatrix", normalMatrix);

			//光源参数的uniform更新
			//directionalLight 的更新
			shader->setVector3("directionalLight.color", dirLight->mColor);
			shader->setVector3("directionalLight.direction", dirLight->mDirection);
			shader->setFloat("directionalLight.specularIntensity", dirLight->mSpecularIntensity);


			shader->setFloat("shiness", phongMat->mShiness);

			shader->setVector3("ambientColor", ambLight->mColor);

			//相机信息更新
			shader->setVector3("cameraPosition", camera->mPosition);
			shader->setFloat("near", camera->mNear);
			shader->setFloat("far", camera->mFar);

		}
			break;
		...
}

```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMzEwNTkwOTYxLC03NTg1NjYwODgsMTk1Nj
U3OTI0OCwtMTA0Nzg1OTI3MCwxNzEyODE2NzExLDE1NDg0MDIx
NzZdfQ==
-->