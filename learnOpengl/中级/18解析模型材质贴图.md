1. 添加`processTexture`函数

先前已经有`processNode`和`processMesh`的函数在`AssimpLoader`中，制作`processTexture`，解析纹理
我们先完善先前的`processMesh`，添加参数`scene`
```cpp
static Mesh* processMesh(aiMesh* aimesh, const aiScene* scene);
```
利用`scene`得到材质的`Index`，并获取材质图片的路径
```cpp
Mesh* AssimpLoader::processMesh(aiMesh* aimesh, const aiScene* scene)
{
	...

	//>=0说明模型的文件中带有材质信息
	if (aimesh->mMaterialIndex >= 0) {
		aiMaterial* aiMat = scene->mMaterials[aimesh->mMaterialIndex];

		//获取图片读取路径
		aiString aipath;
		//从材质中拿到diffuse纹理的第0张信息，路径赋值到aipath中
		aiMat->Get(AI_MATKEY_TEXTURE(aiTextureType_DIFFUSE, 0), aipath);

	}
	else {

	}

	return new Mesh(geometry, material);
}
```
但是此时的`aipath`是相对路径而不是绝对路径，我们需要自己补充为绝对路径
Object* AssimpLoader::load(const std::string& path)
{
	//拿出模型所在目录，//，第一个/是转义字符，第二个/才是真的斜杠
	//find_last_of可以找到最后一个斜杠的位置
	std::size_t lastIndex = path.find_last_of("//");
	//0到最后一个斜杠的字符串
	auto rootPath = path.substr(0, lastIndex + 1);

	Object* rootNode = new Object();

	Assimp::Importer importer;
	//aiProcess_Triangulate：三角格化，如一个四边形，将其分为两个三角形
	//aiProcess_GenNormals：如果没有法线自动生成法线
	const aiScene* scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_GenNormals);

	//验证读取是否正确顺利
	if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {
		std::cerr << "Error: Model Read Fail" << std::endl;
		return nullptr;
	}
	processNode(scene->mRootNode, rootNode, scene);

	return rootNode;
}
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTk0MTk0NjYwNiwtMTc0MDg4OTUxNiw5Nz
c4MTc4OTNdfQ==
-->