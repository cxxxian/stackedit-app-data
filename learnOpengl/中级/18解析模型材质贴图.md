1. 添加`processTexture`函数

先前已经有`processNode`和`processMesh`的函数在`AssimpLoader`中，制作`processTexture`，解析纹理
我们先完善先前的`processMesh`，添加参数`scene`
```cpp
static Mesh* processMesh(aiMesh* aimesh, const aiScene* scene);
```
利用`scene`得到材质的`Index`，并获取材质图片的路径
```cpp
Mesh* AssimpLoader::processMesh(aiMesh* aimesh, const aiScene* scene)
{
	...

	//>=0说明模型的文件中带有材质信息
	if (aimesh->mMaterialIndex >= 0) {
		aiMaterial* aiMat = scene->mMaterials[aimesh->mMaterialIndex];

		//获取图片读取路径
		aiString aipath;
		//从材质中拿到diffuse纹理的第0张信息，路径赋值到aipath中
		aiMat->Get(AI_MATKEY_TEXTURE(aiTextureType_DIFFUSE, 0), aipath);

	}
	else {

	}

	return new Mesh(geometry, material);
}
```
但是此时的`aipath`是相对路径而不是绝对路径，我们需要自己补充为绝对路径。
所以我们去到`load`方法中，利用`path`，`path`是我们读取模型的绝对路径，我们利用`path.find_last_of`拿到最后一个`/`的索引，就可以得到我们希望的`rootPath`，即绝对路径的前缀
```cpp
Object* AssimpLoader::load(const std::string& path)
{
	//拿出模型所在目录，//，第一个/是转义字符，第二个/才是真的斜杠
	//find_last_of可以找到最后一个斜杠的位置
	std::size_t lastIndex = path.find_last_of("//");
	//0到最后一个斜杠的字符串
	auto rootPath = path.substr(0, lastIndex + 1);

	...
}
```
由于我们的`load`，`processNode`，`processMesh`是嵌套使用的，我们希望在`processMesh`中使用我们刚刚在`load`设计的`rootPath`，我们就需要在`processNode`，`processMesh`都添加上变量`const std::string& rootPath`
```cpp
public:
	static Object* load(const std::string& path);

private:
	static void processNode(aiNode* ainode, 
		Object* parent, 
		const aiScene* scene,
		const std::string& rootPath
	);

	static Mesh* processMesh(aiMesh* aimesh, 
		const aiScene* scene,
		const std::string& rootPath
	);
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTc0NzQ5MTg4MywtMTc0MDg4OTUxNiw5Nz
c4MTc4OTNdfQ==
-->