
![输入图片说明](/imgs/2025-02-07/mYZFYCynhkJKZC2u.png)

## 区域渲染
在`phong.frag`中
使用`gl_FragCoord.xy`进行制作
我们的界面是`800*600`，以`400`为分界线做`step`，然后使用mix函数，就可以做到`0~400`是红色，`400~800`是蓝色，将`blendColor`乘上`finalColor`就可以做到像滤镜一样的效果
```glsl
float flag = step(400, gl_FragCoord.x);
vec3 blendColor = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), flag);
finalColor *= blendColor;
```

![输入图片说明](/imgs/2025-02-07/feYWhxJJzh5MgNKj.png)

## 深度信息
在`phong.frag`中，将深度值直接输出为`rgb`值，会发现是白色，越靠近越变灰，说明越来越近
```glsl
finalColor = vec3(gl_FragCoord.z, gl_FragCoord.z, gl_FragCoord.z);
```
![输入图片说明](/imgs/2025-02-07/xzX9XWVoHNZK55am.png)

![输入图片说明](/imgs/2025-02-07/EkaWMb5RGmSmpcEt.png)

![输入图片说明](/imgs/2025-02-07/0sX9EIjBcaFkters.png)

# 深度缓存
在`main.cpp`中，创建三个平面A，B，C，
按照深度gA在最前面，B在中间，C在最后，
```cpp
void prepare() {
	renderer = new Renderer();
	scene = new Scene();

	auto geometry = Geometry::createPlane(5.0f, 5.0f);
	auto materialA = new PhongMaterial();
	materialA->mDiffuse = new Texture("assets/textures/goku.jpg", 0);
	auto meshA = new Mesh(geometry, materialA);

	scene->addChild(meshA);

	auto materialB = new PhongMaterial();
	materialB->mDiffuse = new Texture("assets/textures/box.png", 0);
	materialB->mDepthWrite = false;//禁止深度写入
	auto meshB = new Mesh(geometry, materialB);
	meshB->setPosition(glm::vec3(2.0f,0.5f, -1.0f));
	scene->addChild(meshB);

	auto materialC = new PhongMaterial();
	materialC->mDiffuse = new Texture("assets/textures/earth.png", 0);
	auto meshC = new Mesh(geometry, materialC);
	meshC->setPosition(glm::vec3(4.0f, 1.0f, -2.0f));
	scene->addChild(meshC);
	
	...
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTY3OTU4NTkwNCwxMTA2MDA1MDY5LC0yNj
kyMDMwMjMsMjE3MzY0NDYxLDU5MDI4MTM5MiwtMjExOTQ2ODQ0
LC0yMDg4NzQ2NjEyXX0=
-->