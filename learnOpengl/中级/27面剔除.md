为了优化性能，我们可以剔除我们看不到的模型部分，不渲染它们，但是我们先前是通过深度检测来不显示那些背面的部分
使用深度检测这种方法的话，我们依旧是把整个模型经过`render`渲染，传进`fragment`着色器后，再进行深度检测判断，效率不佳。
我们提前进行面剔除，只将能看到的面保留并渲染，效率更佳

![输入图片说明](/imgs/2025-02-12/rg4BoFBQfKNKQE2R.png)

![输入图片说明](/imgs/2025-02-12/VkkYINvOixtuwfnm.png)

![输入图片说明](/imgs/2025-02-12/SclFepcf1C8ZugQl.png)

在`main.cpp`中制作一个平面并挂上材质
```cpp
void prepare() {
	renderer = new Renderer();
	scene = new Scene();

	auto Geo = Geometry::createPlane(2.0f, 2.0f);
	auto Mat = new PhongMaterial();
	Mat->mDiffuse = new Texture("assets/textures/grass.jpg", 0);
	auto mesh = new Mesh(Geo, Mat);
	scene->addChild(mesh);
	...
}
```
在`render.cpp`中的`render`函数中开启面剔除并设置相关参数
```cpp
void Renderer::render(
	Scene* scene, 
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	////1 设置当前帧绘制的时候，opengl的必要状态机参数
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LESS);
	glDepthMask(GL_TRUE);

	glDisable(GL_POLYGON_OFFSET_FILL);
	glDisable(GL_POLYGON_OFFSET_LINE);

	// 开启测试、设置基本写入状态，打开模板测试写入
	glEnable(GL_STENCIL_TEST);
	glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);
	glStencilMask(0xFF);//保证模板缓冲可以被清理

	// 默认颜色混合
	glDisable(GL_BLEND);
	
	//面剔除
	glEnable(GL_CULL_FACE);//开启面剔除
	glFrontFace(GL_CCW);//逆时针为正面
	glCullFace(GL_BACK);//剔除背面
	...
}
```
效果如下，在正面可以看得到平面，背面就看不到了

![输入图片说明](/imgs/2025-02-12/fv5izjdb72cjoca3.png)

## 代码封装
在`material.h`中创建相应变量
```cpp
public:
	...
	//面剔除
	bool	mFaceCulling{ false };
	unsigned int	mFrontFace{ GL_CCW };
	unsigned int	mCullFace{ GL_BACK };
```
然后去到`render.h`中创建函数
`void setFaceCullingState(Material* material);`，
用来开启关闭面剔除以及编辑相关状态
在`render.cpp`实现方法
```cpp
void Renderer::setFaceCullingState(Material* material)
{
	if (material->mFaceCulling) {
		glEnable(GL_CULL_FACE);
		glFrontFace(material->mFrontFace);
		glCullFace(material->mCullFace);

	}
	else {
		glDisable(GL_CULL_FACE);
	}
}
```
并在`renderObject`方法中调用此方法
```cpp
//针对单个object进行渲染
void Renderer::renderObject(
	Object* object,
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	//1 判断是Mesh还是Object，如果是Mesh需要渲染
	if (object->getType() == ObjectType::Mesh) {
		auto mesh = (Mesh*)object;
		auto geometry = mesh->mGeometry;

		Material* material = nullptr;
		if (mGlobalMaterial != nullptr) {
			material = mGlobalMaterial;
		}
		else {
			material = mesh->mMaterial;
		}

		//设置渲染状态
		setDpethState(material);
		setPolygonOffsetState(material);
		setStencilState(material);
		setBlendState(material);
		setFaceCullingState(material);

		//1 决定使用哪个Shader 
		Shader* shader = pickShader(material->mType);

		//2 更新shader的uniform
		shader->begin();

		switch (material->mType) {
		case MaterialType::PhongMaterial: {
			PhongMaterial* phongMat = (PhongMaterial*)material;

			//diffuse贴图帧更新
			//将纹理采样器与纹理单元进行挂钩
			shader->setInt("sampler", 0);
			//将纹理与纹理单元进行挂钩
			phongMat->mDiffuse->bind();

			//高光蒙版的帧更新
			/*shader->setInt("specularMaskSampler", 1);
			phongMat->mSpecularMask->bind();*/

			//mvp
			shader->setMatrix4x4("modelMatrix", mesh->getModelMatrix());
			shader->setMatrix4x4("viewMatrix", camera->getViewMatrix());
			shader->setMatrix4x4("projectionMatrix", camera->getProjectionMatrix());

			auto normalMatrix = glm::mat3(glm::transpose(glm::inverse(mesh->getModelMatrix())));
			shader->setMatrix3x3("normalMatrix", normalMatrix);

			//光源参数的uniform更新
			//directionalLight 的更新
			shader->setVector3("directionalLight.color", dirLight->mColor);
			shader->setVector3("directionalLight.direction", dirLight->mDirection);
			shader->setFloat("directionalLight.specularIntensity", dirLight->mSpecularIntensity);


			shader->setFloat("shiness", phongMat->mShiness);

			shader->setVector3("ambientColor", ambLight->mColor);

			//相机信息更新
			shader->setVector3("cameraPosition", camera->mPosition);

			//透明度
			shader->setFloat("opacity", material->mOpacity);
		}
										break;
		case MaterialType::WhiteMaterial: {
			//mvp
			shader->setMatrix4x4("modelMatrix", mesh->getModelMatrix());
			shader->setMatrix4x4("viewMatrix", camera->getViewMatrix());
			shader->setMatrix4x4("projectionMatrix", camera->getProjectionMatrix());
		}
										break;
		case MaterialType::DepthMaterial: {
			//mvp
			shader->setMatrix4x4("modelMatrix", mesh->getModelMatrix());
			shader->setMatrix4x4("viewMatrix", camera->getViewMatrix());
			shader->setMatrix4x4("projectionMatrix", camera->getProjectionMatrix());

			//camera
			shader->setFloat("near", camera->mNear);
			shader->setFloat("far", camera->mFar);
		}
										break;
		case MaterialType::OpacityMaskMaterial: {
			OpacityMaskMaterial* opacityMat = (OpacityMaskMaterial*)material;

			//diffuse贴图帧更新
			//将纹理采样器与纹理单元进行挂钩
			shader->setInt("sampler", 0);
			//将纹理与纹理单元进行挂钩
			opacityMat->mDiffuse->bind();

			//透明度蒙版的帧更新
			shader->setInt("opacityMaskSampler", 1);
			opacityMat->mOpacityMask->bind();

			//mvp
			shader->setMatrix4x4("modelMatrix", mesh->getModelMatrix());
			shader->setMatrix4x4("viewMatrix", camera->getViewMatrix());
			shader->setMatrix4x4("projectionMatrix", camera->getProjectionMatrix());

			auto normalMatrix = glm::mat3(glm::transpose(glm::inverse(mesh->getModelMatrix())));
			shader->setMatrix3x3("normalMatrix", normalMatrix);

			//光源参数的uniform更新
			//directionalLight 的更新
			shader->setVector3("directionalLight.color", dirLight->mColor);
			shader->setVector3("directionalLight.direction", dirLight->mDirection);
			shader->setFloat("directionalLight.specularIntensity", dirLight->mSpecularIntensity);


			shader->setFloat("shiness", opacityMat->mShiness);

			shader->setVector3("ambientColor", ambLight->mColor);

			//相机信息更新
			shader->setVector3("cameraPosition", camera->mPosition);

			//透明度
			shader->setFloat("opacity", material->mOpacity);
		}
										break;
		default:
			break;
		}

		//3 绑定vao
		glBindVertexArray(geometry->getVao());

		//4 执行绘制命令
		glDrawElements(GL_TRIANGLES, geometry->getIndicesCount(), GL_UNSIGNED_INT, 0);
	}

}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5MTE0NDc5OTAsLTE1NDU4OTk4NDEsLT
U5NDU1Mzg5MCwtMzY2MTk1ODAyXX0=
-->