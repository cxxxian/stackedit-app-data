## 理论解释

![输入图片说明](/imgs/2025-02-09/wwIrPFJqrCqPUI3f.png)

![输入图片说明](/imgs/2025-02-09/M2cmKZDTB2hzYRUb.png)

![输入图片说明](/imgs/2025-02-09/4nwcUZKuakqegXwQ.png)

## API

![输入图片说明](/imgs/2025-02-09/BqQV5TQaFPc4iNTu.png)

![输入图片说明](/imgs/2025-02-09/1DErcMc9tbQeqzW2.png)

![输入图片说明](/imgs/2025-02-09/d9nTGMxfAXgCVDgi.png)

![输入图片说明](/imgs/2025-02-09/m4YzqpMp7kP7IZ9x.png)

## 代码实现
先在`main.cpp`创建一个立方体，前面有一块平面遮挡
```cpp
void prepare() {
	renderer = new Renderer();
	scene = new Scene();

	auto boxGeo = Geometry::createBox(4);
	auto boxMat = new PhongMaterial();
	boxMat->mDiffuse = new Texture("assets/textures/box.png", 0);
	
	auto boxMesh = new Mesh(boxGeo, boxMat);
	scene->addChild(boxMesh);

	auto planeGeo = Geometry::createPlane(6.0, 6.0);
	auto planeMat = new PhongMaterial();
	planeMat->mDiffuse = new Texture("assets/textures/window.png", 0);

	auto planeMesh = new Mesh(planeGeo, planeMat);
	planeMesh->setPosition(glm::vec3(0.0, 0.0, 4.0));
	scene->addChild(planeMesh);
	...
}
```


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1MjA5OTEyNTYsMTk2NzQ5NzQ4NCw5OD
QyMzM2NjIsODQyNTA1OTA1LDE3MzM0NDg3MzgsLTg5NjIxODEx
OSwtMjA4ODc0NjYxMl19
-->