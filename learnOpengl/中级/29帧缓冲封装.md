1. `Texture`加入空白构造函数
```
Texture();
```

2. `Texture`类加入创建颜色、深度模板缓冲的静态`create`函数

在`texture.h`声明函数
```cpp
static Texture* createColorAttachment(unsigned int width, unsigned int height, unsigned int unit);
static Texture* createDepthStecilAttachment(unsigned int width, unsigned int height, unsigned int unit);
```
去到`texture.cpp`实现
颜色的附件直接调用我们之前设计的`Texture`构造函数即可
```cpp
Texture* Texture::createColorAttachment(unsigned int width, unsigned int height, unsigned int unit)
{
	return new Texture(width, height, unit);
}
```
而深度模板附件，我们没办法直接调用构造方法，因为参数不太一样，例如：`GL_DEPTH24_STENCIL8`等
```cpp
Texture* Texture::createDepthStecilAttachment(unsigned int width, unsigned int height, unsigned int unit)
{
	Texture* dsTex = new Texture();
	unsigned int depthStencil;
	glGenTextures(1, &depthStencil);
	glBindTexture(GL_TEXTURE_2D, depthStencil);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, width, height, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, depthStencil, 0);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

	dsTex->mTexture = depthStencil;
	dsTex->mWidth = width;
	dsTex->mHeight = height;
	dsTex->mUnit = unit;
	
	return dsTex;
}
```

5. 封装`FrameBuffer`类

创建一个`framebuffer.h`
初始化相应关于帧缓冲的变量
```cpp
#pragma once
#include "../core.h"
#include "../texture.h"

class Framebuffer {
public:
	Framebuffer(unsigned int width, unsigned int height);
	~Framebuffer();

public:
	unsigned int mWidth{ 0 };
	unsigned int mHeight{ 0 };

	unsigned int mFBO{ 0 };
	Texture* mColorAttachment{ nullptr };
	Texture* mDepthStencilAttachment{ nullptr };
};
```
对应到`frambuffer.cpp`中进行实现
其实这个构造函数所实现的内容就是我们先前的`prepareFBO`所实现的功能
```cpp
#include "framebuffer.h"

Framebuffer::Framebuffer(unsigned int width, unsigned int height)
{
	mWidth = width;
	mHeight = height;
	//1 生成FBO对象并绑定
	glGenFramebuffers(1, &mFBO);
	glBindFramebuffer(GL_FRAMEBUFFER, mFBO);

	//2 生成颜色附件，并加入fbo
	mColorAttachment = Texture::createColorAttachment(mWidth, mHeight, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, mColorAttachment->getTexture(), 0);

	//3 生成depth，stencil附件，并加入fbo
	mDepthStencilAttachment = Texture::createDepthStecilAttachment(mWidth, mHeight, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, mDepthStencilAttachment->getTexture(), 0);

	//检查当前fbo是否完整
	if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
		std::cout << "Error: frameBuffer is not complete" << std::endl;
	}
	glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

Framebuffer::~Framebuffer()
{
	if (mFBO) {
		glDeleteFramebuffers(1, &mFBO);
	}
	if (mColorAttachment != nullptr) {
		delete mColorAttachment;
	}
	if (mDepthStencilAttachment != nullptr) {
		delete mDepthStencilAttachment;
	}
}
```

做完这些后，我们就可以去到`main.cpp`中进行使用

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTcxMTg4Nzc2OCwxMDg2MDU5NDc5LDE4MD
g2ODM4OTUsLTEyMTM0NTYwOTJdfQ==
-->