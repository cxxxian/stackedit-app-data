1. `Texture`加入空白构造函数
```
Texture();
```

2. `Texture`类加入创建颜色、深度模板缓冲的静态`create`函数

在`texture.h`声明函数
```cpp
static Texture* createColorAttachment(unsigned int width, unsigned int height, unsigned int unit);
static Texture* createDepthStecilAttachment(unsigned int width, unsigned int height, unsigned int unit);
```
去到`texture.cpp`实现
颜色的附件直接调用我们之前设计的`Texture`构造函数即可
```cpp
Texture* Texture::createColorAttachment(unsigned int width, unsigned int height, unsigned int unit)
{
	return new Texture(width, height, unit);
}
```
而深度模板附件，我们没办法直接调用构造方法，因为参数不太一样，例如：`GL_DEPTH24_STENCIL8`等
```cpp
Texture* Texture::createDepthStecilAttachment(unsigned int width, unsigned int height, unsigned int unit)
{
	Texture* dsTex = new Texture();
	unsigned int depthStencil;
	glGenTextures(1, &depthStencil);
	glBindTexture(GL_TEXTURE_2D, depthStencil);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, width, height, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, NULL);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, depthStencil, 0);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);

	dsTex->mTexture = depthStencil;
	dsTex->mWidth = width;
	dsTex->mHeight = height;
	dsTex->mUnit = unit;
	
	return dsTex;
}
```

5. 封装`FrameBuffer`类


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTkwOTkwNTA1NiwxMDg2MDU5NDc5LDE4MD
g2ODM4OTUsLTEyMTM0NTYwOTJdfQ==
-->