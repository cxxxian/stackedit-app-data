# 光照参数
在main.cpp中声明光照的参数，然后将这些参数搞到shader中
```
//平行光：参数（方向、光强）uniform变量形式
glm::vec3 lightDirection = glm::vec3(-1.0f, -1.0f, -1.0f);
glm::vec3 lightColor = glm::vec3(0.9f, 0.85f, 0.75f);
```
到`fragment.glsl`中声明参数，并且先暂时将`lightColor`直接输出验证是否正确
```
...
//光源参数
uniform vec3 lightDirection;
uniform vec3 lightColor;

void main()
{
    //1 将vs中输入的normal做一下归一化
    vec3 normalN = normalize(normal);
    //2 将负数的情况直接清理为0，使用clamp函数
    vec3 normalColor = clamp(normalN, 0.0, 1.0);
    FragColor = vec4(lightColor, 1.0);

    //FragColor = texture(sampler, uv);
}
```
之前设计的传输vec3不好用，设计一个专门传vector3向量的
```
void Shader::setVector3(const std::string& name, const glm::vec3 value)
{
    //1 通过名称拿到Uniform变量位置location
    GLuint location = GL_CALL(glGetUniformLocation(mProgram, name.c_str()));

    //2 通过location更新Uniform变量的值
    GL_CALL(glUniform3f(location, value.x, value.y, value.z));
}
```
到`render()`中调用方法并且绑定光照参数到`shader`中
```
void render(){
	...
    //光源参数的uniform更新
    shader->setVector3("lightDirection", lightDirection);
    shader->setVector3("lightColor", lightColor);
    ...
}
```
就可以得到目标效果啦

![输入图片说明](/imgs/2024-11-22/eR7Dk8ZpNNqxIKQW.png)

# Diffuse
现在我们要实现Diffuse光照效果了
只需要到`fragment.glsl`修改，
```
#version 330 core
out vec4 FragColor;

uniform float time;

in vec2 uv;
in vec3 normal;

uniform sampler2D sampler;

//光源参数
uniform vec3 lightDirection;
uniform vec3 lightColor;

void main()
{
    //1 获取物体当前像素的颜色，也就是纹理的颜色
    vec3 objectColor = texture(sampler, uv).xyz;

    //2 准备diffuse（漫反射）相关的各类数据
    vec3 normalN = normalize(normal);

    vec3 lightDirN = normalize(lightDirection);
	
	//此处的diffuse需要clamp是因为，背后的面可能被点乘出负数的结果
	//虽然都是黑色，但是不太好
    float diffuse = clamp(dot(-lightDirN, normalN), 0.0, 1.0);
    vec3 finalColor = lightColor * diffuse * objectColor;

    FragColor = vec4(finalColor, 1.0);
}
```
修改一下平行光的方向就可以很明显的看到明暗关系
```
glm::vec3 lightDirection = glm::vec3(-0.4f, -1.4f, -1.9f);
glm::vec3 lightColor = glm::vec3(1.0f, 1.0f, 1.0f);
```

![输入图片说明](/imgs/2024-11-22/FcZQKRwLcVtCjVJd.png)

背后是黑色的是因为diffuse的值计算出来为0，从法线和光源方向的点乘入手就可以很容易理解了

![输入图片说明](/imgs/2024-11-22/YI5OATbqiPieS6Ro.png)

# Specular
`reflect`是一个用来计算`lightRef`的函数，只需要传入光源`lightDir`方向和法线`normal`就行
这里注意一下，计算`specular`的`lightRef`和`ViewDir`都要是单位向量，要不然这个`max`就会失效
此处`cos`值为负数的情况，自己模拟一下便知，比如`view`视角跑到左半边去

![输入图片说明](/imgs/2024-11-22/S1wqt76og7gdagBY.png)

由于针对每个像素，相机位置都是相同的，所以用`uniform`

![输入图片说明](/imgs/2024-11-22/v96MtWenPYPvxa51.png)

![输入图片说明](/imgs/2024-11-22/gsKwqoibzsuy8jGb.png)
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTM0MTI3ODEyOCwtMTUyOTA0NDUxN119
-->