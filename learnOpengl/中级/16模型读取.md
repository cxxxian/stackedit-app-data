# 配置assimp
![输入图片说明](/imgs/2024-12-06/uArrQBtj4eUg07jX.png)

将`assimp`配置到`include`中，和两个`lib`

![输入图片说明](/imgs/2024-12-06/jtWrN396hWeDwHop.png)

在`cmakeLists`中链接库
```
target_link_libraries(openglStudy glfw3.lib assimp-vc143-mtd.lib zlibstaticd.lib wrapper app fw imguilib)
```

![输入图片说明](/imgs/2024-12-06/8Sh1vlakzdQBfpr6.png)

![输入图片说明](/imgs/2024-12-06/XPFJuxf35bUgx3Rs.png)

# 读取模型
现在`asset`文件夹下建立一个`fbx`文件夹，并放入`fbx`文件
目标：
1. 加入`AssimpLoader`工具类，专门负责读取模型
2. 完成模型文件读取的基础验证
3. 完成解析`Node`架构与`Object`的一一对应

### 目标一
在`application`文件夹下，创建`assimpLoader`类，
`assimpLoader.h`如下：
```cpp
#pragma once
#include "../glframework/core.h"
#include "../glframework/object.h"

class AssimpLoader {
public:
	static Object* load(const std::string& path);
};
```

### 目标二
在`assimpLoader.h`补充这三个头文件
```cpp
#include "assimp/Importer.hpp"
#include "assimp/scene.h"
#include "assimp/postprocess.h"
```
然后去到`assimpLoader.cpp`中实现`load`方法中的验证部分
这里`importer.ReadFile`返回有一个const指针，所以为了对应我们也在声明的时候加上`const`：`const aiScene* scene`
```cpp
#include "assimpLoader.h"

Object* AssimpLoader::load(const std::string& path)
{
	Object* rootNode = new Object();

	Assimp::Importer importer;
	//aiProcess_Triangulate：三角格化，如一个四边形，将其分为两个三角形
	//aiProcess_GenNormals：如果没有法线自动生成法线
	const aiScene* scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_GenNormals);

	//验证读取是否正确顺利
	if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {
		std::cerr << "Error: Model Read Fail" << std::endl;
		return nullptrl;
	}

	return rootNode;
}

```

可以到`main.cpp`中测试一下，在`prepare`函数中调用一下`load`函数
```cpp
void prepare() {
	renderer = new Renderer();
	scene = new Scene();

	auto test = AssimpLoader::load("assets/fbx/Fist Fight B.fbx");
	...
}
```
此时会报错，主要原因**重名**
我们之前在`application.h`声明了一个`app`宏，将其改为`glApp`，要不然和`assimp`库中重名`bug`
```
#define glApp Application::getInstance()
```
最后在这个地方打个断点，没有进去就说明我们的`fbx`文件没问题
```
if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {
		std::cerr << "Error: Model Read Fail" << std::endl;
		return nullptr;
	}
```
如果出现这种报错，右键`cmakeList`清除缓存并重新配置即可，因为我们添加了一个新的`cpp`文件，这步意为更新

![输入图片说明](/imgs/2024-12-06/GMlP7ob1LgpBTjoe.png)

### 目标三
完善load函数，之前只完成了验证读取，现在引入processNode函数
进行正式的：解析`Node`架构与`Object`的一一对应
```cpp
Object* AssimpLoader::load(const std::string& path)
{
	Object* rootNode = new Object();

	Assimp::Importer importer;
	//aiProcess_Triangulate：三角格化，如一个四边形，将其分为两个三角形
	//aiProcess_GenNormals：如果没有法线自动生成法线
	const aiScene* scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_GenNormals);

	//验证读取是否正确顺利
	if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {
		std::cerr << "Error: Model Read Fail" << std::endl;
		return nullptr;
	}
	processNode(scene->mRootNode, rootNode);

	return rootNode;
}
```
```cpp
void AssimpLoader::processNode(aiNode* ainode, Object* parent)
{
	Object* node = new Object();
	parent->addChild(node);

	glm::mat4 localMatrix = getMat4f(ainode->mTransformation);
	//位置 旋转 缩放
	glm::vec3 position, eulerAngle, scale;
	Tools::decompose(localMatrix, position, eulerAngle, scale);
	node->setPosition(position);
	node->setAngleX(eulerAngle.x);
	node->setAngleY(eulerAngle.y);
	node->setAngleZ(eulerAngle.z);
	node->setScale(scale);

	for (int i = 0; i < ainode->mNumChildren; i++) {
		processNode(ainode->mChildren[i], node);
	}
}
```
```cpp
glm::mat4 AssimpLoader::getMat4f(aiMatrix4x4 value)
{
	//aiMatrix转化为glm::mat4
	glm::mat4 to(
		value.a1, value.a2, value.a3, value.a4,
		value.b1, value.b2, value.b3, value.b4,
		value.c1, value.c2, value.c3, value.c4,
		value.d1, value.d2, value.d3, value.d4
		);

	return to;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgyNzc0ODU0LDM3NTUwMjUyMSwtMzYxOD
AzMTQxLDE1ODA3MDc4OSwxMDQ5Nzk1ODMwLDU0NTcyOTc1MSwt
MTk2MDg1ODQxNywxNjQ0NzMxMjU4LDE0NDMzMTk2NDcsNjQzMD
E2OTA1XX0=
-->