在`material.h`中创建相应的有关于颜色混合的变量
```cpp
public:
	...
	//颜色混合
	bool	mBlend{ false };
	unsigned int	mSFactor{GL_SRC_ALPHA};
	unsigned int	mDFactor{GL_ONE_MINUS_SRC_ALPHA};

	float	mOpacity{ 1.0f };

```
然后去`phong.frag`中加入透明度参数
透明度 = `alpha` * `opacity`
```glsl
//透明度
uniform float opacity;

void main()
{
	...
	vec3 objectColor  = texture(sampler, uv).xyz;
	float alpha  = texture(sampler, uv).a;
	...
	FragColor = vec4(finalColor, alpha * opacity);
}
```
去到`render.cpp`中，在`render`函数中设置默认关闭颜色混合，是因为颜色混合还是蛮消耗性能的，我们什么时候需要开启再开启即可，默认时关闭
```cpp
void Renderer::render(
	Scene* scene, 
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	////1 设置当前帧绘制的时候，opengl的必要状态机参数
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LESS);
	glDepthMask(GL_TRUE);

	glDisable(GL_POLYGON_OFFSET_FILL);
	glDisable(GL_POLYGON_OFFSET_LINE);

	// 开启测试、设置基本写入状态，打开模板测试写入
	glEnable(GL_STENCIL_TEST);
	glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);
	glStencilMask(0xFF);//保证模板缓冲可以被清理

	// 默认关闭颜色混合
	glDisable(GL_BLEND);

	...
}

```
在`render.h`中创建并在`render.cpp`中实现`setBlendState`
```cpp
void Renderer::setBlendState(Material* material)
{
	if (material->mBlend) {
		glEnable(GL_BLEND);
		glBlendFunc(material->mSFactor, material->mDFactor);
	}
	else {
		glDisable(GL_BLEND);
	}
}
```
在`renderObject`方法中使用`setBlendState`并将透明度变量传到`shader`当中
```cpp
//针对单个object进行渲染
void Renderer::renderObject(
	Object* object,
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	...

		//设置渲染状态
		setDpethState(material);
		setPolygonOffsetState(material);
		setStencilState(material);
		setBlendState(material);

		//1 决定使用哪个Shader 
		Shader* shader = pickShader(material->mType);

		//2 更新shader的uniform
		shader->begin();

		switch (material->mType) {
		case MaterialType::PhongMaterial: {
			PhongMaterial* phongMat = (PhongMaterial*)material;

			...
			//透明度
			shader->setFloat("opacity", material->mOpacity);
		}
										break;
		...
}

```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyNjAzMDQ3MzQsLTEwNTE3ODMwMTldfQ
==
-->