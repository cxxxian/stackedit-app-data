在`material.h`中创建相应的有关于颜色混合的变量
```cpp
public:
	...
	//颜色混合
	bool	mBlend{ false };
	unsigned int	mSFactor{GL_SRC_ALPHA};
	unsigned int	mDFactor{GL_ONE_MINUS_SRC_ALPHA};

	float	mOpacity{ 1.0f };

```
然后去`phong.frag`中加入透明度参数
透明度 = `alpha` * `opacity`
```glsl
//透明度
uniform float opacity;

void main()
{
	...
	vec3 objectColor  = texture(sampler, uv).xyz;
	float alpha  = texture(sampler, uv).a;
	...
	FragColor = vec4(finalColor, alpha * opacity);
}
```
去到`render.cpp`中，在`render`函数中设置默认关闭颜色混合，是因为颜色混合还是蛮消耗性能的，我们什么时候需要开启再开启即可，默认时关闭
```cpp
void Renderer::render(
	Scene* scene, 
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	////1 设置当前帧绘制的时候，opengl的必要状态机参数
	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LESS);
	glDepthMask(GL_TRUE);

	glDisable(GL_POLYGON_OFFSET_FILL);
	glDisable(GL_POLYGON_OFFSET_LINE);

	// 开启测试、设置基本写入状态，打开模板测试写入
	glEnable(GL_STENCIL_TEST);
	glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);
	glStencilMask(0xFF);//保证模板缓冲可以被清理

	// 默认关闭颜色混合
	glDisable(GL_BLEND);

	...
}

```
在`render.h`中创建并在`render.cpp`中实现`setBlendState`
```cpp
void Renderer::setBlendState(Material* material)
{
	if (material->mBlend) {
		glEnable(GL_BLEND);
		glBlendFunc(material->mSFactor, material->mDFactor);
	}
	else {
		glDisable(GL_BLEND);
	}
}
```
在`renderObject`方法中使用`setBlendState`并将透明度变量传到`shader`当中
```cpp
//针对单个object进行渲染
void Renderer::renderObject(
	Object* object,
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	...

		//设置渲染状态
		setDpethState(material);
		setPolygonOffsetState(material);
		setStencilState(material);
		setBlendState(material);

		//1 决定使用哪个Shader 
		Shader* shader = pickShader(material->mType);

		//2 更新shader的uniform
		shader->begin();

		switch (material->mType) {
		case MaterialType::PhongMaterial: {
			PhongMaterial* phongMat = (PhongMaterial*)material;

			...
			//透明度
			shader->setFloat("opacity", material->mOpacity);
		}
										break;
		...
}

```
最后我们去到`main.cpp`中，创建一个立方体使用窗户贴图，
```cpp
void prepare() {
	renderer = new Renderer();
	scene = new Scene();

	auto geometry = Geometry::createBox(4.0f);
	auto materialA = new PhongMaterial();
	materialA->mDiffuse = new Texture("assets/textures/window.png", 0);
	auto meshA = new Mesh(geometry, materialA);
	scene->addChild(meshA);
	
	
	dirLight = new DirectionalLight();
	dirLight->mDirection = glm::vec3(-1.0f);
	dirLight->mSpecularIntensity = 0.1f;

	ambLight = new AmbientLight();
	ambLight->mColor = glm::vec3(0.1f);
}

```
还未开启颜色混合的效果如下，是不透明的物体

![输入图片说明](/imgs/2025-02-10/K5foo2aOFUXzWv7X.png)

开启颜色混合和关闭深度写入后，即可得到透明效果

![输入图片说明](/imgs/2025-02-10/H7xD9PyftdF9rm1U.png)

以上功能支持我们自己创建的几何体，并`new`出自己的材质，但当我们用`AssimpLoader`读取模型时，要想实现设置透明的功能，需要对模型进行深度搜索遍历（因为模型存储可以理解为树形结构）

设计如下`SetModelBlend`函数，即能实现深度搜索遍历，在遍历过程中对每一个`mesh`都设置相应的颜色混合赋值。
这里的`object`和`mesh`的概念需回顾先前的设计，`mesh`才是实际有几何的节点，`object`只充当一个树枝的作用，`mesh`是`object`的子节点
```cpp
void SetModelBlend(Object* obj, bool blend, float opacity) {
	if (obj->getType() == ObjectType::Mesh) {
		Mesh* mesh = (Mesh*)obj;
		Material* material = mesh->mMaterial;
		material->mBlend = blend;
		material->mOpacity = opacity;
		material->mDepthWrite = false;
	}
	auto children = obj->getChildren();
	for (int i = 0; i < children.size(); i++) {
		SetModelBlend(children[i], blend, opacity);
	}
}

void prepare() {
	renderer = new Renderer();
	scene = new Scene();

	auto model = AssimpLoader::load("assets/fbx/bag/backpack.obj");
	SetModelBlend(model, true, 0.5f);
	scene->addChild(model);
	...
}
```
通过如上我们就可以实现模型读取的透明度设置，效果如下。

![输入图片说明](/imgs/2025-02-10/Ge2uF8xDztpvWDVs.png)

但是正由我们先前提到的`OpenGL`乱序读取的问题，其实是会造成颜色混合的`BUG`。
`A`，`B`，`C`三个面片从前往后绘制然后混合和从后往前绘制并混合其实是有差别的，但是我们人眼很难看得出来。
从后往前是我们期望的绘制顺序，颜色混合也是正常的
但是从前往后的话，即使我们关闭深度写入，`B`会在`A`的基础上进行混合，`C`同理，最后得到的颜色会以`C`权重更大（这是不理想的情况）

### 关于绘制顺序解决

![输入图片说明](/imgs/2025-02-11/SCuNtuRcdY9qRcF1.png)

先绘制不透明物体，透明物体按照摄像机的距离顺序，从后往前绘制
实现步骤如下：
1. 创建不透明和透明物体队列，并且每一帧渲染前要清空
在`render.h`中创建两个队列
```cpp
private:
	//生成多种不同的shader对象
	//根据材质类型的不同，挑选使用哪一个shader对象
	Shader* mPhongShader{ nullptr };
	Shader* mWhiteShader{ nullptr };
	Shader* mDepthShader{ nullptr };

	//不透明物体和透明物体的队列
	//注意：每一帧绘制前，都需要清空两个队列
	std::vector<Mesh*> mOpacityObjects{};
	std::vector<Mesh*> mTransparentObjects{};
```
并且到`render.cpp`中的`render`函数中，实现队列清空操作
```cpp
void Renderer::render(
	Scene* scene, 
	Camera* camera,
	DirectionalLight* dirLight,
	AmbientLight* ambLight
) {
	...

	//2 清理画布 
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

	//清理队列
	mOpacityObjects.clear();
	mTransparentObjects.clear();

	//3 将scene当作根节点开始递归渲染
	renderObject(scene, camera, dirLight, ambLight);
}

```

2. 在`render`中，修改对`scene`的解析，将不透明物体与透明物体装入不同队列
在`render.h`中创建方法，用来将不透明物体与透明物体装入不同队列
```cpp
private:
	void projectObecjt(Object* obj);
```
在`render.cpp`中实现
```cpp
void Renderer::projectObecjt(Object* obj)
{
	if (obj->getType() == ObjectType::Mesh) {
		Mesh* mesh = (Mesh*)obj;
		Material* material = mesh->mMaterial;
		if (material->mBlend) {
			mTransparentObjects.push_back(mesh);
		}
		else {
			mOpacityObjects.push_back(mesh);
		}
	}
	auto children = obj->getChildren();
	for (int i = 0; i < children.size(); i++) {
		projectObecjt(children[i]);
	}
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTAyODk3ODI2OCw2NzI1MDY3MjgsLTE3MD
EyOTcwNTYsODYzNDIxODUsLTcxNTUxODI1MSwtMzQ0OTA4MjUy
LDgzMzQxMjA1MSwtMTI2MDMwNDczNCwtMTA1MTc4MzAxOV19
-->