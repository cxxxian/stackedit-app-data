### 1. **视锥体剔除的工作原理**

#### **视锥体的定义**

视锥体（View Frustum）是由摄像机的投影矩阵和视图矩阵定义的六面体，包括：

-   **近裁剪面（Near Plane）**
    
-   **远裁剪面（Far Plane）**
    
-   **左裁剪面（Left Plane）**
    
-   **右裁剪面（Right Plane）**
    
-   **上裁剪面（Top Plane）**
    
-   **下裁剪面（Bottom Plane）**
    

#### **判断物体是否在视锥体内的方法**

1.  **包围盒（Bounding Box）**：通常使用包围盒（如轴对齐包围盒 AABB 或球形包围盒）来近似表示物体的边界。
    
2.  **平面与点的测试**：视锥体的每个裁剪面可以表示为一个平面方程。通过将物体的包围盒的顶点与这些平面方程进行比较，可以判断物体是否在视锥体外。
    

### 2. **手动实现视锥体剔除**

#### **计算视锥体的裁剪平面**

以下代码展示了如何计算视锥体的裁剪平面：

cpp

复制

```cpp
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

struct Frustum {
    glm::vec4 planes[6]; // 6个裁剪平面

    void calculate(const glm::mat4& viewProjection) {
        glm::mat4 m = viewProjection;
        planes[0] = m[3] + m[0]; // 左裁剪面
        planes[1] = m[3] - m[0]; // 右裁剪面
        planes[2] = m[3] + m[1]; // 下裁剪面
        planes[3] = m[3] - m[1]; // 上裁剪面
        planes[4] = m[3] + m[2]; // 近裁剪面
        planes[5] = m[3] - m[2]; // 远裁剪面
    }
};
```

-   **`viewProjection`**：视图矩阵和投影矩阵的乘积。
    
-   **`planes`**：存储视锥体的六个裁剪平面的法向量和距离。
    

#### **检查物体是否在视锥体内**

以下代码展示了如何检查一个物体是否在视锥体内：

cpp

复制

```cpp
struct AABB {
    glm::vec3 min;
    glm::vec3 max;
};

bool isInsideFrustum(const Frustum& frustum, const AABB& aabb) {
    for (int i = 0; i < 6; ++i) {
        glm::vec4 plane = frustum.planes[i];
        float d1 = glm::dot(plane, glm::vec4(aabb.min, 1.0f));
        float d2 = glm::dot(plane, glm::vec4(aabb.max, 1.0f));
        if (d1 < 0.0f && d2 < 0.0f) {
            return false; // 物体完全在裁剪平面外
        }
    }
    return true; // 物体在视锥体内
}
```

-   **`aabb.min` 和 `aabb.max`**：包围盒的最小和最大顶点。
    
-   **`plane`**：裁剪平面的法向量和距离。
    
-   **`d1` 和 `d2`**：包围盒的最小和最大顶点到裁剪平面的距离。
    

#### **使用视锥体剔除**

以下代码展示了如何在渲染循环中使用视锥体剔除：

cpp

复制

```cpp
Frustum frustum;
glm::mat4 viewProjection = projection * view;
frustum.calculate(viewProjection);

for (const auto& object : sceneObjects) {
    AABB aabb = object.getAABB();
    if (isInsideFrustum(frustum, aabb)) {
        object.render();
    }
}
```

-   **`viewProjection`**：视图矩阵和投影矩阵的乘积。
    
-   **`frustum.calculate(viewProjection)`**：计算视锥体的裁剪平面。
    
-   **`isInsideFrustum(frustum, aabb)`**：检查物体是否在视锥体内。
    
-   **`object.render()`**：如果物体在视锥体内，则渲染该物体。
    

### 3. **总结**

-   **视锥体剔除**：一种优化技术，用于确定哪些物体在当前视锥体内，从而避免渲染那些不可见的物体。
    
-   **计算裁剪平面**：通过视图矩阵和投影矩阵的乘积计算视锥体的裁剪平面。
    
-   **检查物体是否在视锥体内**：使用包围盒和裁剪平面的平面方程进行测试。
    
-   **手动实现**：需要自己实现视锥体剔除逻辑，或者使用现有的图形引擎或库来帮助你完成这一任务。


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTAyNjc1MjE5Nl19
-->