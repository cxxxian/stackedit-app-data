### **一、CPU 端（应用阶段）**

-   **应用逻辑**：游戏逻辑、物理运算、AI、相机更新等。
    
-   **场景管理**：组织场景图、剔除不可见物体（视锥裁剪、遮挡裁剪等）。
    
-   **渲染指令生成**：把需要绘制的物体转化为 **Draw Call**（提交给 GPU）。
    
-   **数据准备**：创建/更新顶点缓冲、索引缓冲、材质参数、纹理、Uniform/SSBO 等。
    

👉 CPU 的目标：把数据交给 GPU，减少状态切换和 Draw Call 的数量。

----------

### **二、GPU 端（图形流水线）**

#### 1. **顶点着色阶段（Vertex Shader, VS）**

-   输入：**顶点数据**（位置、法线、UV、切线等）。
    
-   主要工作：
    
    -   模型空间 → 世界空间 → 观察空间 → 裁剪空间的坐标变换。
        
    -   计算或传递纹理坐标、颜色、法线等属性。
        
-   输出：裁剪空间坐标，插值用的属性。
    

----------

#### 2. **曲面细分（可选：Tessellation）**

-   **细分控制着色器 (TCS)**：决定细分程度。
    
-   **细分评估着色器 (TES)**：生成新的顶点位置（例如弯曲曲面）。
    
-   用途：LOD、曲面细化、地形渲染等。
    

----------

#### 3. **几何着色器（可选：Geometry Shader, GS）**

-   输入：一个基本图元（点/线/三角形）。
    
-   可以：
    
    -   生成新的图元（扩展/放大）。
        
    -   丢弃图元。
        
    -   例如：点精灵扩展成四边形、法线可视化。
        

----------

#### 4. **裁剪与屏幕映射**

-   **视锥裁剪**：丢弃落在裁剪空间外的顶点/图元。
    
-   **视口变换**：把坐标从 NDC（[-1,1]范围）映射到屏幕像素坐标。
    

----------

#### 5. **光栅化（Rasterization）**

-   把图元（三角形）转化为 **片段 (Fragment, 类似像素)**。
    
-   插值：顶点着色器传出的属性（颜色、UV、法线）被插值到每个片段。
    
-   剔除：背面剔除（Back-face culling）、多边形偏移等。
    

----------

#### 6. **片段着色阶段（Fragment Shader / Pixel Shader, FS/PS）**

-   输入：一个片段（带插值属性）。
    
-   工作内容：
    
    -   采样纹理（颜色贴图、法线贴图、粗糙度、金属度等）。
        
    -   计算光照（Phong、PBR、阴影、IBL）。
        
    -   输出颜色、深度值等。
        

----------

#### 7. **片段测试与合并（Output Merger）**

对 FS 输出的片段，逐个进行测试与混合：

-   **深度测试（Depth Test）**：检查是否被遮挡。
    
-   **模板测试（Stencil Test）**：用于描边、后处理 Mask。
    
-   **混合（Blending）**：和帧缓冲已有颜色混合（透明、半透明）。
    
-   **写入帧缓冲**：颜色缓冲（Color Buffer）、深度缓冲（Depth Buffer）、模板缓冲（Stencil Buffer）。
    

----------

### **三、后处理阶段（Post-Processing）**

在片段全部绘制完成后，通常会再开一条 **全屏三角形 / 四边形** 的渲染流程：

-   HDR → LDR 映射（Tone Mapping）。
    
-   Bloom、景深、运动模糊、屏幕空间反射（SSR）。
    
-   后期合成（UI、特效叠加）。
    
-   最终写入 **显示缓冲区 (Back Buffer)**。
    

----------

### **四、显示阶段**

-   **交换缓冲 (Swap Buffers)**：后台缓冲区内容传到前台显示。
    
-   显示器扫描输出图像。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTg4OTUwNzIxN119
-->