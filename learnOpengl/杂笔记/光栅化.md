# 光栅化

## 1. 基础职责（最传统的部分）

-   **扫描变换 (Rasterization)**：决定三角形覆盖了哪些像素（片元）。
    
-   **填充规则 (Fill rules)**：比如左上填充规则（top-left rule），避免共享边界的三角形重复/遗漏填充。
    

----------

## 2. 插值计算

光栅化不仅是“把像素打上色”，还要插值出三角形顶点带来的各种属性：

-   **深度 (z 值)**：做 Z-buffer 深度测试。
    
-   **颜色 (顶点着色器输出的颜色)**。
    
-   **纹理坐标 (uv)**。
    
-   **法线、切线等**（用于光照和法线贴图）。
    

注意：因为透视投影不是线性的，**纹理坐标等要做透视校正插值**，否则会产生拉伸失真。

----------

## 3. 光栅化阶段的裁剪与舍弃

-   **背面剔除 (Back-face culling)**：通过三角形的顶点顺序（顺时针/逆时针）判断是否朝向摄像机，背面丢弃。
    
-   **视口裁剪**：屏幕外的部分不会产生片元。
    
-   **Scissor Test**：限制绘制区域。
    

----------

## 4. 片元生成后的测试

虽然严格来说这是“光栅化之后 → 片元处理阶段”，但它是紧密耦合的：

-   **深度测试 (Depth Test)**：决定片元是否可见。
    
-   **模板测试 (Stencil Test)**：用于复杂遮罩/特效。
    
-   **Alpha Test / discard**：透明度裁剪。
    

----------

## 5. 次级功能（更高级的光栅化需求）

-   **多重采样 (MSAA)**：一个像素多个采样点，提高边缘质量。
    
-   **早期深度剔除 (Early-Z)**：在像素着色之前用深度快速丢弃不可见片元，提高性能。
    
-   **保守光栅化 (Conservative Rasterization)**：保证只要三角形覆盖像素，就一定触发片元（常用于 GPU 碰撞检测、光栅化阴影体积）。
    
-   **可编程采样 (Sample Shading)**：比如在 Vulkan/DirectX12 中可以直接控制样本级 shading。
    

----------

## 6. 辅助计算

-   **三角形边函数 (Edge function)**：判断像素是否在三角形内，比扫描线更通用。
    
-   **重心坐标 (Barycentric coordinates)**：高效计算插值权重。
    
-   **屏幕空间导数 (ddx, ddy)**：用来自动选择 mipmap level。
    

----------

✅ 总结一下：  
三角形光栅化除了扫描线/填充，它还需要：

1.  插值各种属性（深度、颜色、UV、法线…），且做透视校正。
    
2.  进行可见性测试（深度、模板、alpha）。
    
3.  支持抗锯齿、早期 Z 剔除等优化。
    
4.  提供 barycentric 坐标和 ddx/ddy 供后续片元阶段使用。
    

所以三角形光栅化是一个“确定片元覆盖 + 插值属性 + 提供后续测试和 shading 输入”的完整过程。


# 左上填充规则
## 1. 问题背景

在三角形网格里，相邻的两个三角形常常**共享一条边**：

-   如果两边都认为边界上的像素属于自己 → **重复绘制**。
    
-   如果两边都认为边界上的像素不属于自己 → **出现缝隙**。
    

所以，需要一个**一致的规则**来决定某个像素在“边界上”时，属于哪个三角形。

----------

## 2. 左上填充规则 (Top-Left Rule)

**定义**：

-   如果像素中心正好落在三角形的**左边界**或**上边界**上，那么这个像素算作被三角形覆盖；
    
-   如果像素中心落在三角形的**右边界**或**下边界**上，那么不算被覆盖。
    

这里“左边界/上边界”的定义是：

-   **上边界**：边的 y 值较小的顶点在下方（往上升的边），并且水平边里，把 **水平的上边** 算作上边界。
    
-   **左边界**：边相对于扫描方向在左边。
    

换句话说，图形学硬件会把边分成 “top/left” 和 “bottom/right”，然后**只包含 top/left 边上的像素**。

----------

## 3. 举例

想象一个正方形被拆成两个三角形：
```
  (0,1) *----* (1,1)
         |\  |
         | \ |
         |  \|
  (0,0) *----* (1,0)

```
-   左上三角形覆盖 “对角线” → 它包含 **左边和上边的像素**。
    
-   右下三角形覆盖 “对角线” → 它包含 **右边和下边的像素**。
    

这样，正方形边界的像素**不会重复填充，也不会漏掉**。

----------

## 4. 为什么要这样？

-   **一致性**：保证整个屏幕的像素分配规则固定，不会出现某些边缘“有时候画、有时候不画”。
    
-   **避免缝隙/重叠**：确保两个三角形拼接时像素既不重复也不遗漏。
    
-   **硬件友好**：在 GPU 的光栅化器里，这条规则可以简单地用边函数符号判断实现。
    

----------

## 5. 总结

-   **左上填充规则**是 GPU 光栅化的标准规范。
    
-   它规定：
    
    -   “左边界 + 上边界” → 属于三角形；
        
    -   “右边界 + 下边界” → 不属于三角形。
        
-   目的是**避免重复/缺失**，保证拼接网格严丝合缝。


# 斜线
**斜线边界在左上填充规则 (Top-Left rule) 里到底算哪边？**

----------

## 1. 先复习规则

-   **左边界 / 上边界**：包含。
    
-   **右边界 / 下边界**：不包含。
    

对于水平线（y 不变） → 只包含“上边”的一条。  
对于垂直线（x 不变） → 只包含“左边”的一条。  
那么 **斜线（既不是水平也不是垂直）** 怎么办？

----------

## 2. 斜线的判定方式

其实图形学硬件里有一个**统一的判断方法**：

> 对于一条边，如果它是从顶点 v0(x0,y0)v_0(x_0,y_0)v0​(x0​,y0​) 指向 v1(x1,y1)v_1(x_1,y_1)v1​(x1​,y1​)：
> 
> -   如果 **y 上升**（y0<y1y_0 < y_1y0​<y1​），那这条边算作 **左边界**。
>     
> -   如果 **y 不上升**（水平线情况），就看它是不是“上边界”。
>     
> -   否则这条边算作 **右边界**。
>     

所以：

-   一条 **向上的斜线边** → 属于三角形（左边界）。
    
-   一条 **向下的斜线边** → 不属于三角形（右边界）。
    

----------

## 3. 举例

假设我们有一个正方形被对角线切开：
```
(0,1) *----*
       |  /|
       | / |
       |/  |
(0,0) *----*

```

对角线是从左下 (0,0) 到右上 (1,1)。

-   这条边是 **y 上升的斜线** → 按规则，它是“左边界”。
    
-   所以它的像素由 **左下三角形**来填充。
另一种切法：
```
(0,1) *----*
       |\  |
       | \ |
       |  \|
(0,0) *----*

```
-   对角线是从左上 (0,1) 到右下 (1,0)。
    
    -   这条边是 **y 下降的斜线** → 按规则，它是“右边界”。
        
    -   所以它的像素由 **右下三角形**来填充。
        
这样就保证拼合的时候不会重复或漏掉像素。

## 4. 总结

-   **水平边** → 取上边。
    
-   **垂直边** → 取左边。
    
-   **斜线边**：
    
    -   如果 **往上升** → 属于三角形；
        
    -   如果 **往下降** → 不属于三角形。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2MTE5NDY2NTVdfQ==
-->