# 光栅化

## 1. 基础职责（最传统的部分）

-   **扫描变换 (Rasterization)**：决定三角形覆盖了哪些像素（片元）。
    
-   **填充规则 (Fill rules)**：比如左上填充规则（top-left rule），避免共享边界的三角形重复/遗漏填充。
    

----------

## 2. 插值计算

光栅化不仅是“把像素打上色”，还要插值出三角形顶点带来的各种属性：

-   **深度 (z 值)**：做 Z-buffer 深度测试。
    
-   **颜色 (顶点着色器输出的颜色)**。
    
-   **纹理坐标 (uv)**。
    
-   **法线、切线等**（用于光照和法线贴图）。
    

注意：因为透视投影不是线性的，**纹理坐标等要做透视校正插值**，否则会产生拉伸失真。

----------

## 3. 光栅化阶段的裁剪与舍弃

-   **背面剔除 (Back-face culling)**：通过三角形的顶点顺序（顺时针/逆时针）判断是否朝向摄像机，背面丢弃。
    
-   **视口裁剪**：屏幕外的部分不会产生片元。
    
-   **Scissor Test**：限制绘制区域。
    

----------

## 4. 片元生成后的测试

虽然严格来说这是“光栅化之后 → 片元处理阶段”，但它是紧密耦合的：

-   **深度测试 (Depth Test)**：决定片元是否可见。
    
-   **模板测试 (Stencil Test)**：用于复杂遮罩/特效。
    
-   **Alpha Test / discard**：透明度裁剪。
    

----------

## 5. 次级功能（更高级的光栅化需求）

-   **多重采样 (MSAA)**：一个像素多个采样点，提高边缘质量。
    
-   **早期深度剔除 (Early-Z)**：在像素着色之前用深度快速丢弃不可见片元，提高性能。
    
-   **保守光栅化 (Conservative Rasterization)**：保证只要三角形覆盖像素，就一定触发片元（常用于 GPU 碰撞检测、光栅化阴影体积）。
    
-   **可编程采样 (Sample Shading)**：比如在 Vulkan/DirectX12 中可以直接控制样本级 shading。
    

----------

## 6. 辅助计算

-   **三角形边函数 (Edge function)**：判断像素是否在三角形内，比扫描线更通用。
    
-   **重心坐标 (Barycentric coordinates)**：高效计算插值权重。
    
-   **屏幕空间导数 (ddx, ddy)**：用来自动选择 mipmap level。
    

----------

✅ 总结一下：  
三角形光栅化除了扫描线/填充，它还需要：

1.  插值各种属性（深度、颜色、UV、法线…），且做透视校正。
    
2.  进行可见性测试（深度、模板、alpha）。
    
3.  支持抗锯齿、早期 Z 剔除等优化。
    
4.  提供 barycentric 坐标和 ddx/ddy 供后续片元阶段使用。
    

所以三角形光栅化是一个“确定片元覆盖 + 插值属性 + 提供后续测试和 shading 输入”的完整过程。



<!--stackedit_data:
eyJoaXN0b3J5IjpbOTQ4NjIwNTM1XX0=
-->