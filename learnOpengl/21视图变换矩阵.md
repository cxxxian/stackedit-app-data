# 什么是视图变化矩阵
![输入图片说明](/imgs/2024-11-01/vqNFhUddJPl5RxED.png)
![输入图片说明](/imgs/2024-11-01/IY1DPBaTawXDzC5Q.png)
原本摄像机朝向-z轴，计算相对方便，此时被旋转后投影变得麻烦
![输入图片说明](/imgs/2024-11-01/I4IEwdp9QVlUiRkU.png)
将p点投影到摄像机本地坐标系
![输入图片说明](/imgs/2024-11-01/jtjiXTi224lcSlnG.png)
![输入图片说明](/imgs/2024-11-01/DP2m227RrAnzYTYK.png)
![输入图片说明](/imgs/2024-11-01/PKvai9xpnVaEeSau.png)

**视图变换矩阵：物体从世界坐标系转到相机坐标系**
T是平移矩阵，R是旋转矩阵
![输入图片说明](/imgs/2024-11-01/kANY1vnTxj9tmDeD.png)
# 视图变换矩阵推导
![输入图片说明](/imgs/2024-11-01/Mb8YqLALwMYnFcI7.png)
![输入图片说明](/imgs/2024-11-01/xEPOzYxWQlp8KmZk.png)
这里假设了f是单位向量，否则右侧的式子同样需要normalize单位化
![输入图片说明](/imgs/2024-11-01/Dm3mwYsxlnYBtmhg.png)
![输入图片说明](/imgs/2024-11-01/rKYoiuZ2ttQqLKy0.png)
![输入图片说明](/imgs/2024-11-01/vxih8oqUjKj0chN5.png)
![输入图片说明](/imgs/2024-11-01/E4ob9U518JNEjVnw.png)
## final 结论
![输入图片说明](/imgs/2024-11-01/y7o4G5BbdRnSk03P.png)
# 实验
在`main.cpp`中声明一个`viewMatrix`。
```
glm::mat4 viewMatrix(1.0);
```
在`main.cpp`中声明一个函数`prepareCamera()`，用`lookAt`函数给`viewMatrix`赋值
```
void prepareCamera() {
    //lookat：生成一个viewMatrix
    //eye：当前摄像机所在的位置
    //center：当前摄像机看向的那个点
    //up：穹顶向量
    viewMatrix = glm::lookAt(glm::vec3(0.0f, 0.0f, 0.5f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));
}
```
在main函数中使用`prepareCamera()`
```
int main() {
	...
    prepareShader();
    //prepareInterleavedBuffer();
    //prepareVAOForGLTriangles();
    prepareVAO();
    prepareTexture();
    prepareCamera();

    while (app->update()) {
        render();
        //渲染操作
    }
    app->destroy();
    delete texture;

    return 0;
}
```
接下来，因为我们声明`viewMatrix`是用来把物体从世界坐标转化到摄像机坐标系下，所以我们要去`vertex.glsl`中对坐标进行操作
因为各个顶点共用一个视图变换，所以声明为`uniform mat4 viewMatrix`
最后将`position = viewMatrix * transform * position`，transform * position是原本的世界坐标，如果有变换`transform`用来变换，最后乘上`viewMatrix`既可以转到摄像机坐标系下
```
#version 460 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aColor;
layout (location = 2) in vec2 aUV;
out vec3 color;
out vec2 uv;

uniform mat4 transform;
uniform mat4 viewMatrix;

void main()
{
    vec4 position = vec4(aPos, 1.0);
    position = viewMatrix * transform * position;
    gl_Position = position;
    color = aColor;
    uv = aUV;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTg0OTg0ODgzNywxNjAzMjc2NzU2LC0xMD
A4MDM5MDg3LC0xMzU0NzA2MzczLC0xODc0OTYxMjcsNzAzNDg3
MzEwLC0xMTkxNDA2MDY2LDQwNjA4NTU3OV19
-->