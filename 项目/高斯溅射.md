
## ä¸€ã€è¯†åˆ«ä½ çš„ PLY æ ¼å¼ç±»å‹

é¦–å…ˆæ˜ç¡®ä½ çš„ `.ply` æ˜¯å“ªç§æ ¼å¼ï¼š

1.  **Unpacked æ ¼å¼**ï¼ˆæ¯ä¸ª splat æ˜¾å¼è®°å½•å±æ€§ï¼Œfloat ä¸ºä¸»ï¼‰
    
2.  **Packed æ ¼å¼**ï¼ˆå‹ç¼©ç¼–ç åçš„ï¼Œä½¿ç”¨ chunk åˆ†åŒºå’Œå­—èŠ‚ä½æ“ä½œï¼‰
    
3.  **SuperSplat æˆ–å…¶ä»–è‡ªå®šä¹‰æ ¼å¼**
    

ä¸åŒæ ¼å¼å½±å“è§£æå’Œä¸Šä¼ åˆ° GPU çš„æ–¹å¼ã€‚

----------

## äºŒã€åŸºæœ¬æµç¨‹æ¦‚è§ˆ

> ä»¥ä¸‹ä»¥ Three.js æˆ– WebGL ä¸ºä¾‹ï¼Œä¹Ÿé€‚ç”¨äºåŸç”Ÿ OpenGL / WebGPUã€‚

### 1. **åŠ è½½ `.ply` æ–‡ä»¶å¹¶è§£ææ•°æ®**

#### è§£ææ­¥éª¤ï¼š

-   è¯»å–å¤´éƒ¨ï¼ˆHeaderï¼‰  
    åˆ¤æ–­å±æ€§ç±»å‹ï¼Œå¦‚ï¼š
    
```
property float x 
property float y 
property float z 
property float scale_0 
property float quaternion_0 
property uchar red ...
```
    
-   æŒ‰æ•°æ®æ ¼å¼ï¼ˆASCII æˆ– binaryï¼‰è¯»å–æ‰€æœ‰ç‚¹ï¼ˆsplatï¼‰å±æ€§ï¼š
    
    -   ä½ç½®ï¼ˆx, y, zï¼‰
        
    -   æ–¹å‘ï¼ˆquaternion æˆ– covariance çŸ©é˜µï¼‰
        
    -   å°ºåº¦ï¼ˆscale_x, scale_y, scale_zï¼‰
        
    -   é¢œè‰²ï¼ˆRGB æˆ– RGBAï¼‰
        
    -   ä¸ç¡®å®šæ€§å‚æ•°ï¼ˆlog scale, alpha, etcï¼‰
        

> å¦‚æœæ˜¯ packed æ ¼å¼ï¼Œä½ éœ€è¦å…ˆâ€œè§£ç â€ä¸º float æ ¼å¼ï¼Œæ‰èƒ½ç»§ç»­åç»­å¤„ç†ã€‚

----------

### 2. **ç»„ç»‡æ•°æ®å¹¶ä¸Šä¼ åˆ° GPUï¼ˆæ„å»º Bufferï¼‰**

æŠŠæ¯ä¸ª splat çš„å±æ€§æ•´ç†æˆé€‚åˆä¸Šä¼ åˆ° GPU çš„ç»“æ„ï¼Œæ¯”å¦‚ï¼š

```
// ç¤ºä¾‹ç»“æ„ [   
center.x, center.y, center.z,   
scale.x, scale.y, scale.z,   
quat.x, quat.y, quat.z, quat.w,   
r, g, b, a,   ... 
]
```

-   åˆ›å»º `Float32Array` æˆ– `Uint8Array` æ¥å­˜æ”¾è¿™äº›æ•°æ®ã€‚
    
-   ä½¿ç”¨ `THREE.BufferGeometry` å’Œ `BufferAttribute` ä¸Šä¼ ã€‚
    

----------

### 3. **ç¼–å†™è‡ªå®šä¹‰ç€è‰²å™¨ï¼ˆVertex + Fragmentï¼‰**

#### é¡¶ç‚¹ç€è‰²å™¨ï¼ˆVertex Shaderï¼‰

-   è§£æ splat çš„å±æ€§ï¼ˆä½ç½®ã€ç¼©æ”¾ã€æ–¹å‘ã€é¢œè‰²ç­‰ï¼‰
    
-   è®¡ç®—é«˜æ–¯æŠ•å½±åˆ°å±å¹•ç©ºé—´çš„æ¤­åœ†å‚æ•°ï¼ˆM matrix æˆ–ç±»ä¼¼ï¼‰
    
-   è¾“å‡ºç»™ç‰‡æ®µç€è‰²å™¨
    

#### ç‰‡æ®µç€è‰²å™¨ï¼ˆFragment Shaderï¼‰

-   å¯¹æ¯ä¸ªåƒç´ åšé€æ˜èåˆï¼ˆalpha blendingï¼‰
    
-   åŸºäºé«˜æ–¯å¯†åº¦åœºå åŠ è´¡çŒ®ï¼ˆæƒé‡ + é¢œè‰²ï¼‰
    

å‚è€ƒé«˜æ–¯ splatting çš„è®ºæ–‡ä¸­çš„å±å¹•ç©ºé—´èåˆå…¬å¼ã€‚

----------

### 4. **æ··åˆè®¾ç½®ä¸æ¸²æŸ“æ§åˆ¶**

-   å¯ç”¨é€æ˜æ··åˆï¼š
    
```
gl.enable(gl.BLEND); 
gl.blendFunc(gl.ONE, gl.ONE); // åŠ æƒèåˆ
```
    
-   æ§åˆ¶ splat æ•°é‡ï¼ˆLODã€Chunk-basedï¼‰
    
-   æ·±åº¦æ’åºæˆ–å‰å‘ç´¯åŠ ï¼ˆDepends on rendererï¼‰


## ä¸ºä»€ä¹ˆè¦å¯¹é«˜æ–¯ä½“æ’åºï¼Ÿ

### **1. ä¸ºäº†æ­£ç¡®çš„é€æ˜åº¦æ¸²æŸ“ï¼ˆAlpha Blendingï¼‰**

é«˜æ–¯ splatting é€šå¸¸ä½¿ç”¨ **åŠ æƒé¢œè‰²èåˆ**ï¼ˆä¾‹å¦‚åŠ æƒå¹³å‡ï¼ŒOITï¼šOrder Independent Transparency çš„ä¸€ç§å˜ä½“ï¼‰ï¼Œä½†**å¦‚æœä½¿ç”¨æ ‡å‡† alpha blendingï¼ˆå¦‚ gl.ONE, gl.ONE_MINUS_SRC_ALPHAï¼‰æ—¶ï¼Œé¡ºåºå°±å¾ˆé‡è¦**ã€‚

#### ä¸¾ä¾‹ï¼š

å‡å¦‚ä½ ä»åå¾€å‰ç”»ï¼š

`èƒŒæ™¯ â†’ è¿œå¤„ splat â†’ è¿‘å¤„ splat`

è‹¥é¡ºåºé”™äº†ï¼ˆå…ˆç”»è¿‘çš„å†ç”»è¿œçš„ï¼‰ï¼Œè¿œå¤„çš„ splat ä¼šè¢«ä¸æ­£ç¡®åœ°é®æŒ¡æˆ–æ··åˆï¼Œäº§ç”Ÿï¼š

-   é¢œè‰²åæš—
    
-   äº®åº¦ä¸çœŸå®
    
-   è¾¹ç¼˜æ–­è£‚ã€é”™ä½æ„Ÿ
    

ğŸ¯ **è§£å†³åŠæ³•ï¼šæŒ‰è§†ç‚¹è·ç¦»ä»è¿œåˆ°è¿‘æ’åº splats**ï¼ˆPainterâ€™s Algorithmï¼‰

----------

### **2. æ”¯æŒé€æ­¥æ¸²æŸ“æˆ–åˆ†å—åŠ è½½**

æ’åºä¹‹åï¼Œå¯ä»¥ï¼š

-   **è£å‰ªæ‰é åçš„ splat**ï¼ˆæå‡æ€§èƒ½ï¼‰
    
-   **åªæ¸²æŸ“å‰ N ä¸ªæœ€é‡è¦ splats**ï¼ˆä¾‹å¦‚åœ¨ LOD ä¸­ï¼ŒæŒ‰è´¡çŒ®åº¦æ’åºï¼‰
    

### **3. å®ç°æ­£ç¡®çš„å‰å‘åŠ æƒå¹³å‡èåˆ**

é«˜æ–¯æ¸²æŸ“å¸¸ç”¨ï¼š

```
gl.blendFunc(gl.ONE, gl.ONE);
```

æˆ–è€…ï¼š

```
gl_FragColor.rgb += weight * color; 
gl_FragColor.a   += weight;
```
ä¹‹åå† `normalizeï¼š`

```
finalColor = accum.rgb / accum.a;
```

è™½ç„¶è¿™ç§æ–¹å¼ç†è®ºä¸Š**é¡ºåºæ— å…³ï¼ˆorder independentï¼‰**ï¼Œä½†å¦‚æœä½ çš„ shader è®¡ç®—ä¸­å¼•å…¥äº†éçº¿æ€§å› ç´ ï¼ˆä¾‹å¦‚ï¼š

-   **è¿‘å¤§è¿œå°çš„ scale æ˜ å°„**
    
-   **log-opacity å¤„ç†**
    
-   **early-Z discard**  
    ï¼‰ï¼Œå°±ä¼šå‡ºç°å®é™…æ•ˆæœä¾èµ–äºæ¸²æŸ“é¡ºåºã€‚

# shaderè®¾è®¡
é¡¶ç‚¹ç€è‰²å™¨ï¼ˆvertex shaderï¼‰â€”â€”æ ¸å¿ƒä»»åŠ¡ï¼šæ„å»ºå±å¹•ç©ºé—´æ¤­åœ†
```glsl
// è¾“å…¥å±æ€§ï¼šæ¯ä¸ª splat ä¸€ä¸ªç‚¹
in vec3 center;
in vec3 scale;
in vec4 quat;
in vec4 color;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

void main() {
    // 1. è®¡ç®— splat ä¸­å¿ƒçš„è§†å›¾ç©ºé—´ä½ç½®
    vec4 viewPos = modelViewMatrix * vec4(center, 1.0);

    // 2. æ„å»ºåæ–¹å·®çŸ©é˜µ Sigmaï¼ˆé«˜æ–¯æ‰©æ•£ï¼‰
    mat3 R = quaternionToRotationMatrix(quat);
    mat3 S = scaleMatrix(scale); // diagonal
    mat3 Sigma = R * S * transpose(R);

    // 3. æŠ•å½±å˜æ¢åˆ°å±å¹•ç©ºé—´
    mat3 J = computeJacobian(viewPos); // æŠ•å½±Jacobian
    mat3 A = J * Sigma * transpose(J); // å±å¹•ç©ºé—´åæ–¹å·®çŸ©é˜µ

    // 4. è¾“å‡ºé¡¶ç‚¹ä½ç½®ï¼ˆå±å¹•ä¸­å¿ƒï¼‰ä¾› rasterizer ç”¨
    gl_Position = projectionMatrix * viewPos;

    // 5. æŠŠ A çŸ©é˜µä¼ ç»™ fragmentï¼ˆéœ€è¦ flat varying æˆ– SSBOï¼‰
    out_mat3 A_screen = A;
    out_vec4 rgba = color;
}
```
ç‰‡æ®µç€è‰²å™¨ï¼ˆfragment shaderï¼‰â€”â€”æ ¸å¿ƒä»»åŠ¡ï¼šè®¡ç®—å¯†åº¦ + èåˆé¢œè‰²
```glsl
in mat3 A_screen; // å±å¹•ç©ºé—´åæ–¹å·®çŸ©é˜µ
in vec4 rgba;

out vec4 outColor;

void main() {
    // 1. å½“å‰åƒç´ ç›¸å¯¹æ¤­åœ†ä¸­å¿ƒçš„åç§»ï¼ˆåœ¨ NDC æˆ–å±å¹•ç©ºé—´ä¸­ï¼‰
    vec2 delta = gl_FragCoord.xy - center_screen.xy;

    // 2. è®¡ç®—é«˜æ–¯å¯†åº¦ï¼šÏ(x) = exp(-0.5 * x^T * A_inv * x)
    float density = exp(-0.5 * dot(delta, A_screen * delta));

    // 3. æ··åˆè¾“å‡º
    vec3 rgb = rgba.rgb * density;
    float alpha = rgba.a * density;

    outColor = vec4(rgb, alpha);
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTg2ODc1OTQyN119
-->