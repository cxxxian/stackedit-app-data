# GPU 得到的 metric
## 1. 什么是 metric

在 Spark 的排序阶段（`computeVec4.glsl`），  
**metric** 就是 GPU 为每个 splat 计算出来的 **排序关键值**（一个数，或几个打包的数）。

在最常见的情况（按深度排序）里：
```
metric = “splat 到相机的距离（深度）”
```
-   单精度模式（sort32）：metric 就是一个 float（float32）
    
-   双精度半精度模式（doubleSort）：metric 会打包成两个 float16 存在一个 RGBA8 像素里（这样一个像素能存两个 splat）

## 2. 它是怎么得到的

在 shader 中：
1.  **取 splat 中心点坐标**（GPU 从 PackedSplats 数据纹理/SSBO 里读取）
2.  **用相机矩阵转换到视图空间**

```glsl
vec3 viewPos = (viewMatrix * vec4(center, 1.0)).xyz;
```
1.  **根据排序策略算一个数**
    -   透视深度（`-viewPos.z`）
    -   或径向距离（`length(viewPos - origin)`）
    -   再加 `depthBias` 做微调
2.  **编码到 uvec4**
    -   半精度打包到 RG（两个 16-bit float）
    -   单精度放到 32-bit int

最终写到：
```
out uvec4 target; // FBO 的颜色输出
```
## 3. 它的作用

这个 metric 是排序的唯一输入：

-   渲染完后，FBO 里的每个像素就代表一个 splat 的 metric
    
-   `gl.readPixels` / `readRenderTargetPixelsAsync` 把它们回读到 CPU
    
-   CPU 再根据这个 metric 做桶排序，得到从远到近的 **ordering**（splat 绘制顺序）
    

----------

## 4. 为什么 metric 是必须的

高斯 splat 是半透明物体，**绘制顺序会影响最终颜色**
-   不排序：透明部分可能覆盖错误，出现“透明混合错乱”
-   有了 metric：
    -   CPU 可以把 splats 从远到近排序 
    -   渲染时按顺序加法混合   
    -   透明效果正确

----------

## 5. 一句话总结

> GPU 里的 metric 是“每个 splat 的排序关键值”，  
> 它用来告诉 CPU **哪个 splat 在前哪个在后**，这样 CPU 就能生成正确的绘制顺序。  
> 没有 metric，就没法对透明的 splat 做正确的混合。

# 排序

`vertexShader`中有一个`splatIndex`，`splatIndex` 用来控制渲染顺序的“排序索引”，它不是原始数据的复制，而是指向原始高斯体数据的索引。

### 具体来说：

-   你的原始高斯体数据，比如位置、颜色、旋转等，存储在一个纹理或缓冲区里，索引是固定的。
    
-   CPU端做排序时，不会动这些数据本身，而是生成一个新的数组，这个数组里面存的就是**原始数据的索引**，但按正确的渲染顺序排列。
    
-   GPU在绘制时，拿到这个排序后的索引(`splatIndex`)，然后用它去采样原始高斯体数据（纹理fetch等）。
    
-   这样就能保证绘制时，高斯体是按照你计算的顺序一个一个正确叠加渲染的。
    

----------

### 为什么不用直接移动原始数据？

-   原始数据可能很大，拷贝和移动代价高。
    
-   只操作索引，轻量高效。
    
-   GPU绘制支持索引缓冲（index buffer）或顶点属性，直接使用索引即可。
----------

总结：  
**排序的是“索引”，而不是数据本身。** 这样既节省性能，也方便管理。你现有的shader中`splatIndex`就是接收这个排序结果的索引变量。


## 排序实现
`splatGeometry.ts`这个代码，就是排序的关键接口之一，负责把 **排序好的索引数组** 传给 GPU，控制实例绘制的顺序。

### 详细解释：

-   构造函数里：
    
```
this.attribute = new THREE.InstancedBufferAttribute(ordering, 1, false, 1); 
this.setAttribute("splatIndex", this.attribute);
```
这里 `ordering` 就是排序好的索引数组，作为实例属性绑定到顶点着色器的 `splatIndex` 输入。
    
-   GPU绘制时，每个实例（即每个高斯溅射体）都会拿到对应的 `splatIndex`，然后用它去采样纹理或buffer里的原始高斯体数据。
    
-   `update` 方法可以动态更新排序后的索引数组，比如你每帧CPU重新排序后，调用 `update` 让GPU拿到新的顺序。
    
-   `instanceCount` 控制当前激活渲染的实例数量。


`splatViewPoint.ts`的`sortUpdate`方法，就是用来更新排序
真正实现排序的代码在`work.ts`中，有很多个`sort`函数，例如`sortSplat`
### `sortSplat`函数的作用和思路总结：

-   输入参数：
    
    -   `totalSplats`: 高斯体总数。
        
    -   `readback`: GPU 渲染后读取回来的深度数据数组（Uint8Array 分层存储）。
        
    -   `ordering`: 一个 Uint32Array，用来存放排序后的高斯体索引。
        
-   **核心原理**：
    
    这段代码使用了一种基于 **计数排序（counting sort）** 的思想，因为深度被编码为16位半精度浮点数（float16），可以先对深度值做分桶计数。
    
-   **步骤：**
    
    1.  初始化 `depthArray16`，它是一个长度为 DEPTH_SIZE_16（应该是 32768，16位半精度范围）的计数数组。
        
    2.  遍历所有深度数据，统计每个深度值出现的次数，存入 `depthArray16`。
        
    3.  通过累加计数，计算每个深度值在排序数组中的起始位置。
        
    4.  再次遍历所有深度，根据深度值在 `depthArray16` 记录的起始位置，将对应 splat 的索引写入 `ordering`。
        
    5.  返回有效（激活）的 splats 数量和排序后的索引数组。

# GPU端代码实现
`computeVec4.glsl`**为排序生成数据**。
它的作用是：

-   **根据 fragment 坐标 (`gl_FragCoord`) 确定当前要处理的 splat 索引**
    
-   **调用 `produceSplat(index)` 计算该 splat 的排序 metric（深度/距离）**
    
-   **把这个 metric 打包成 `uvec4` 写入颜色输出 `target`**（最终会进 FBO，被 CPU 读回）

1. 高精度声明
```glsl
precision highp float;
precision highp int;
precision highp sampler2D;
...
```
确保计算排序 metric 时有足够精度（尤其是深度）。
2. 排序目标控制
```glsl
uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;
out uvec4 target;
```
`targetLayer` / `targetBase` / `targetCount` 用来确定当前批次要处理的 splats 范围。
`target` 是输出的颜色数据（RGBA → uvec4），会被 `gl.readPixels` 读回。

3. GLSL 模板占位符

```glsl
{{ GLOBALS }} {{ STATEMENTS }}
```

这里是动态生成 shader 的占位符。
 `{{ GLOBALS }}` 会被替换成需要的 uniform / varyings 定义（比如相机矩阵、splat 数据采样函数）。
`{{ STATEMENTS }}` 会被替换成排序逻辑，比如：
 从 `PackedSplats` 取中心点
转到相机空间   
计算 Z-depth 或 radial distance
 打包成 RGBA
 
4. 核心索引计算
```glsl
int targetIndex =
    int(targetLayer << SPLAT_TEX_LAYER_BITS) +
    int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) +
    int(gl_FragCoord.x);
int index = targetIndex - targetBase;

```
FBO 被当作一个“splat 属性表”，每个像素代表一个 splat。
`gl_FragCoord.x / y` 给出当前 fragment 的像素坐标。
再结合 `targetLayer`（用于多层数据分批）计算全局 splat ID。

5. 条件处理
```glsl
if ((index >= 0) && (index < targetCount)) {
    produceSplat(index);
} else {
    target = uvec4(0u, 0u, 0u, 0u);
}
```
如果当前像素对应的 splat 在处理范围内 → 调 `produceSplat(index)` 生成 metric
否则 → 输出 0（无效）

## 数据流总结

1.  **SparkViewpoint.sortUpdate** 调用 `reader.renderReadback`
2.  WebGL 渲染管线运行这个 shader
3.  每个 fragment 负责一个 splat，调用 `produceSplat` 算 metric（深度/距离）
4.  metric 打包成 `uvec4`，写入 `target`（颜色输出）
5.  颜色缓冲存在 FBO
6.  `gl.readPixels` 把这些值回读到 CPU
7.  CPU 用桶排序（`sortSplats`）生成绘制顺序

----------

所以，**它是排序流程的一部分**，  
更准确地说，它是 **GPU 端的 metric 计算阶段**，  
排序本身（对这些 metric 的排序）是在 CPU/Web Worker 里完成的。

# GPU 读取 + Readback
## 1. 流程概述（GPU → CPU）

Spark 的排序流程是这样的：
```
PackedSplats（GPU存储点数据）
   ↓
GPU Shader (computeVec4.glsl)
   ↓ FBO（WebGLArrayRenderTarget）
   ↓
gl.readPixels / readRenderTargetPixelsAsync
   ↓
CPU 解码（半精度/单精度深度值）
   ↓
CPU 桶排序（sortSplats）

```

## 2. Readback.ts 的关键 API

### （1）`ensureCapacity(capacity)`

-   确保有一个足够大的 **FBO**（`WebGLArrayRenderTarget`）来容纳要渲染的 splat metric 数据。
    
-   格式固定为 **RGBA8**（WebGL2 中跨平台可读的唯一颜色格式）。
    
-   宽度、高度、depth 都由 `getTextureSize` 计算。
    

### （2）`prepareProgramMaterial(reader)`

-   生成一个基于 `computeVec4.glsl` 的 shader 程序（`DynoProgram`），用来计算每个 splat 的 metric（比如深度）。
    
-   输出目标是 `out uvec4 target`，实际写到 FBO 的 RGBA8。
    

### （3）`process({ count, material })`

-   使用 `FullScreenQuad` 把 shader 渲染到 FBO。
    
-   每个 fragment 对应一个 splat，调用 `produceSplat(index)` 计算 metric。
    
-   用 `targetLayer`、`targetBase` 等 uniform 分批渲染，避免一次性超大数据。
    

### （4）`read({ readback })`

-   用 `renderer.readRenderTargetPixelsAsync` 从 FBO 的颜色附件中读回 **Uint8Array**。
    
-   按行按 layer 读取，组装成连续的缓冲。
    

### （5）`renderReadback({ reader, count, readback })`

-   组合 `process` + `read`，一次完成渲染和读取。
    
-   排序流程中就是用这个方法：  
    先在 GPU 生成深度 → 再读回 CPU。
# 为什么用gpu
## 用 Spark 的排序流程举例

假设你要计算 1,000,000 个 splat 的深度：

-   **CPU做法**：

```	cpp
for (let i = 0; i < 1_000_000; i++) {
    depth[i] = calcDepth(position[i]);
}
```
-   这是一个循环，顺序执行，要 1,000,000 次迭代。
    
-   **GPU做法**（FBO + fragment shader）：
    
    -   创建一个 1000×1000 像素的 FBO，每个像素对应一个 splat
        
    -   GPU 一次 draw call 启动 1,000,000 个 fragment 线程
        
    -   每个线程在自己的 `main()` 里跑一次 `produceSplat(index)`
        
    -   全部线程几乎同时完成
        

这样 GPU 就能在一个渲染调用里完成所有 splat 的深度计算，这就是“高度并行”。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTcxMzEwNjQ5MywxNzY2MzI3NjcyLC0xMj
YxNTA2NDU2LDIwNzg0Njc5NDEsMTM3NTU5NzYyNiwyMzI4Mjc0
NjMsOTE3NzU0Mjg5LC0xNTc2MTc4MDA1LDE5OTgwNDUwMjJdfQ
==
-->