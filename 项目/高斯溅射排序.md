## 高斯溅射渲染中深度图的作用

### 1. **为什么要先渲染深度？**

-   **深度图是记录每个屏幕像素距离摄像机最近的物体深度。**
    
-   在传统渲染中，深度图用于“深度测试”，确保后面渲染的像素不会覆盖前面更近的像素，避免远处物体覆盖近处物体。
    
-   对于高斯溅射（一个由大量带有体积和颜色的高斯体组成的点云），渲染顺序非常重要，因为颜色需要叠加，而且高斯体可能相互重叠。
    

----------

### 2. **先渲染深度图步骤**

-   用**简化的shader（只写深度，不写颜色）**，渲染所有高斯体，GPU会写入深度缓冲区（Depth Buffer），生成深度图。
    
-   这一步快速算出每个屏幕像素上的“最前面那个高斯体的深度”。
    

----------

### 3. **为什么不能只靠高斯体本身的中心深度排序？**

-   高斯体不是点，而是有空间扩散的体积。
    
-   中心点深度只是它的一个单点距离，不能准确反映高斯体在屏幕上的投影深度范围。
    
-   有些高斯体中心远，但投影在屏幕上可能覆盖或遮挡更近的高斯体边缘，导致渲染错乱。
    

----------

### 4. **利用深度图辅助排序**

-   生成深度图后，可以用它来辅助判断每个高斯体实际在屏幕上的遮挡情况。
    
-   具体做法：
    
    -   取某个高斯体在屏幕上的投影区域。
        
    -   从深度图采样该区域的深度值（其实是对应“最前面高斯体”的深度）。
        
    -   将采样到的深度和该高斯体自身深度对比，判断该高斯体是否被遮挡，计算排序指标（metric）。
        
-   这样可以得到比单中心深度更准确的排序结果，保证颜色叠加的正确顺序。
    

----------

### 5. **之后才正式渲染颜色**

-   用这个排序结果，从**最远**的高斯体开始渲染，逐渐叠加到最近的。
    
-   这样颜色才不会错乱，视觉效果正确。

# 排序

`vertexShader`中有一个`splatIndex`，`splatIndex` 用来控制渲染顺序的“排序索引”，它不是原始数据的复制，而是指向原始高斯体数据的索引。

### 具体来说：

-   你的原始高斯体数据，比如位置、颜色、旋转等，存储在一个纹理或缓冲区里，索引是固定的。
    
-   CPU端做排序时，不会动这些数据本身，而是生成一个新的数组，这个数组里面存的就是**原始数据的索引**，但按正确的渲染顺序排列。
    
-   GPU在绘制时，拿到这个排序后的索引(`splatIndex`)，然后用它去采样原始高斯体数据（纹理fetch等）。
    
-   这样就能保证绘制时，高斯体是按照你计算的顺序一个一个正确叠加渲染的。
    

----------

### 为什么不用直接移动原始数据？

-   原始数据可能很大，拷贝和移动代价高。
    
-   只操作索引，轻量高效。
    
-   GPU绘制支持索引缓冲（index buffer）或顶点属性，直接使用索引即可。
----------

总结：  
**排序的是“索引”，而不是数据本身。** 这样既节省性能，也方便管理。你现有的shader中`splatIndex`就是接收这个排序结果的索引变量。


## 排序实现
`splatGeometry.ts`这个代码，就是排序的关键接口之一，负责把 **排序好的索引数组** 传给 GPU，控制实例绘制的顺序。

### 详细解释：

-   构造函数里：
    
```
this.attribute = new THREE.InstancedBufferAttribute(ordering, 1, false, 1); 
this.setAttribute("splatIndex", this.attribute);
```
这里 `ordering` 就是排序好的索引数组，作为实例属性绑定到顶点着色器的 `splatIndex` 输入。
    
-   GPU绘制时，每个实例（即每个高斯溅射体）都会拿到对应的 `splatIndex`，然后用它去采样纹理或buffer里的原始高斯体数据。
    
-   `update` 方法可以动态更新排序后的索引数组，比如你每帧CPU重新排序后，调用 `update` 让GPU拿到新的顺序。
    
-   `instanceCount` 控制当前激活渲染的实例数量。


`splatViewPoint.ts`的`sortUpdate`方法，就是用来更新排序
真正实现排序的代码在`work.ts`中，有很多个`sort`函数，例如`sortSplat`
### `sortSplat`函数的作用和思路总结：

-   输入参数：
    
    -   `totalSplats`: 高斯体总数。
        
    -   `readback`: GPU 渲染后读取回来的深度数据数组（Uint8Array 分层存储）。
        
    -   `ordering`: 一个 Uint32Array，用来存放排序后的高斯体索引。
        
-   **核心原理**：
    
    这段代码使用了一种基于 **计数排序（counting sort）** 的思想，因为深度被编码为16位半精度浮点数（float16），可以先对深度值做分桶计数。
    
-   **步骤：**
    
    1.  初始化 `depthArray16`，它是一个长度为 DEPTH_SIZE_16（应该是 32768，16位半精度范围）的计数数组。
        
    2.  遍历所有深度数据，统计每个深度值出现的次数，存入 `depthArray16`。
        
    3.  通过累加计数，计算每个深度值在排序数组中的起始位置。
        
    4.  再次遍历所有深度，根据深度值在 `depthArray16` 记录的起始位置，将对应 splat 的索引写入 `ordering`。
        
    5.  返回有效（激活）的 splats 数量和排序后的索引数组。

# GPU端代码实现
`computeVec4.glsl`**为排序生成数据**。
它的作用是：

-   **根据 fragment 坐标 (`gl_FragCoord`) 确定当前要处理的 splat 索引**
    
-   **调用 `produceSplat(index)` 计算该 splat 的排序 metric（深度/距离）**
    
-   **把这个 metric 打包成 `uvec4` 写入颜色输出 `target`**（最终会进 FBO，被 CPU 读回）

1. 高精度声明
```glsl
precision highp float;
precision highp int;
precision highp sampler2D;
...
```
确保计算排序 metric 时有足够精度（尤其是深度）。
2. 排序目标控制
```glsl
uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;
out uvec4 target;
```
`targetLayer` / `targetBase` / `targetCount` 用来确定当前批次要处理的 splats 范围。
`target` 是输出的颜色数据（RGBA → uvec4），会被 `gl.readPixels` 读回。

3. GLSL 模板占位符

```glsl
{{ GLOBALS }} {{ STATEMENTS }}
```

这里是动态生成 shader 的占位符。
 `{{ GLOBALS }}` 会被替换成需要的 uniform / varyings 定义（比如相机矩阵、splat 数据采样函数）。
`{{ STATEMENTS }}` 会被替换成排序逻辑，比如：
 从 `PackedSplats` 取中心点
转到相机空间   
计算 Z-depth 或 radial distance
 打包成 RGBA
 
4. 核心索引计算
```glsl
int targetIndex =
    int(targetLayer << SPLAT_TEX_LAYER_BITS) +
    int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) +
    int(gl_FragCoord.x);
int index = targetIndex - targetBase;

```
FBO 被当作一个“splat 属性表”，每个像素代表一个 splat。
`gl_FragCoord.x / y` 给出当前 fragment 的像素坐标。
再结合 `targetLayer`（用于多层数据分批）计算全局 splat ID。

5. 条件处理
```glsl
if ((index >= 0) && (index < targetCount)) {
    produceSplat(index);
} else {
    target = uvec4(0u, 0u, 0u, 0u);
}
```
如果当前像素对应的 splat 在处理范围内 → 调 `produceSplat(index)` 生成 metric
否则 → 输出 0（无效）

## 数据流总结

1.  **SparkViewpoint.sortUpdate** 调用 `reader.renderReadback`
2.  WebGL 渲染管线运行这个 shader
3.  每个 fragment 负责一个 splat，调用 `produceSplat` 算 metric（深度/距离）
4.  metric 打包成 `uvec4`，写入 `target`（颜色输出）
5.  颜色缓冲存在 FBO
6.  `gl.readPixels` 把这些值回读到 CPU
7.  CPU 用桶排序（`sortSplats`）生成绘制顺序

----------

所以，**它是排序流程的一部分**，  
更准确地说，它是 **GPU 端的 metric 计算阶段**，  
排序本身（对这些 metric 的排序）是在 CPU/Web Worker 里完成的。

# GPU 读取 + Readback
## 1. 流程概述（GPU → CPU）

Spark 的排序流程是这样的：
```
PackedSplats（GPU存储点数据）
   ↓
GPU Shader (computeVec4.glsl)
   ↓ FBO（WebGLArrayRenderTarget）
   ↓
gl.readPixels / readRenderTargetPixelsAsync
   ↓
CPU 解码（半精度/单精度深度值）
   ↓
CPU 桶排序（sortSplats）

```

## 2. Readback.ts 的关键 API

### （1）`ensureCapacity(capacity)`

-   确保有一个足够大的 **FBO**（`WebGLArrayRenderTarget`）来容纳要渲染的 splat metric 数据。
    
-   格式固定为 **RGBA8**（WebGL2 中跨平台可读的唯一颜色格式）。
    
-   宽度、高度、depth 都由 `getTextureSize` 计算。
    

### （2）`prepareProgramMaterial(reader)`

-   生成一个基于 `computeVec4.glsl` 的 shader 程序（`DynoProgram`），用来计算每个 splat 的 metric（比如深度）。
    
-   输出目标是 `out uvec4 target`，实际写到 FBO 的 RGBA8。
    

### （3）`process({ count, material })`

-   使用 `FullScreenQuad` 把 shader 渲染到 FBO。
    
-   每个 fragment 对应一个 splat，调用 `produceSplat(index)` 计算 metric。
    
-   用 `targetLayer`、`targetBase` 等 uniform 分批渲染，避免一次性超大数据。
    

### （4）`read({ readback })`

-   用 `renderer.readRenderTargetPixelsAsync` 从 FBO 的颜色附件中读回 **Uint8Array**。
    
-   按行按 layer 读取，组装成连续的缓冲。
    

### （5）`renderReadback({ reader, count, readback })`

-   组合 `process` + `read`，一次完成渲染和读取。
    
-   排序流程中就是用这个方法：  
    先在 GPU 生成深度 → 再读回 CPU。
# 为什么
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTMxNDgzNzU0MywtMTI2MTUwNjQ1NiwyMD
c4NDY3OTQxLDEzNzU1OTc2MjYsMjMyODI3NDYzLDkxNzc1NDI4
OSwtMTU3NjE3ODAwNSwxOTk4MDQ1MDIyXX0=
-->