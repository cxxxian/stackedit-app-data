这样是对的吗
```cpp
char* a = "abcde";
char b = "abcdef";
std::memcpy(a, b, 5);
```
其实是不对的，因为
`char* a = "abcde";`
`"abcde"` 是一个 **字符串常量**（存放在只读存储区，通常是 `.rodata` 段）。
在现代 C++ 中，`"abcde"` 的类型是 `const char[6]`，会退化成 `const char*`。
所以严格来说，应该写成：
 `const char* a = "abcde";`
你写成 `char* a` 在 C++11 之后其实会报 **警告/错误**，因为你试图把 `const char*` 转成 `char*`。
如果强行编译通过，`a` 指向的区域是只读的，对它写会导致 **未定义行为（通常是段错误 segfault）**。

如果要实现以上的效果
需要这样声明`a`
```cpp
char* a = new char[6];  // 可写
```

# c++生命周期问题
c++不同变量的作用域和生命周期，大概了解哪一些，
new出来的生命周期的变量是怎么样的，
new出来的变量没有手动释放会怎么样

## 一、作用域（Scope）
作用域决定**变量能被访问的范围**，一般分为：
### 1. 局部作用域（Local Scope）
-   定义在函数或语句块 `{}` 中的变量。
-   进入 `{}` 时创建，离开 `{}` 时销毁。
```cpp
void foo() {
    int a = 10; // 局部变量
} // 离开函数，a 被销毁
```
### 2. 全局作用域（Global Scope）
-   定义在所有函数外部的变量。
-   程序启动时创建，程序结束时销毁。
```cpp
int g = 5; // 全局变量
int main() { g++; }
```
### 3. 静态作用域（Static Scope）
-   用 `static` 修饰的变量，即使定义在函数内，也会**在整个程序期间都存在**，但**只在定义的作用域内可见**。
```cpp
void foo() {
    static int counter = 0; // 只会初始化一次
    counter++;
}
```
### 4. 类作用域（Class Scope）
-   类的成员变量、函数的作用域。
```cpp
class MyClass {
    int x; // 类成员作用域
};
```

![输入图片说明](/imgs/2025-11-02/lgqlQYMMSQupPcAi.png)

## 三、`new` 出来的变量

当你写：
```cpp
int* p = new int(5);
```
它的行为是：
-   `new` 从**堆内存**中分配空间；
-   调用类型的**构造函数**（如果有）；
-   返回一个**指向该内存的指针**。
所以：
-   `p` 是一个局部变量（存在栈上）；
-   `*p` 指向的对象存在堆上；
-   这个堆上对象的生命周期**不会随着作用域结束而自动释放**。

## 四、如果 `new` 出来的变量没有手动释放会怎样？
```cpp
void foo() {
    int* p = new int(10);
} // 函数结束，但没有 delete
```
结果：
-   `p`（指针）离开作用域被销毁；
-   但堆上的那块内存（`new int(10)`）**仍然存在**；
-   导致 **内存泄漏（memory leak）**。

内存泄漏的危害：
-   程序长期运行会越来越占内存；
-   资源无法回收；
-   在嵌入式或游戏引擎中可能导致崩溃。
- 
## 五、正确做法

要用 `delete` 手动释放：
```cpp
int* p = new int(5); 
delete p; p = nullptr; // 防止悬空指针
```

数组要用 `delete[]`：
```cpp
int* arr = new int[10]; 
delete[] arr;
```
## 六、现代 C++ 推荐做法：智能指针

不建议手动 `new` 和 `delete`，容易出错。  
建议使用 **智能指针**：
```cpp
#include <memory> 
void foo() {     
	auto p = std::make_unique<int>(5);   // 自动释放     
	auto q = std::make_shared<int>(10);  // 引用计数释放 
} // 离开作用域自动析构，安全无泄漏
```

# dynamic cast失败了话会怎么样
## 一、`dynamic_cast` 的作用

`dynamic_cast` 是 **运行时安全类型转换**（RTTI 的一部分），  
主要用于**在继承层次中，将基类指针/引用转换为派生类类型（下行转换）**。

----------

## 二、使用前提

-   类必须是 **多态类型**（即至少有一个虚函数），否则编译报错。
```cpp
struct Base { virtual ~Base() {} }; // ✅ 多态类型
```

## 三、运行机制
当执行 `dynamic_cast<T*>(ptr)` 时，运行时会：
1.  通过对象的虚表指针（`vptr`）找到类型信息（RTTI）；
2.  检查对象的**实际类型**是否是 `T` 或其子类；
3.  如果匹配，返回转换后的有效指针；
4.  如果不匹配，返回 `nullptr`。

![输入图片说明](/imgs/2025-11-02/Zt9tK6s6Fx5sud7E.png)

## 五、为什么会失败？

因为：
> `dynamic_cast` 会检查“对象的真实类型”。  
> `Base* b = new Base();` 时，对象的真实类型就是 `Base`，不是 `Derived`，  
> 所以无法把它“安全地”变成 `Derived*`。

## 六、指针 vs 引用 的区别

![输入图片说明](/imgs/2025-11-02/yWLuWUzf4zeePxCi.png)

#### 成功的情况
如果引用确实引用的是派生类对象：
```cpp
Derived d; 
Base& b_ref = d; // Base 引用指向 Derived 
Derived& d_ref = dynamic_cast<Derived&>(b_ref); // ✅ 成功
```
这时不会抛异常，因为 `b_ref` 的实际类型就是 `Derived`。

## 七、用途总结

-   ✅ **安全的下行转换**（基类 → 派生类）
-   ✅ **类型识别**（通过 `if (dynamic_cast<Derived*>(b))` 判断类型）
-   ❌ 不适用于非多态类（没有虚函数）

![输入图片说明](/imgs/2025-11-02/1G1y4sKAvJL94Hcp.png)

# 右值引用
## 右值引用（`T&&`）总结

### 定义与语法

-   右值引用是 C++11 引入的引用类型，用 `&&` 表示：
```cpp
int&& r = 5;  // 绑定临时对象 5
```
-   只能绑定 **右值**（临时对象、字面量、表达式结果），不能直接绑定左值。

### 右值引用的核心概念

-   **右值** = 临时对象或表达式结果 → 生命周期短 → “即将消亡”
例如`int r = 5`，5就是即将消亡的对象，运行完这句话就会消亡
-   **右值引用**允许：
    1.  **修改临时对象**（安全，因为没人再使用它）
    2.  **移动资源**（如指针、缓冲区），避免深拷贝，提高性能

### 主要用途

1.  **移动语义（Move Semantics）**
    
    -   避免拷贝大对象，直接转移内部资源
        
    -   例：
```cpp
std::vector<int> v1 = {1,2,3}; 
std::vector<int> v2 = std::move(v1); // v1 的内部数组指针转移给 v2
```
    
2.  **完美转发（Perfect Forwarding）**
    
    -   模板中保持传入参数的左值/右值属性
    -   例：
```cpp
template<typename T> void wrapper(T&& arg) {     
	process(std::forward<T>(arg)); // 保留原值类别 
}
```    
3.  **减少不必要拷贝**
    
    -   函数返回临时对象或表达式结果 → 直接移动而非复制
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTczODM0MDEzNiwxOTMxMzU5NzMyXX0=
-->