## 首先：什么是浮点数（float）？

你平常用的数字，比如 `3.1415`、`0.1`、`1000000.0` 这些带小数的数字，在计算机里要用**浮点数格式**来存。

“浮点数”的意思就是：

> 这个数字的 **小数点位置是浮动的**，它可以很大很大（比如 10 亿），也可以很小很小（比如 0.0000001），用一个统一的方式来表示它们。

## 浮点数是怎么存的？

在内存里，浮点数不是直接存“3.14”，而是把它拆成三块信息存：


符号位：记录正还是负
指数部分：表示这个数是 10 的几次方
尾数部分：表示这个数的具体数字形状

可以类比成科学记数法：
```
3.14 × 10^2  → 拆成：正号 + 指数 2 + 尾数 3.14
```

## 什么是 float16、float32、float64？

这些名字表示的是“**浮点数的大小和精度**”。
名称

`float16`：16 位，别名half
`float32`：32 位，别名float
`float64`：64 位，别名double

你可以简单理解为：

> float16 是“轻量级”小数字（用于图像处理）  
> float32 是“常用”的 float  
> float64 是“更精确”的 float，也叫 double（双精度）

## 为什么 float 会有“精度问题”？

因为浮点数的尾数部分是**固定位数的二进制小数**，而有些十进制小数不能用有限的二进制表示。

比如：

-   十进制的 `0.1` 在二进制中是个无限循环小数，像 `0.0001100110011...`；
    
-   但 float 只能保留前面 23 位（float32），所以会**截断**、**舍入**，变成一个近似值；
    
-   最终导致你以为 `0.1 + 0.2 == 0.3`，但实际是 **不完全等于的**！

## 举个现实例子

假如你有一个只能装 7 位数字的电子秤（float）：

-   放上 1234567 → 精确
-   放上 12345678 → 超出了，就会变成 12345680（尾数被截断）

而 double 是一台 16 位秤，就能装下更多数字，不容易失真。

## 为什么float16精度随数值变大而降低

简单来说，float16精度随数值变大而降低，是因为浮点数的表示方式决定的：

-   浮点数由“指数”和“尾数”组成，尾数位数固定（float16只有10位尾数），所以能表示的有效数字有限；
    
-   当数值变大，指数增加，浮点数的范围变大，但尾数位数不变，导致相邻两个可表示数之间的间隔（最小可分辨差值）变大；
    
-   因此，数值大时，相邻数之间的差距变宽，精度“颗粒”变粗，细节丢失，表现为精度降低。
    

你可以想象，float16就像一把尺子，尺子刻度是固定的，数值越大，每格代表的实际长度越长，所以分辨能力变差。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQwNjI1NzU5NCwtMjM2NzU2NDE1LC0yMD
g4NzQ2NjEyXX0=
-->