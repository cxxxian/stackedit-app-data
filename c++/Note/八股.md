**1.内存分区有哪些? 堆栈有哪些区别？**

C++ 程序在运行时也会按照不同的功能划分不同的段，C++程序使用的内存分区一般包括：栈、堆、全局/静态存储区、常量存储区、代码区。

**栈**：目前绝大部分 CPU 体系都是基于栈来运行程序，栈中主要存放函数的局部变量、函数参数、返回地址等，栈空间一般由操作系统进行默认分配或者程序指定分配，栈空间在进程生存周期一直都存在，当进程退出时，操作系统才会对栈空间进行回收。

**堆**：动态申请的内存空间，就是由 malloc 函数或者 new 函数分配的内存块，由程序控制它的分配和释放，可以在程序运行周期内随时进行申请和释放，如果进程结束后还没有释放，操作系统会自动回收。

**全局区/静态存储区**：存放全局变量和静态变量，程序运行结束操作系统自动释放。

**常量存储区**：存放的是常量，不允许修改，程序运行结束自动释放。

**代码区**：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。




# 形象解释：虚函数表与多态
我们可以用 菜单点餐 的比喻来理解虚函数表和动态多态的过程。假设你走进一家餐厅，餐厅提供不同套餐（基类和派生类），每个套餐的菜品（函数实现）可能不同，但菜名（函数名）是统一的。服务员（基类指针）会根据你实际点的套餐（对象类型），通过菜单目录（虚函数表）找到正确的菜品（函数实现）。

1. 虚函数表（vtable）—— 菜单目录
基类菜单：基类定义一套标准菜名（虚函数），例如：
```cpp
class 套餐 {
public:
    virtual void 主食() = 0;  // 抽象虚函数
    virtual void 甜点() = 0;
};
```
编译器为基类生成一张 菜单目录（虚函数表），记录每个菜名对应的做法（函数地址），但此时菜品未实现（抽象类）。

派生类菜单：具体套餐（如牛肉套餐、素食套餐）继承基类，并实现所有菜品：

```cpp
class 牛肉套餐 : public 套餐 {
public:
    void 主食() override { cout << "牛排\n"; }  // 具体实现
    void 甜点() override { cout << "冰淇淋\n"; }
};
```
编译器为派生类生成新的 菜单目录，记录 牛肉套餐::主食() 和 牛肉套餐::甜点() 的地址。

2. 虚函数指针（vptr）—— 桌牌号
每个餐桌（对象） 都有一个 桌牌号（vptr），指向该桌客人点的套餐对应的菜单目录。
客人坐下（对象构造） 时，服务员（构造函数）根据客人点的套餐（对象类型），将桌牌号指向对应的菜单目录。
```cpp
牛肉套餐* 我的套餐 = new 牛肉套餐();  
// 构造时，桌牌号（vptr）指向牛肉套餐的菜单目录
```
3. 多态调用——服务员按桌牌号上菜
当服务员（基类指针）需要为你上菜（调用虚函数）时：
```cpp
套餐* 服务员 = new 牛肉套餐();  // 服务员只知道这是“套餐”，但不知道具体类型
服务员->主食();  // 动态绑定：查看桌牌号→找到牛肉套餐的菜单→执行“牛排”
```
步骤详解：
服务员（基类指针）看到桌牌号（vptr）指向 牛肉套餐的菜单目录。
查找菜单目录中 主食() 的位置（如第0项），找到对应的做法（牛肉套餐::主食() 地址）。
按此做法上菜：端上牛排。
如果桌牌号指向的是 素食套餐的菜单目录，则会执行 素食套餐::主食()，端上沙拉。

4. 动态绑定的本质——运行时查表
编译阶段：只确定“菜名”（函数名）和菜单目录的位置（虚函数表结构）。
运行阶段：根据桌牌号（vptr）动态查找当前对象的菜单目录（vtable），找到实际菜品（函数实现）。
5. 错误场景——没有虚函数表
如果菜品（函数）不是虚函数：

```cpp
class 套餐 {
public:
    void 饮料() { cout << "白开水\n"; }  // 非虚函数
};
class 牛肉套餐 : public 套餐 {
public:
    void 饮料() { cout << "红酒\n"; }     // 隐藏基类实现
};
套餐* 服务员 = new 牛肉套餐();
服务员->饮料();  // 输出“白开水”（静态绑定，按基类类型调用）
```
服务员直接按基类菜单目录操作，无视实际套餐类型。

总结
虚函数表（vtable） 是每个类的 专属菜单目录，记录该类的所有虚函数实现。
虚函数指针（vptr） 是对象的 桌牌号，构造函数根据对象类型指向正确的菜单。
多态调用 就像服务员根据桌牌号动态查表，保证“上对菜”（执行正确的派生类函数）。
这种机制让 C++ 在运行时灵活选择行为，是面向对象中 “一个接口，多种实现” 的核心支撑。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTczNTc3NTUzNCwyMjYyNzc1NTJdfQ==
-->