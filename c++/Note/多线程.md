## C++ å¤šçº¿ç¨‹çš„åŸºæœ¬ç”¨æ³•ï¼š`std::thread`

ä» C++11 å¼€å§‹ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ `std::thread` åˆ›å»ºæ–°çº¿ç¨‹ã€‚

### ç¤ºä¾‹ï¼šåˆ›å»ºä¸€ä¸ªçº¿ç¨‹æ‰“å°æ•°å­—

```cpp
#include <iostream>
#include <thread>  
void printNumbers() {     
	for (int i = 1; i <= 5; ++i) {         
		std::cout << "å­çº¿ç¨‹è¾“å‡º: " << i << std::endl;     
	} 
}  
int main() {     
	std::thread t(printNumbers);// å¯åŠ¨æ–°çº¿ç¨‹æ‰§è¡Œ printNumbers     			
	t.join();// ç­‰å¾…çº¿ç¨‹æ‰§è¡Œå®Œæˆ     
	std::cout << "ä¸»çº¿ç¨‹ç»“æŸ" << std::endl;     
	return 0; 
}
```

### è¿è¡Œç»“æœï¼š

```makefile
å­çº¿ç¨‹è¾“å‡º: 1 
å­çº¿ç¨‹è¾“å‡º: 2
... 
ä¸»çº¿ç¨‹ç»“æŸ
```
## å¤šçº¿ç¨‹é™·é˜±ï¼š**å…±äº«æ•°æ®å’Œç«äº‰é—®é¢˜**

ä¸¤ä¸ªçº¿ç¨‹å¦‚æœåŒæ—¶è®¿é—®åŒä¸€ä»½æ•°æ®ï¼Œå°±å¯èƒ½å‡ºé”™ã€‚

### ç¤ºä¾‹ï¼ˆé”™è¯¯ç¤ºèŒƒï¼‰ï¼š

```cpp
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) counter++;// âŒ ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶ä¿®æ”¹å¯èƒ½å¯¼è‡´é”™è¯¯ 
}
```

### âœ… æ­£ç¡®å†™æ³•ï¼šåŠ é”ä¿æŠ¤å…±äº«å˜é‡

```cpp
#include <mutex>  
std::mutex mtx; 
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) {         		
		std::lock_guard<std::mutex> lock(mtx);         		
		counter++;     
	} 
}
```

> ğŸ”’ `std::mutex` å¯ä»¥ä¿æŠ¤ä¸€æ®µä»£ç åªè®©ä¸€ä¸ªçº¿ç¨‹è¿›å…¥ï¼Œé¿å…â€œæ•°æ®ç«äº‰â€ã€‚

## å¸¸ç”¨æ¦‚å¿µ

`std::thread`ï¼šå¯åŠ¨ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œå‡½æ•°
`.join()`ï¼šé˜»å¡ä¸»çº¿ç¨‹ï¼Œç­‰å­çº¿ç¨‹è·‘å®Œ
`.detach()`ï¼šåˆ†ç¦»çº¿ç¨‹ï¼Œä¸ç­‰å¾…å®ƒæ‰§è¡Œå®Œï¼ˆè°¨æ…ä½¿ç”¨ï¼‰


# ä¸é¡¹ç›®ç»“åˆï¼ˆå¼‚æ­¥åŠ è½½è´´å›¾ï¼‰
è¿™æ˜¯ä¸€æ®µæ™®é€šçš„åŠ è½½è´´å›¾æ–¹æ³•
```cpp
Texture::Texture(const std::string& path, unsigned int unit, unsigned int internalFormat) {
	mUnit = unit;

	//1 stbImage è¯»å–å›¾ç‰‡
	int channels;

	//--åè½¬yè½´
	stbi_set_flip_vertically_on_load(true);

	unsigned char* data = stbi_load(path.c_str(), &mWidth, &mHeight, &channels, STBI_rgb_alpha);

	//2 ç”Ÿæˆçº¹ç†å¹¶ä¸”æ¿€æ´»å•å…ƒç»‘å®š
	glGenTextures(1, &mTexture);
	//--æ¿€æ´»çº¹ç†å•å…ƒ--
	glActiveTexture(GL_TEXTURE0 + mUnit);
	//--ç»‘å®šçº¹ç†å¯¹è±¡--	
	glBindTexture(GL_TEXTURE_2D, mTexture);

	//3 ä¼ è¾“çº¹ç†æ•°æ®,å¼€è¾Ÿæ˜¾å­˜
	glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

	
//	glGenerateMipmap(GL_TEXTURE_2D);

	//***é‡Šæ”¾æ•°æ® 
	stbi_image_free(data);

	//4 è®¾ç½®çº¹ç†çš„è¿‡æ»¤æ–¹å¼
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);

	//5 è®¾ç½®çº¹ç†çš„åŒ…è£¹æ–¹å¼
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);//u
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);//v
}
```
### åŒºåˆ†**å“ªäº›éƒ¨åˆ†å¯ä»¥åœ¨åå°çº¿ç¨‹åšï¼Œå“ªäº›å¿…é¡»ä¸»çº¿ç¨‹åš**ï¼š
1. `stbi_load` å›¾åƒè§£ç 
âœ… å¯ä»¥
çº¯ CPU æ“ä½œï¼Œä¸ OpenGL æ— å…³

2. `glGenTextures` ç­‰ GL API
âŒ ä¸è¡Œï¼ˆé»˜è®¤ï¼‰
OpenGL ä¸Šä¸‹æ–‡åªç»‘å®šåœ¨ä¸»çº¿ç¨‹ä¸Š

3. `glTexImage2D` ä¸Šä¼  GPU
âŒ ä¸è¡Œï¼ˆåŒä¸Šï¼‰
GPU æ“ä½œå¿…é¡»ä¸»çº¿ç¨‹å®Œæˆ

4. `stbi_image_free`
âœ… å¯ä»¥
çº¯å†…å­˜é‡Šæ”¾ï¼Œéå›¾å½¢ API

æ‰€ä»¥ä»£ç é‡Œï¼Œ**åªæœ‰ `stbi_load(path)` è¿™ä¸€æ­¥å¯ä»¥æ”¾åˆ°åå°çº¿ç¨‹åš**ã€‚

**å¤šçº¿ç¨‹ç‰ˆæœ¬**ï¼š  
ä½ åªæƒ³è®©**`stbi_load` åœ¨åå°çº¿ç¨‹æ‰§è¡Œ**ï¼Œç„¶åä¸»çº¿ç¨‹å†è°ƒç”¨åŸæ¥çš„ `Texture` æ„é€ å‡½æ•°å®Œæˆä¸Šä¼ å³å¯ã€‚

----------

## æ”¹åŠ¨ç›®æ ‡ï¼š

åŸæ¥çš„ç»“æ„ï¼š

```cpp
Texture tex("brick.jpg", 0, GL_RGBA); // åŒæ­¥åŠ è½½å¹¶ä¸Šä¼ 
```

æˆ‘ä»¬è¦å˜æˆï¼š

```cpp
// åˆå§‹åŒ–é˜¶æ®µï¼ˆåªæ‰§è¡Œä¸€æ¬¡ï¼‰
Texture::loadAsync("brick.jpg", 0, GL_RGBA);

// ä¸»å¾ªç¯ä¸­æ¯å¸§æ£€æŸ¥
if (Texture::hasLoaded()) {
    std::vector<unsigned char> pixels;
    int w, h;
    Texture::getLoadedData(pixels, w, h);
    Texture tex(pixels, w, h, 0, GL_RGBA); // æ„é€ å¹¶ä¸Šä¼ 
}

```	

`texture.h`å¦‚ä¸‹ï¼š
```cpp
#pragma once
#include <string>
#include <vector>
#include <mutex>
#include <thread>
#include <atomic>

class Texture {
public:
    Texture(const std::vector<unsigned char>& pixels, int width, int height,
            unsigned int unit, unsigned int internalFormat);

    static void loadAsync(const std::string& path, unsigned int unit, unsigned int internalFormat);
    static bool hasLoaded();
    static void getLoadedData(std::vector<unsigned char>& pixels, int& w, int& h);

private:
    unsigned int mTexture = 0;
    unsigned int mUnit = 0;
    int mWidth = 0;
    int mHeight = 0;

    static std::vector<unsigned char> sPixels;
    static int sWidth, sHeight;
    static std::mutex sMutex;
    static std::atomic<bool> sReady;
};
```
`Texture.cpp`å¦‚ä¸‹ï¼š
```cpp
#define STB_IMAGE_IMPLEMENTATION
#include "Texture.h"
#include <glad/glad.h>
#include <stb_image.h>

std::vector<unsigned char> Texture::sPixels;
int Texture::sWidth = 0;
int Texture::sHeight = 0;
std::mutex Texture::sMutex;
std::atomic<bool> Texture::sReady = false;

Texture::Texture(const std::vector<unsigned char>& pixels, int width, int height,
                 unsigned int unit, unsigned int internalFormat) {
    mUnit = unit;
    mWidth = width;
    mHeight = height;

    glGenTextures(1, &mTexture);
    glActiveTexture(GL_TEXTURE0 + mUnit);
    glBindTexture(GL_TEXTURE_2D, mTexture);

    glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels.data());

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
}

void Texture::loadAsync(const std::string& path, unsigned int unit, unsigned int internalFormat) {
	//lambdaè¡¨è¾¾å¼
    std::thread([path]() {
        int w, h, channels;
        stbi_set_flip_vertically_on_load(true);
        unsigned char* data = stbi_load(path.c_str(), &w, &h, &channels, STBI_rgb_alpha);
        if (!data) return;

        std::lock_guard<std::mutex> lock(sMutex);
        sWidth = w;
        sHeight = h;
        sPixels.assign(data, data + w * h * 4);
        stbi_image_free(data);
        sReady = true;
    }).detach();
}

bool Texture::hasLoaded() {
    return sReady.load();
}

void Texture::getLoadedData(std::vector<unsigned char>& pixels, int& w, int& h) {
    std::lock_guard<std::mutex> lock(sMutex);
    pixels = sPixels;
    w = sWidth;
    h = sHeight;
    sReady = false;
}

```
è§£é‡Šä¸€ä¸‹ï¼š
`loadAsync`æ ¸å¿ƒç›®çš„æ˜¯**è®©è´´å›¾çš„è¯»å–ï¼ˆ`stbi_load`ï¼‰åœ¨åå°çº¿ç¨‹ä¸­æ‰§è¡Œï¼Œè€Œä¸æ˜¯é˜»å¡ä¸»çº¿ç¨‹**ã€‚
```cpp
void Texture::loadAsync(const std::string& path, unsigned int unit, unsigned int internalFormat)
```
è¿™ä¸ªå‡½æ•°ï¼š
-   æ˜¯ä¸€ä¸ª**é™æ€å‡½æ•°**ï¼ˆ`static`ï¼‰ï¼Œæ‰€ä»¥ä¸ä¾èµ–äº `Texture` å®ä¾‹ï¼›
-   ä¼šå¯åŠ¨ä¸€ä¸ª**çº¿ç¨‹**å»åŠ è½½è´´å›¾æ•°æ®ï¼›
-   ç»“æœæš‚æ—¶ç¼“å­˜åˆ°é™æ€å˜é‡ä¸­ï¼ˆæ¯”å¦‚ `sPixels`ã€`sWidth` ç­‰ï¼‰ï¼›
-   ç„¶åä¸»çº¿ç¨‹ç¨åå†ä¸Šä¼ ã€‚

```cpp
std::thread([path]() {
    ...
}).detach();
```
-   ç”¨ lambda åˆ›å»ºçº¿ç¨‹ï¼Œæ•è· `path` å˜é‡ï¼›
-   detach ä»£è¡¨çº¿ç¨‹åå°æ‰§è¡Œï¼Œè‡ªåŠ¨ç»“æŸï¼Œä¸»çº¿ç¨‹ä¸ä¼šç­‰å¾…ã€‚

### è®¾ç½® stb_image Yè½´åè½¬ï¼ˆå’ŒåŸæ¥ä¸€æ ·ï¼‰

```cpp
stbi_set_flip_vertically_on_load(true);
```
-   å› ä¸º OpenGL Yè½´å‘ä¸Šï¼Œä½†å›¾ç‰‡å¾€å¾€ Yè½´å‘ä¸‹ï¼Œæ‰€ä»¥è¿™é‡Œåšç¿»è½¬ï¼›
-   è¿™ä¸€ç‚¹å’Œä½ åŸæ¥çš„ä¸€æ¨¡ä¸€æ ·ã€‚

### ç”¨ `stbi_load` åŠ è½½è´´å›¾æ•°æ®
```cpp
unsigned char* data = stbi_load(path.c_str(), &w, &h, &channels, STBI_rgb_alpha);
```
-   ä»æ–‡ä»¶ä¸­åŠ è½½ä¸€å¼ å›¾ç‰‡ï¼›
-   `data` æ˜¯å›¾ç‰‡åƒç´ æ•°æ®ï¼Œ`w` å’Œ `h` æ˜¯å›¾åƒå®½é«˜ï¼›
-   `channels` è¡¨ç¤ºåŸå§‹é€šé“æ•°ï¼›
-   `STBI_rgb_alpha` å¼ºåˆ¶è¾“å‡º RGBA 4 é€šé“ï¼ˆæ¯åƒç´ 4å­—èŠ‚ï¼‰ï¼›
-   **è¿™æ®µå’ŒåŸæ¥çš„ä»£ç å®Œå…¨ä¸€æ ·**ã€‚

### å¼‚å¸¸æ£€æŸ¥

```cpp
if (!data) return;
```
-   å¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ï¼ˆæ‰¾ä¸åˆ°æ–‡ä»¶/åæ–‡ä»¶ï¼‰ï¼Œç›´æ¥è¿”å›ï¼›
-   é¿å…åé¢æ“ä½œç©ºæŒ‡é’ˆã€‚

### åŠ é”å¹¶ä¿å­˜æ•°æ®ï¼ˆé‡ç‚¹ï¼ï¼‰
```cpp
std::lock_guard<std::mutex> lock(sMutex);
```
-   åŠ é”ï¼Œä¿è¯ä¸‹é¢è¿™æ®µä»£ç æ˜¯**çº¿ç¨‹å®‰å…¨çš„**ï¼›
-   å› ä¸º `sPixels`ã€`sWidth`ã€`sHeight` æ˜¯é™æ€å…±äº«å˜é‡ï¼Œå¤šçº¿ç¨‹è®¿é—®å¿…é¡»åŠ é”ã€‚

### åŠ é”å¹¶ä¿å­˜æ•°æ®ï¼ˆé‡ç‚¹ï¼ï¼‰

cpp

å¤åˆ¶ç¼–è¾‘

`std::lock_guard<std::mutex> lock(sMutex);`

-   åŠ é”ï¼Œä¿è¯ä¸‹é¢è¿™æ®µä»£ç æ˜¯**çº¿ç¨‹å®‰å…¨çš„**ï¼›
    
-   å› ä¸º `sPixels`ã€`sWidth`ã€`sHeight` æ˜¯é™æ€å…±äº«å˜é‡ï¼Œå¤šçº¿ç¨‹è®¿é—®å¿…é¡»åŠ é”ã€‚

**ä¸ºä»€ä¹ˆè¦è®¾è®¡ä¸ºé™æ€å…±äº«ï¼Ÿ**
å› ä¸ºè¿™äº›å˜é‡è¢«è®¾ä¸º `static`ï¼Œæ„æ€æ˜¯ï¼š
-   å®ƒä»¬æ˜¯ `Texture` ç±»çº§åˆ«çš„**å…¨å±€å…±äº«çŠ¶æ€**ï¼›
-   ä¸ä¾èµ–æŸä¸ª `Texture` å¯¹è±¡æ˜¯å¦å­˜åœ¨ï¼›
-   åªéœ€è¦åœ¨ç¬¬ä¸€æ¬¡å£°æ˜æ—¶æ„é€ ä¸€æ¬¡ï¼Œæ•´ä¸ªç¨‹åºç”Ÿå‘½å‘¨æœŸåªå­˜åœ¨ä¸€ä»½ã€‚

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ**
> å› ä¸ºå¼‚æ­¥è´´å›¾åŠ è½½çš„è¿‡ç¨‹å‘ç”Ÿåœ¨æ²¡æœ‰ `Texture` å¯¹è±¡çš„å‰æä¸‹ã€‚  
> æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å…ˆåŠ è½½è´´å›¾ï¼Œå†åœ¨ä¸»çº¿ç¨‹ä¸­ç”¨è¿™äº›æ•°æ®æ„é€  `Texture` å¯¹è±¡ã€‚

è€Œå¦‚æœä¸è®¾ä¸º `static`ï¼Œä½ å°±å¿…é¡»å…ˆæœ‰ä¸ªå¯¹è±¡ï¼Œæ‰èƒ½å­˜æ•°æ®ï¼Œè¿™å°±è¡Œä¸é€šäº†ã€‚

**ä¸ºä»€ä¹ˆä¸€å®šè¦ åŠ é”ï¼ˆæˆ–ç”¨ atomicï¼‰**ï¼Ÿ

å³ä½¿ä½ åªæœ‰ä¸€ä¸ªåå°çº¿ç¨‹ï¼Œ**ä¸»çº¿ç¨‹å’Œåå°çº¿ç¨‹ä¹‹é—´ä»ç„¶ä¼šäº§ç”Ÿç«æ€æ¡ä»¶**ï¼ˆrace conditionï¼‰ï¼š
ä¸¾ä¸ªä¾‹å­ï¼šä½ ä¸åŠ é”å°±è®¿é—® `sPixels`ï¼Œå¯èƒ½ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µï¼š

![è¾“å…¥å›¾ç‰‡è¯´æ˜](/imgs/2025-07-08/TfKXmQZIgkj1sgaR.png)

----------

### ä¿å­˜è´´å›¾æ•°æ®ï¼ˆåŒºåˆ«æœ€å¤§çš„ä¸€éƒ¨åˆ†ï¼‰

```cpp
sWidth = w; 
sHeight = h;
sPixels.assign(data, data + w * h * 4);
```

è¿™æ˜¯è¿™æ®µä»£ç **å’Œä½ åŸæ¥çš„æ„é€ å‡½æ•°æœ€å¤§ä¸åŒçš„åœ°æ–¹**ï¼š

#### ä½ åŸæ¥æ˜¯ï¼š

```cpp
glTexImage2D(..., data);
stbi_image_free(data);
```

ä½ æ˜¯ç›´æ¥ä¸Šä¼  GPUï¼Œä¸ä¿å­˜æ•°æ®ã€‚

#### è€Œç°åœ¨ï¼š

```cpp
sPixels.assign(data, data + w * h * 4);
```
-   æŠŠ `data` ä¸­çš„åƒç´ å¤åˆ¶è¿›ä¸€ä¸ª `std::vector<unsigned char>` ä¸­ï¼Œä¿å­˜ä¸‹æ¥ï¼›
-   `assign(data, data + w * h * 4)` æ˜¯æ ‡å‡†å†™æ³•ï¼Œç›¸å½“äºï¼š
```cpp
for (int i = 0; i < w * h * 4; ++i){
	sPixels[i] = data[i];
}
```

ä¸ºä»€ä¹ˆè¦è¿™æ ·ï¼Ÿ

> å› ä¸º `data` æ˜¯ `stbi_load` malloc å‡ºæ¥çš„ï¼Œå¦‚æœæˆ‘ä»¬ä¸åŠæ—¶æ‹·è´ã€åˆé©¬ä¸Š freeï¼Œå°±ä¼šä¸¢å¤±æ•°æ®æˆ–è®¿é—®éæ³•å†…å­˜ã€‚  
> æ‰€ä»¥æˆ‘ä»¬å…ˆ copy åˆ°è‡ªå·±çš„å®¹å™¨ä¸­ï¼ˆvectorï¼‰ï¼Œå† freeã€‚

### é‡Šæ”¾åŸå§‹æ•°æ®

```cpp
stbi_image_free(data);
```

-   åŸå§‹ `data` æ˜¯ `stbi_load` åˆ†é…çš„å †å†…å­˜ï¼›
-   æˆ‘ä»¬å·²ç»æ‹·è´è¿› `sPixels`ï¼Œæ‰€ä»¥ç°åœ¨å¯ä»¥å®‰å…¨é‡Šæ”¾ï¼›
-   å’Œä½ åŸæ¥é‡Šæ”¾æ–¹å¼ä¸€æ ·ã€‚


### è®¾ç½®æ ‡å¿—ä½ï¼šæ•°æ®å‡†å¤‡å¥½äº†ï¼

```cpp
sReady = true;
```
-   `sReady` æ˜¯ä¸€ä¸ª `std::atomic<bool>` ç±»å‹çš„å…¨å±€æ ‡å¿—ï¼›
-   ä»£è¡¨è´´å›¾æ•°æ®å·²ç»å‡†å¤‡å¥½ï¼Œå¯ä»¥ä»ä¸»çº¿ç¨‹ä¸­ä¸Šä¼  GPU äº†ï¼›
-   ä¸»çº¿ç¨‹é€šè¿‡è°ƒç”¨ `hasLoaded()` æ£€æŸ¥è¿™ä¸ªæ ‡å¿—ã€‚

# æ¥ä¸‹æ¥è¿›é˜¶ï¼ŒåŠ å…¥å¼‚æ­¥åŠ è½½å¤šå¼ è´´å›¾
æ­¤æ—¶è¦å¼•å…¥ä¸€ä¸ªå…±äº«é˜Ÿåˆ—æ¥å­˜å‚¨åŠ è½½å¥½çš„è´´å›¾

è´´å›¾æ•°æ®ç»“æ„è®¾è®¡ï¼šTextureData.h
```cpp
#pragma once
#include <vector>
#include <string>
struct TextureData {     
	std::string name;// ç”¨äºè¯†åˆ«ï¼ˆè·¯å¾„æˆ– IDï¼‰     	
	std::vector<unsigned char> pixels;// åƒç´ æ•°æ®
	int width = 0;
	int height = 0;
	int channels = 4;// é€šå¸¸æ˜¯ RGBA 
};
```
```cpp
#pragma once
#include "TextureData.h"
#include <string>
#include <vector>
#include <queue>
#include <mutex>
#include <thread>
#include <condition_variable>
class TextureLoader {
public:
	void loadAsync(const std::string& path);
	bool hasTexture();
	TextureData popTexture(); // çº¿ç¨‹å®‰å…¨åœ°å–å‡ºä¸€å¼ å·²åŠ è½½çš„è´´å›¾  private:
	std::queue<TextureData> mQueue;
	std::mutex mMutex; 
};
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTM0OTgyMzgwNywzMDk1Nzk3MjgsMTY1MD
gwODI2MCwxMTgwODMxNjk2XX0=
-->