## C++ 多线程的基本用法：`std::thread`

从 C++11 开始，我们可以用 `std::thread` 创建新线程。

### 示例：创建一个线程打印数字

```cpp
#include <iostream>
#include <thread>  
void printNumbers() {     
	for (int i = 1; i <= 5; ++i) {         
		std::cout << "子线程输出: " << i << std::endl;     
	} 
}  
int main() {     
	std::thread t(printNumbers);// 启动新线程执行 printNumbers     			
	t.join();// 等待线程执行完成     
	std::cout << "主线程结束" << std::endl;     
	return 0; 
}
```

### 运行结果：

```makefile
子线程输出: 1 
子线程输出: 2
... 
主线程结束
```
## 多线程陷阱：**共享数据和竞争问题**

两个线程如果同时访问同一份数据，就可能出错。

### 示例（错误示范）：

```cpp
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) counter++;// ❌ 两个线程同时修改可能导致错误 
}
```

### ✅ 正确写法：加锁保护共享变量

```cpp
#include <mutex>  
std::mutex mtx; 
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) {         		
		std::lock_guard<std::mutex> lock(mtx);         		
		counter++;     
	} 
}
```

> 🔒 `std::mutex` 可以保护一段代码只让一个线程进入，避免“数据竞争”。


# 与项目结合（异步加载贴图）
这是一段普通的加载贴图方法
```cpp
Texture::Texture(const std::string& path, unsigned int unit, unsigned int internalFormat) {
	mUnit = unit;

	//1 stbImage 读取图片
	int channels;

	//--反转y轴
	stbi_set_flip_vertically_on_load(true);

	unsigned char* data = stbi_load(path.c_str(), &mWidth, &mHeight, &channels, STBI_rgb_alpha);

	//2 生成纹理并且激活单元绑定
	glGenTextures(1, &mTexture);
	//--激活纹理单元--
	glActiveTexture(GL_TEXTURE0 + mUnit);
	//--绑定纹理对象--	
	glBindTexture(GL_TEXTURE_2D, mTexture);

	//3 传输纹理数据,开辟显存
	glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

	
//	glGenerateMipmap(GL_TEXTURE_2D);

	//***释放数据 
	stbi_image_free(data);

	//4 设置纹理的过滤方式
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);

	//5 设置纹理的包裹方式
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);//u
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);//v
}
```
### 区分**哪些部分可以在后台线程做，哪些必须主线程做**：
1. `stbi_load` 图像解码
✅ 可以
纯 CPU 操作，与 OpenGL 无关

2. `glGenTextures` 等 GL API
❌ 不行（默认）
OpenGL 上下文只绑定在主线程上

3. `glTexImage2D` 上传 GPU
❌ 不行（同上）
GPU 操作必须主线程完成

4. `stbi_image_free`
✅ 可以
纯内存释放，非图形 API

所以代码里，**只有 `stbi_load(path)` 这一步可以放到后台线程做**。

**多线程版本**：  
你只想让**`stbi_load` 在后台线程执行**，然后主线程再调用原来的 `Texture` 构造函数完成上传即可。

----------

## ✅ 改动目标：

你原来的结构：

cpp

复制编辑

`Texture tex("brick.jpg", 0, GL_RGBA); // 同步加载并上传`

我们要变成：

cpp

复制编辑

`// 后台线程读取图像数据 Texture::loadAsync("brick.jpg", 0, GL_RGBA);  // 主线程定期 check 是否可以构造 Texture 对象 if (Texture::hasLoaded()) {     Texture tex(Texture::getLoadedData()); }`
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTU0MzM2Nzg5NCwxMTgwODMxNjk2XX0=
-->