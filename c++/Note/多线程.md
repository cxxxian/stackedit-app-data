## C++ 多线程的基本用法：`std::thread`

从 C++11 开始，我们可以用 `std::thread` 创建新线程。

### 示例：创建一个线程打印数字

```cpp
#include <iostream>
#include <thread>  
void printNumbers() {     
	for (int i = 1; i <= 5; ++i) {         
		std::cout << "子线程输出: " << i << std::endl;     
	} 
}  
int main() {     
	std::thread t(printNumbers);// 启动新线程执行 printNumbers     			
	t.join();// 等待线程执行完成     
	std::cout << "主线程结束" << std::endl;     
	return 0; 
}
```

### 运行结果：

```makefile
子线程输出: 1 
子线程输出: 2
... 
主线程结束
```
## 多线程陷阱：**共享数据和竞争问题**

两个线程如果同时访问同一份数据，就可能出错。

### 示例（错误示范）：

```cpp
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) counter++;// ❌ 两个线程同时修改可能导致错误 
}
```

### ✅ 正确写法：加锁保护共享变量

```cpp
#include <mutex>  
std::mutex mtx; 
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) {         		
		std::lock_guard<std::mutex> lock(mtx);         		
		counter++;     
	} 
}
```

> 🔒 `std::mutex` 可以保护一段代码只让一个线程进入，避免“数据竞争”。

## 常用概念

`std::thread`：启动一个线程来执行函数
`.join()`：阻塞主线程，等子线程跑完
`.detach()`：分离线程，不等待它执行完（谨慎使用）


# 与项目结合（异步加载贴图）
这是一段普通的加载贴图方法
```cpp
Texture::Texture(const std::string& path, unsigned int unit, unsigned int internalFormat) {
	mUnit = unit;

	//1 stbImage 读取图片
	int channels;

	//--反转y轴
	stbi_set_flip_vertically_on_load(true);

	unsigned char* data = stbi_load(path.c_str(), &mWidth, &mHeight, &channels, STBI_rgb_alpha);

	//2 生成纹理并且激活单元绑定
	glGenTextures(1, &mTexture);
	//--激活纹理单元--
	glActiveTexture(GL_TEXTURE0 + mUnit);
	//--绑定纹理对象--	
	glBindTexture(GL_TEXTURE_2D, mTexture);

	//3 传输纹理数据,开辟显存
	glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

	
//	glGenerateMipmap(GL_TEXTURE_2D);

	//***释放数据 
	stbi_image_free(data);

	//4 设置纹理的过滤方式
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);

	//5 设置纹理的包裹方式
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);//u
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);//v
}
```
### 区分**哪些部分可以在后台线程做，哪些必须主线程做**：
1. `stbi_load` 图像解码
✅ 可以
纯 CPU 操作，与 OpenGL 无关

2. `glGenTextures` 等 GL API
❌ 不行（默认）
OpenGL 上下文只绑定在主线程上

3. `glTexImage2D` 上传 GPU
❌ 不行（同上）
GPU 操作必须主线程完成

4. `stbi_image_free`
✅ 可以
纯内存释放，非图形 API

所以代码里，**只有 `stbi_load(path)` 这一步可以放到后台线程做**。

**多线程版本**：  
你只想让**`stbi_load` 在后台线程执行**，然后主线程再调用原来的 `Texture` 构造函数完成上传即可。

----------

## 改动目标：

原来的结构：

```cpp
Texture tex("brick.jpg", 0, GL_RGBA); // 同步加载并上传
```

我们要变成：

```cpp
// 初始化阶段（只执行一次）
Texture::loadAsync("brick.jpg", 0, GL_RGBA);

// 主循环中每帧检查
if (Texture::hasLoaded()) {
    std::vector<unsigned char> pixels;
    int w, h;
    Texture::getLoadedData(pixels, w, h);
    Texture tex(pixels, w, h, 0, GL_RGBA); // 构造并上传
}

```	

`texture.h`如下：
```cpp
#pragma once
#include <string>
#include <vector>
#include <mutex>
#include <thread>
#include <atomic>

class Texture {
public:
    Texture(const std::vector<unsigned char>& pixels, int width, int height,
            unsigned int unit, unsigned int internalFormat);

    static void loadAsync(const std::string& path, unsigned int unit, unsigned int internalFormat);
    static bool hasLoaded();
    static void getLoadedData(std::vector<unsigned char>& pixels, int& w, int& h);

private:
    unsigned int mTexture = 0;
    unsigned int mUnit = 0;
    int mWidth = 0;
    int mHeight = 0;

    static std::vector<unsigned char> sPixels;
    static int sWidth, sHeight;
    static std::mutex sMutex;
    static std::atomic<bool> sReady;
};
```
`Texture.cpp`如下：
```cpp
#define STB_IMAGE_IMPLEMENTATION
#include "Texture.h"
#include <glad/glad.h>
#include <stb_image.h>

std::vector<unsigned char> Texture::sPixels;
int Texture::sWidth = 0;
int Texture::sHeight = 0;
std::mutex Texture::sMutex;
std::atomic<bool> Texture::sReady = false;

Texture::Texture(const std::vector<unsigned char>& pixels, int width, int height,
                 unsigned int unit, unsigned int internalFormat) {
    mUnit = unit;
    mWidth = width;
    mHeight = height;

    glGenTextures(1, &mTexture);
    glActiveTexture(GL_TEXTURE0 + mUnit);
    glBindTexture(GL_TEXTURE_2D, mTexture);

    glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels.data());

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
}

void Texture::loadAsync(const std::string& path, unsigned int unit, unsigned int internalFormat) {
	//lambda表达式
    std::thread([path]() {
        int w, h, channels;
        stbi_set_flip_vertically_on_load(true);
        unsigned char* data = stbi_load(path.c_str(), &w, &h, &channels, STBI_rgb_alpha);
        if (!data) return;

        std::lock_guard<std::mutex> lock(sMutex);
        sWidth = w;
        sHeight = h;
        sPixels.assign(data, data + w * h * 4);
        stbi_image_free(data);
        sReady = true;
    }).detach();
}

bool Texture::hasLoaded() {
    return sReady.load();
}

void Texture::getLoadedData(std::vector<unsigned char>& pixels, int& w, int& h) {
    std::lock_guard<std::mutex> lock(sMutex);
    pixels = sPixels;
    w = sWidth;
    h = sHeight;
    sReady = false;
}

```
解释一下：
`loadAsync`核心目的是**让贴图的读取（`stbi_load`）在后台线程中执行，而不是阻塞主线程**。
```cpp
void Texture::loadAsync(const std::string& path, unsigned int unit, unsigned int internalFormat)
```
这个函数：
-   是一个**静态函数**（`static`），所以不依赖于 `Texture` 实例；
-   会启动一个**线程**去加载贴图数据；
-   结果暂时缓存到静态变量中（比如 `sPixels`、`sWidth` 等）；
-   然后主线程稍后再上传。

```cpp
std::thread([path]() {
    ...
}).detach();
```
-   用 lambda 创建线程，捕获 `path` 变量；
-   detach 代表线程后台执行，自动结束，主线程不会等待。

### 设置 stb_image Y轴反转（和原来一样）

```cpp
stbi_set_flip_vertically_on_load(true);
```
-   因为 OpenGL Y轴向上，但图片往往 Y轴向下，所以这里做翻转；
-   这一点和你原来的一模一样。

### 用 `stbi_load` 加载贴图数据
```cpp
unsigned char* data = stbi_load(path.c_str(), &w, &h, &channels, STBI_rgb_alpha);
```
-   从文件中加载一张图片；
-   `data` 是图片像素数据，`w` 和 `h` 是图像宽高；
-   `channels` 表示原始通道数；
-   `STBI_rgb_alpha` 强制输出 RGBA 4 通道（每像素4字节）；
-   **这段和原来的代码完全一样**。

### 异常检查

```cpp
if (!data) return;
```
-   如果图片加载失败（找不到文件/坏文件），直接返回；
-   避免后面操作空指针。

### 加锁并保存数据（重点！）
```cpp
std::lock_guard<std::mutex> lock(sMutex);
```
-   加锁，保证下面这段代码是**线程安全的**；
-   因为 `sPixels`、`sWidth`、`sHeight` 是静态共享变量，多线程访问必须加锁。

### 加锁并保存数据（重点！）

cpp

复制编辑

`std::lock_guard<std::mutex> lock(sMutex);`

-   加锁，保证下面这段代码是**线程安全的**；
    
-   因为 `sPixels`、`sWidth`、`sHeight` 是静态共享变量，多线程访问必须加锁。

**为什么要设计为静态共享？**
因为这些变量被设为 `static`，意思是：
-   它们是 `Texture` 类级别的**全局共享状态**；
-   不依赖某个 `Texture` 对象是否存在；
-   只需要在第一次声明时构造一次，整个程序生命周期只存在一份。

**为什么这样设计？**
> 因为异步贴图加载的过程发生在没有 `Texture` 对象的前提下。  
> 换句话说，我们先加载贴图，再在主线程中用这些数据构造 `Texture` 对象。

而如果不设为 `static`，你就必须先有个对象，才能存数据，这就行不通了。

**为什么一定要 加锁（或用 atomic）**？

即使你只有一个后台线程，**主线程和后台线程之间仍然会产生竞态条件**（race condition）：
举个例子：你不加锁就访问 `sPixels`，可能会发生这种情况：

![输入图片说明](/imgs/2025-07-08/TfKXmQZIgkj1sgaR.png)

----------

### 保存贴图数据（区别最大的一部分）

```cpp
sWidth = w; 
sHeight = h;
sPixels.assign(data, data + w * h * 4);
```

这是这段代码**和你原来的构造函数最大不同的地方**：

#### 你原来是：

```cpp
glTexImage2D(..., data);
stbi_image_free(data);
```

你是直接上传 GPU，不保存数据。

#### 而现在：

```cpp
sPixels.assign(data, data + w * h * 4);
```
-   把 `data` 中的像素复制进一个 `std::vector<unsigned char>` 中，保存下来；
-   `assign(data, data + w * h * 4)` 是标准写法，相当于：
```cpp
for (int i = 0; i < w * h * 4; ++i){
	sPixels[i] = data[i];
}
```

为什么要这样？

> 因为 `data` 是 `stbi_load` malloc 出来的，如果我们不及时拷贝、又马上 free，就会丢失数据或访问非法内存。  
> 所以我们先 copy 到自己的容器中（vector），再 free。

### 释放原始数据

```cpp
stbi_image_free(data);
```

-   原始 `data` 是 `stbi_load` 分配的堆内存；
-   我们已经拷贝进 `sPixels`，所以现在可以安全释放；
-   和你原来释放方式一样。


### 设置标志位：数据准备好了！

```cpp
sReady = true;
```
-   `sReady` 是一个 `std::atomic<bool>` 类型的全局标志；
-   代表贴图数据已经准备好，可以从主线程中上传 GPU 了；
-   主线程通过调用 `hasLoaded()` 检查这个标志。

# 接下来进阶，加入异步加载多张贴图
此时要引入一个共享队列来存储加载好的贴图

贴图数据结构设计：TextureData.h
```cpp
#pragma once
#include <vector>
#include <string>
struct TextureData {     
	std::string name;// 用于识别（路径或 ID）     	
	std::vector<unsigned char> pixels;// 像素数据
	int width = 0;
	int height = 0;
	int channels = 4;// 通常是 RGBA 
};
```
```cpp
#pragma once
#include "TextureData.h"
#include <string>
#include <vector>
#include <queue>
#include <mutex>
#include <thread>
#include <condition_variable>
class TextureLoader {
public:
	void loadAsync(const std::string& path);
	bool hasTexture();
	TextureData popTexture(); // 线程安全地取出一张已加载的贴图  private:
	std::queue<TextureData> mQueue;
	std::mutex mMutex; 
};
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTM0OTgyMzgwNywzMDk1Nzk3MjgsMTY1MD
gwODI2MCwxMTgwODMxNjk2XX0=
-->