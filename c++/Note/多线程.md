## C++ å¤šçº¿ç¨‹çš„åŸºæœ¬ç”¨æ³•ï¼š`std::thread`

ä» C++11 å¼€å§‹ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ `std::thread` åˆ›å»ºæ–°çº¿ç¨‹ã€‚

### ç¤ºä¾‹ï¼šåˆ›å»ºä¸€ä¸ªçº¿ç¨‹æ‰“å°æ•°å­—

```cpp
#include <iostream>
#include <thread>  
void printNumbers() {     
	for (int i = 1; i <= 5; ++i) {         
		std::cout << "å­çº¿ç¨‹è¾“å‡º: " << i << std::endl;     
	} 
}  
int main() {     
	std::thread t(printNumbers);// å¯åŠ¨æ–°çº¿ç¨‹æ‰§è¡Œ printNumbers     			
	t.join();// ç­‰å¾…çº¿ç¨‹æ‰§è¡Œå®Œæˆ     
	std::cout << "ä¸»çº¿ç¨‹ç»“æŸ" << std::endl;     
	return 0; 
}
```

### è¿è¡Œç»“æœï¼š

```makefile
å­çº¿ç¨‹è¾“å‡º: 1 
å­çº¿ç¨‹è¾“å‡º: 2
... 
ä¸»çº¿ç¨‹ç»“æŸ
```
## å¤šçº¿ç¨‹é™·é˜±ï¼š**å…±äº«æ•°æ®å’Œç«äº‰é—®é¢˜**

ä¸¤ä¸ªçº¿ç¨‹å¦‚æœåŒæ—¶è®¿é—®åŒä¸€ä»½æ•°æ®ï¼Œå°±å¯èƒ½å‡ºé”™ã€‚

### ç¤ºä¾‹ï¼ˆé”™è¯¯ç¤ºèŒƒï¼‰ï¼š

```cpp
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) counter++;// âŒ ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶ä¿®æ”¹å¯èƒ½å¯¼è‡´é”™è¯¯ 
}
```

### âœ… æ­£ç¡®å†™æ³•ï¼šåŠ é”ä¿æŠ¤å…±äº«å˜é‡

```cpp
#include <mutex>  
std::mutex mtx; 
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) {         		
		std::lock_guard<std::mutex> lock(mtx);         		
		counter++;     
	} 
}
```

> ğŸ”’ `std::mutex` å¯ä»¥ä¿æŠ¤ä¸€æ®µä»£ç åªè®©ä¸€ä¸ªçº¿ç¨‹è¿›å…¥ï¼Œé¿å…â€œæ•°æ®ç«äº‰â€ã€‚


# ä¸é¡¹ç›®ç»“åˆï¼ˆå¼‚æ­¥åŠ è½½è´´å›¾ï¼‰
è¿™æ˜¯ä¸€æ®µæ™®é€šçš„åŠ è½½è´´å›¾æ–¹æ³•
```cpp
Texture::Texture(const std::string& path, unsigned int unit, unsigned int internalFormat) {
	mUnit = unit;

	//1 stbImage è¯»å–å›¾ç‰‡
	int channels;

	//--åè½¬yè½´
	stbi_set_flip_vertically_on_load(true);

	unsigned char* data = stbi_load(path.c_str(), &mWidth, &mHeight, &channels, STBI_rgb_alpha);

	//2 ç”Ÿæˆçº¹ç†å¹¶ä¸”æ¿€æ´»å•å…ƒç»‘å®š
	glGenTextures(1, &mTexture);
	//--æ¿€æ´»çº¹ç†å•å…ƒ--
	glActiveTexture(GL_TEXTURE0 + mUnit);
	//--ç»‘å®šçº¹ç†å¯¹è±¡--	
	glBindTexture(GL_TEXTURE_2D, mTexture);

	//3 ä¼ è¾“çº¹ç†æ•°æ®,å¼€è¾Ÿæ˜¾å­˜
	glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

	
//	glGenerateMipmap(GL_TEXTURE_2D);

	//***é‡Šæ”¾æ•°æ® 
	stbi_image_free(data);

	//4 è®¾ç½®çº¹ç†çš„è¿‡æ»¤æ–¹å¼
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);

	//5 è®¾ç½®çº¹ç†çš„åŒ…è£¹æ–¹å¼
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);//u
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);//v
}
```
### åŒºåˆ†**å“ªäº›éƒ¨åˆ†å¯ä»¥åœ¨åå°çº¿ç¨‹åšï¼Œå“ªäº›å¿…é¡»ä¸»çº¿ç¨‹åš**ï¼š
1. `stbi_load` å›¾åƒè§£ç 
âœ… å¯ä»¥
çº¯ CPU æ“ä½œï¼Œä¸ OpenGL æ— å…³

2. `glGenTextures` ç­‰ GL API
âŒ ä¸è¡Œï¼ˆé»˜è®¤ï¼‰
OpenGL ä¸Šä¸‹æ–‡åªç»‘å®šåœ¨ä¸»çº¿ç¨‹ä¸Š

3. `glTexImage2D` ä¸Šä¼  GPU
âŒ ä¸è¡Œï¼ˆåŒä¸Šï¼‰
GPU æ“ä½œå¿…é¡»ä¸»çº¿ç¨‹å®Œæˆ

4. `stbi_image_free`
âœ… å¯ä»¥
çº¯å†…å­˜é‡Šæ”¾ï¼Œéå›¾å½¢ API

æ‰€ä»¥ä»£ç é‡Œï¼Œ**åªæœ‰ `stbi_load(path)` è¿™ä¸€æ­¥å¯ä»¥æ”¾åˆ°åå°çº¿ç¨‹åš**ã€‚

**å¤šçº¿ç¨‹ç‰ˆæœ¬**ï¼š  
ä½ åªæƒ³è®©**`stbi_load` åœ¨åå°çº¿ç¨‹æ‰§è¡Œ**ï¼Œç„¶åä¸»çº¿ç¨‹å†è°ƒç”¨åŸæ¥çš„ `Texture` æ„é€ å‡½æ•°å®Œæˆä¸Šä¼ å³å¯ã€‚

----------

## æ”¹åŠ¨ç›®æ ‡ï¼š

åŸæ¥çš„ç»“æ„ï¼š

```cpp
Texture tex("brick.jpg", 0, GL_RGBA); // åŒæ­¥åŠ è½½å¹¶ä¸Šä¼ 
```

æˆ‘ä»¬è¦å˜æˆï¼š

```cpp
// åå°çº¿ç¨‹è¯»å–å›¾åƒæ•°æ®
Texture::loadAsync("brick.jpg", 0, GL_RGBA);
// ä¸»çº¿ç¨‹å®šæœŸ check æ˜¯å¦å¯ä»¥æ„é€  Texture å¯¹è±¡
if (Texture::hasLoaded()) {
	Texture tex(Texture::getLoadedData()); 
}
```	

`texture.h`å¦‚ä¸‹ï¼š
```cpp
#pragma once
#include <string>
#include <vector>
#include <mutex>
#include <thread>
#include <atomic>

class Texture {
public:
    Texture(const std::vector<unsigned char>& pixels, int width, int height,
            unsigned int unit, unsigned int internalFormat);

    static void loadAsync(const std::string& path, unsigned int unit, unsigned int internalFormat);
    static bool hasLoaded();
    static void getLoadedData(std::vector<unsigned char>& pixels, int& w, int& h);

private:
    unsigned int mTexture = 0;
    unsigned int mUnit = 0;
    int mWidth = 0;
    int mHeight = 0;

    static std::vector<unsigned char> sPixels;
    static int sWidth, sHeight;
    static std::mutex sMutex;
    static std::atomic<bool> sReady;
};
```
`Texture.cpp`å¦‚ä¸‹ï¼š
```cpp
#define STB_IMAGE_IMPLEMENTATION
#include "Texture.h"
#include <glad/glad.h>
#include <stb_image.h>

std::vector<unsigned char> Texture::sPixels;
int Texture::sWidth = 0;
int Texture::sHeight = 0;
std::mutex Texture::sMutex;
std::atomic<bool> Texture::sReady = false;

Texture::Texture(const std::vector<unsigned char>& pixels, int width, int height,
                 unsigned int unit, unsigned int internalFormat) {
    mUnit = unit;
    mWidth = width;
    mHeight = height;

    glGenTextures(1, &mTexture);
    glActiveTexture(GL_TEXTURE0 + mUnit);
    glBindTexture(GL_TEXTURE_2D, mTexture);

    glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels.data());

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
}

void Texture::loadAsync(const std::string& path, unsigned int unit, unsigned int internalFormat) {
    std::thread([path]() {
        int w, h, channels;
        stbi_set_flip_vertically_on_load(true);
        unsigned char* data = stbi_load(path.c_str(), &w, &h, &channels, STBI_rgb_alpha);
        if (!data) return;

        std::lock_guard<std::mutex> lock(sMutex);
        sWidth = w;
        sHeight = h;
        sPixels.assign(data, data + w * h * 4);
        stbi_image_free(data);
        sReady = true;
    }).detach();
}

bool Texture::hasLoaded() {
    return sReady.load();
}

void Texture::getLoadedData(std::vector<unsigned char>& pixels, int& w, int& h) {
    std::lock_guard<std::mutex> lock(sMutex);
    pixels = sPixels;
    w = sWidth;
    h = sHeight;
    sReady = false;
}

```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTYxNzA3MzQwNCwxMTgwODMxNjk2XX0=
-->