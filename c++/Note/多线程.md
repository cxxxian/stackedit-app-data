## C++ 多线程的基本用法：`std::thread`

从 C++11 开始，我们可以用 `std::thread` 创建新线程。

### 示例：创建一个线程打印数字

```cpp
#include <iostream>
#include <thread>  
void printNumbers() {     
	for (int i = 1; i <= 5; ++i) {         
		std::cout << "子线程输出: " << i << std::endl;     
	} 
}  
int main() {     
	std::thread t(printNumbers);// 启动新线程执行 printNumbers     			
	t.join();// 等待线程执行完成     
	std::cout << "主线程结束" << std::endl;     
	return 0; 
}
```

### 运行结果：

```makefile
子线程输出: 1 
子线程输出: 2
... 
主线程结束
```
## 多线程陷阱：**共享数据和竞争问题**

两个线程如果同时访问同一份数据，就可能出错。

### 示例（错误示范）：

```cpp
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) counter++;// ❌ 两个线程同时修改可能导致错误 
}
```

### ✅ 正确写法：加锁保护共享变量

```cpp
#include <mutex>  
std::mutex mtx; 
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) {         		
		std::lock_guard<std::mutex> lock(mtx);         		
		counter++;     
	} 
}
```

> 🔒 `std::mutex` 可以保护一段代码只让一个线程进入，避免“数据竞争”。


# 与项目结合（异步加载贴图）
这是一段普通的加载贴图方法
```cpp
Texture::Texture(const std::string& path, unsigned int unit, unsigned int internalFormat) {
	mUnit = unit;

	//1 stbImage 读取图片
	int channels;

	//--反转y轴
	stbi_set_flip_vertically_on_load(true);

	unsigned char* data = stbi_load(path.c_str(), &mWidth, &mHeight, &channels, STBI_rgb_alpha);

	//2 生成纹理并且激活单元绑定
	glGenTextures(1, &mTexture);
	//--激活纹理单元--
	glActiveTexture(GL_TEXTURE0 + mUnit);
	//--绑定纹理对象--	
	glBindTexture(GL_TEXTURE_2D, mTexture);

	//3 传输纹理数据,开辟显存
	glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);

	
//	glGenerateMipmap(GL_TEXTURE_2D);

	//***释放数据 
	stbi_image_free(data);

	//4 设置纹理的过滤方式
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST_MIPMAP_NEAREST);

	//5 设置纹理的包裹方式
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);//u
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);//v
}
```
### 区分**哪些部分可以在后台线程做，哪些必须主线程做**：
1. `stbi_load` 图像解码
✅ 可以
纯 CPU 操作，与 OpenGL 无关

2. `glGenTextures` 等 GL API
❌ 不行（默认）
OpenGL 上下文只绑定在主线程上

3. `glTexImage2D` 上传 GPU
❌ 不行（同上）
GPU 操作必须主线程完成

4. `stbi_image_free`
✅ 可以
纯内存释放，非图形 API

所以代码里，**只有 `stbi_load(path)` 这一步可以放到后台线程做**。

**多线程版本**：  
你只想让**`stbi_load` 在后台线程执行**，然后主线程再调用原来的 `Texture` 构造函数完成上传即可。

----------

## 改动目标：

原来的结构：

```cpp
Texture tex("brick.jpg", 0, GL_RGBA); // 同步加载并上传
```

我们要变成：

```cpp
// 后台线程读取图像数据
Texture::loadAsync("brick.jpg", 0, GL_RGBA);
// 主线程定期 check 是否可以构造 Texture 对象
if (Texture::hasLoaded()) {
	Texture tex(Texture::getLoadedData()); 
}
```	

`texture.h`如下：
```cpp
#pragma once
#include <string>
#include <vector>
#include <mutex>
#include <thread>
#include <atomic>

class Texture {
public:
    Texture(const std::vector<unsigned char>& pixels, int width, int height,
            unsigned int unit, unsigned int internalFormat);

    static void loadAsync(const std::string& path, unsigned int unit, unsigned int internalFormat);
    static bool hasLoaded();
    static void getLoadedData(std::vector<unsigned char>& pixels, int& w, int& h);

private:
    unsigned int mTexture = 0;
    unsigned int mUnit = 0;
    int mWidth = 0;
    int mHeight = 0;

    static std::vector<unsigned char> sPixels;
    static int sWidth, sHeight;
    static std::mutex sMutex;
    static std::atomic<bool> sReady;
};
```
`Texture.cpp`如下：
```cpp
#define STB_IMAGE_IMPLEMENTATION
#include "Texture.h"
#include <glad/glad.h>
#include <stb_image.h>

std::vector<unsigned char> Texture::sPixels;
int Texture::sWidth = 0;
int Texture::sHeight = 0;
std::mutex Texture::sMutex;
std::atomic<bool> Texture::sReady = false;

Texture::Texture(const std::vector<unsigned char>& pixels, int width, int height,
                 unsigned int unit, unsigned int internalFormat) {
    mUnit = unit;
    mWidth = width;
    mHeight = height;

    glGenTextures(1, &mTexture);
    glActiveTexture(GL_TEXTURE0 + mUnit);
    glBindTexture(GL_TEXTURE_2D, mTexture);

    glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixels.data());

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
}

void Texture::loadAsync(const std::string& path, unsigned int unit, unsigned int internalFormat) {
    std::thread([path]() {
        int w, h, channels;
        stbi_set_flip_vertically_on_load(true);
        unsigned char* data = stbi_load(path.c_str(), &w, &h, &channels, STBI_rgb_alpha);
        if (!data) return;

        std::lock_guard<std::mutex> lock(sMutex);
        sWidth = w;
        sHeight = h;
        sPixels.assign(data, data + w * h * 4);
        stbi_image_free(data);
        sReady = true;
    }).detach();
}

bool Texture::hasLoaded() {
    return sReady.load();
}

void Texture::getLoadedData(std::vector<unsigned char>& pixels, int& w, int& h) {
    std::lock_guard<std::mutex> lock(sMutex);
    pixels = sPixels;
    w = sWidth;
    h = sHeight;
    sReady = false;
}

```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTYxNzA3MzQwNCwxMTgwODMxNjk2XX0=
-->