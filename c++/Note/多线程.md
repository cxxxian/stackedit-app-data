## C++ 多线程的基本用法：`std::thread`

从 C++11 开始，我们可以用 `std::thread` 创建新线程。

### 示例：创建一个线程打印数字

```cpp
#include <iostream>
#include <thread>  
void printNumbers() {     
	for (int i = 1; i <= 5; ++i) {         
		std::cout << "子线程输出: " << i << std::endl;     
	} 
}  
int main() {     
	std::thread t(printNumbers);// 启动新线程执行 printNumbers     			
	t.join();// 等待线程执行完成     
	std::cout << "主线程结束" << std::endl;     
	return 0; 
}
```

### 运行结果：

```makefile
子线程输出: 1 
子线程输出: 2
... 
主线程结束
```
## 多线程陷阱：**共享数据和竞争问题**

两个线程如果同时访问同一份数据，就可能出错。

### 示例（错误示范）：

```cpp
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) counter++;// ❌ 两个线程同时修改可能导致错误 
}
```

### ✅ 正确写法：加锁保护共享变量

```cpp
#include <mutex>  
std::mutex mtx; 
int counter = 0;  
void countUp() {     
	for (int i = 0; i < 1000; ++i) {         	std::lock_guard<std::mutex> lock(mtx);         counter++;     } }
```

> 🔒 `std::mutex` 可以保护一段代码只让一个线程进入，避免“数据竞争”。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTg3MjI4ODgxMV19
-->