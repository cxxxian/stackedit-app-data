# 数据类型占用
-   `short`：2 字节（16 位）
    
-   `int`：4 字节（32 位）
    
-   `float`：4 字节（32 位，IEEE 754 单精度浮点数）
    
-   `double`：8 字节（64 位，IEEE 754 双精度浮点数）
    
-   `char`：1 字节（8 位）

-   `long` 是 4 字节（32 位）
    
-   `long long` 是 8 字节（64 位）
    
-   指针（如 `int*`, `void*` 等）：8 字节（64 位系统下，指针大小通常是 8 字节；在 32 位系统下是 4 字节）

# 内存对齐规则（padding填充）
## 结构体内存对齐的基本规则

### 1. 每个成员的 **地址偏移** 必须是其类型的对齐要求的倍数

-   `char` 对齐到 1 字节
    
-   `int` 对齐到 4 字节
    
-   `double` 对齐到 8 字节
    
-   指针在 64 位系统上通常对齐到 8 字节
    

**结构体在排布成员时，会自动填充 padding 来满足这些对齐要求。**

### 2. 整个结构体的大小（`sizeof(struct)`）必须是**最大对齐量的整数倍**

-   最大对齐量 = 结构体中最大对齐需求的成员的对齐数
    

否则编译器可能会在结构体结尾加尾部 padding。

## Padding 发生的三种情况

### 1. **成员之间的 padding**

当前成员的结尾 **不足以对齐下一个成员**，就会填充。

例如：
```cpp
struct A {
    char c;     // 1 byte
    int i;      // 4 bytes, but必须4字节对齐 ⇒ 填充3字节
};
```
-   实际排布是：`[c][padding(3)][i]` ⇒ `sizeof(A) = 8`

### 2. **结构体结尾的 padding**

结构体整体大小必须是 **最大成员对齐数的倍数**，否则在结尾再加 padding。

例如：

```cpp
struct B {
    int i;      // 4 bytes
    char c;     // 1 byte
    // padding 3 bytes at end to align to 4
};

```
sizeof(B) = 8

### 3. **嵌套结构体的 padding**

结构体内嵌一个结构体，也要保证子结构体正确对齐。
```cpp
struct Inner {
    char c;
    int i;
}; // sizeof(Inner) = 8

struct Outer {
    double d;
    Inner in;
}; // 由于 Inner 首地址必须按其最大对齐（4）对齐，d 结束后可能填 padding。
```
## 小技巧：如何手动减少 padding？

1.  **将成员从大到小排列**（按对齐需求从大到小）  
    避免小成员把大成员“卡”在中间，需要填充。
    
2.  **使用 `#pragma pack` 或 `alignas()` 控制对齐**（慎用）  
    会影响 ABI，可能带来跨平台 bug。
    
3.  **考虑缓存行对齐**（性能优化）
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTMwNjkwMzA3NCw4NjQ3MjQ5MTMsMTMwOD
U1OTQxXX0=
-->