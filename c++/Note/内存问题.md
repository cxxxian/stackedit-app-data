# 数据类型占用
-   `short`：2 字节（16 位）
    
-   `int`：4 字节（32 位）
    
-   `float`：4 字节（32 位，IEEE 754 单精度浮点数）
    
-   `double`：8 字节（64 位，IEEE 754 双精度浮点数）
    
-   `char`：1 字节（8 位）

-   `long` 是 4 字节（32 位）
    
-   `long long` 是 8 字节（64 位）
    
-   指针（如 `int*`, `void*` 等）：8 字节（64 位系统下，指针大小通常是 8 字节；在 32 位系统下是 4 字节）

# 内存对齐规则（padding填充）
## 结构体内存对齐的基本规则

### 1. 每个成员的 **地址偏移** 必须是其类型的对齐要求的倍数

-   `char` 对齐到 1 字节
    
-   `int` 对齐到 4 字节
    
-   `double` 对齐到 8 字节
    
-   指针在 64 位系统上通常对齐到 8 字节
    

**结构体在排布成员时，会自动填充 padding 来满足这些对齐要求。**

### 2. 整个结构体的大小（`sizeof(struct)`）必须是**最大对齐量的整数倍**

-   最大对齐量 = 结构体中最大对齐需求的成员的对齐数
    

否则编译器可能会在结构体结尾加尾部 padding。

## Padding 发生的三种情况

### ✅ 1. **成员之间的 padding**

当前成员的结尾 **不足以对齐下一个成员**，就会填充。

例如：
<!--stackedit_data:
eyJoaXN0b3J5IjpbMzU3OTU0Mjg5LDg2NDcyNDkxMywxMzA4NT
U5NDFdfQ==
-->