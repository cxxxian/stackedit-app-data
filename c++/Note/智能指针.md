# unique_ptr

## move
### 一、unique_ptr 的移动语义背景

`unique_ptr` 是**独占资源所有权**的智能指针，因此它：

-   禁止拷贝（不能有两个 `unique_ptr` 管理同一个指针）
    
-   只允许**移动**来转移所有权
    

----------

### 二、`std::move` 的作用（转移所有权）

```cpp
std::unique_ptr<int> p1(new int(10)); std::unique_ptr<int> p2 = std::move(p1);`
```
含义如下：

-   `std::move(p1)` **将 p1 变为右值**，允许调用移动构造函数
    
-   所有权从 `p1` 转移到 `p2`，`p1` 变为空指针
    

等价于：

```cpp
// 内部是调用了 unique_ptr 的移动构造函数 
p2 = unique_ptr<int>(std::move(p1));  // 实际是构造了一个临时对象并赋值`
```
移动后：

-   `p1.get() == nullptr`
    
-   `p2.get()` 指向原来的资源
    

**注意：`std::move()` 不移动任何东西，只是让变量变成“右值”，允许移动。**

### 三、`std::forward` 的作用（完美转发）

#### 用途：

`std::forward<T>(arg)` 用在**模板中**，保留参数的“左值/右值”属性。

```cpp
template<typename T> void wrapper(T&& arg) {     func(std::forward<T>(arg)); // 完美转发 }
```

#### 与 `unique_ptr` 的结合：

例如，你写一个函数，接收任何 `unique_ptr` 类型并将其转发给别的函数：

```cpp
void consume(std::unique_ptr<int> p) {     // 使用资源 }  template<typename T> void wrapper(T&& arg) {     consume(std::forward<T>(arg)); // 保留原始值类别 }
```
这样：
-   如果你传的是 `std::move(ptr)`，它是右值 -> `std::forward` 保留右值，触发移动。
    
-   如果你传的是 `ptr`（左值），它不能转给 `consume`（因为 `consume` 只能接右值）

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI5MDU2NjcxN119
-->