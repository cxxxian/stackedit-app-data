# 颜色
```glsl
vec3 red = vec3(1.0,0.0,0.0);
red.x = 1.0;
red.y = 0.0;
red.z = 0.0;
```

以x,y,z定义颜色是不是有些奇怪？正因如此，我们有其他方法访问这些变量——以不同的名字。`.x`, `.y`, `.z`也可以被写作`.r`, `.g`, `.b` 和 `.s`, `.t`, `.p`。（`.s`, `.t`, `.p`通常被用做后面章节提到的贴图空间坐标）你也可以通过使用索引位置`[0]`, `[1]` 和 `[2]`来访问向量.

下面的代码展示了所有访问相同数据的方式：

```glsl
vec4 vector;
vector[0] = vector.r = vector.x = vector.s;
vector[1] = vector.g = vector.y = vector.t;
vector[2] = vector.b = vector.z = vector.p;
vector[3] = vector.a = vector.w = vector.q;
```
## 混合颜色
### mix()函数
```
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform float u_time;
vec3 colorA = vec3(0.149,0.141,0.912);
vec3 colorB = vec3(1.000,0.833,0.224);
void main() {
    vec3 color = vec3(0.0);
    float pct = abs(sin(u_time));
    
    // Mix uses pct (a value from 0-1) to
    // mix the two colors
    color = mix(colorA, colorB, pct);

    gl_FragColor = vec4(color,1.0);
}
```
### 逐步解释：

1.  **`vec3 colorA = vec3(0.149, 0.141, 0.912);`**
    -   定义了颜色 `colorA`，这是一个 RGB 颜色，接近深蓝色。
2.  **`vec3 colorB = vec3(1.000, 0.833, 0.224);`**
    -   定义了第二个颜色 `colorB`，接近亮黄色。
3.  **`float pct = abs(sin(u_time));`**
    
    -   这里的 `u_time` 是一个随时间变化的浮点数，`sin(u_time)` 计算的是 `u_time` 的正弦值，范围在 -1 到 1 之间。
    -   `abs(sin(u_time))` 取绝对值，使其范围变为 0 到 1 之间。
    -   这个 `pct`（百分比）会随着时间在 0 和 1 之间循环变化，控制颜色混合的比例。
4.  **`color = mix(colorA, colorB, pct);`**
    
    -   `mix` 函数根据第三个参数 `pct`（范围 0 到 1）来插值混合两个颜色。公式为
        `mix(a, b, pct) = a * (1 - pct) + b * pct;`
        
    -   当 `pct` 为 0 时，`mix` 返回 `colorA`（蓝色）；当 `pct` 为 1 时，`mix` 返回 `colorB`（黄色）；在 0 到 1 之间，它会按比例混合两个颜色。
    -   随着时间变化，颜色在深蓝色和亮黄色之间平滑过渡。
5.  **`gl_FragColor = vec4(color, 1.0);`**
    
    -   将计算得到的颜色赋值给片段的输出颜色，并设置不透明度为 1.0（完全不透明）。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTcyMzY4MDI0NV19
-->