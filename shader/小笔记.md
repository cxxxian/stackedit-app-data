# 有关于`fbo`和`viewport`的理解
我们在每一次准备渲染`fbo`时，都需要将`viewPort`调整到该`fbo`对应的大小
## 举例1
这是我们进行`bloom`渲染的时候，是将`src`提取高亮部分渲染到`dst`上，
我们在方法开头要将`viewPort`进行调整：`glViewport(0, 0, dst->mWidth, dst->mHeight);`
所以此处是对于`dst`的渲染，所以肯定要把`viewport`调整为`dst`的大小
```cpp
void Bloom::extractBright(Framebuffer* src, Framebuffer* dst)
{
	glBindFramebuffer(GL_FRAMEBUFFER, dst->mFBO);

	glViewport(0, 0, dst->mWidth, dst->mHeight);
	glClear(GL_COLOR_BUFFER_BIT);
	
	...
}
```

## 举例2
我们对于点光源的`mRenderTarget`也就是它的`fbo`设置为大小`1024, 1024`，意思就是我们`shadowMap`的大小到时候就是`1024 * 1024`
```cpp
PointLightShadow::PointLightShadow() {
	mCamera = new PerspectiveCamera(90.0f, 1.0, 0.1f, 50.0f);
	mRenderTarget = Framebuffer::createPointShadowFbo(1024, 1024);
}

```
这是我们`renderShadowMap`的方法，我们在渲染阴影贴图的时候，注意这时候我们先取到了目前`viewport`的大小，并进行了记录，其实这时候就记录的是我们当前的屏幕大小
然后我们就要把`viewport`改为和`shadowMap`大小对应的尺寸，再进行渲染
然后很重要的一步就是我们渲染完`shadowMap`之后，要把`viewport`的大小再改回屏幕大小
```cpp
void Renderer::renderShadowMap(
	Camera* camera,
	const std::vector<Mesh*>& meshes, 
	PointLight* pointLight) {
	...

	//2 保存原始状态，绘制shadowMap完毕后，要恢复原始状态
	GLint preFbo;
	glGetIntegerv(GL_FRAMEBUFFER_BINDING, &preFbo);

	GLint preViewport[4];
	glGetIntegerv(GL_VIEWPORT, preViewport);
	...

	glBindFramebuffer(GL_FRAMEBUFFER, pointShadow->mRenderTarget->mFBO);
	glViewport(0, 0, pointShadow->mRenderTarget->mWidth, pointShadow->mRenderTarget->mHeight);

	...

	glBindFramebuffer(GL_FRAMEBUFFER, preFbo);
	glViewport(preViewport[0], preViewport[1], preViewport[2], preViewport[3]);
}
```

# 向量指向问题
例如：
`worldPosition - cameraPosition`
是指`camera`位置指向物体`worldPosition`的向量

# 有关于texture和fbo的思考

![输入图片说明](/imgs/2025-02-12/7ntBrcUI7IdRxa42.png)

我们一开始声明附件对应`texture`的时候，一般最后都是填个`NULL`，说明最后并没有传输任何的数据进去
例如这个颜色`texture`附件
```cpp
Texture::Texture(unsigned int width, unsigned int height, unsigned int unit, unsigned int internalFormat) {
	mWidth = width;
	mHeight = height;
	mUnit = unit;

	glGenTextures(1, &mTexture);
	glActiveTexture(GL_TEXTURE0 + mUnit);
	glBindTexture(GL_TEXTURE_2D, mTexture);

	glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, mWidth, mHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
}
```
那什么时候开始传输的
我们会将该附件绑定到`fbo`上，就像这样
```cpp
Framebuffer::Framebuffer(unsigned int width, unsigned int height) {
	...
	//2 生成颜色附件，并且加入fbo
	mColorAttachment = Texture::createColorAttachment(mWidth, mHeight, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, mColorAttachment->getTexture(), 0);

	//3 生成depth Stencil附件，加入fbo
	mDepthStencilAttachment = Texture::createDepthStencilAttachment(mWidth, mHeight, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, mDepthStencilAttachment->getTexture(), 0);

	...
}
```
此后我们在`main.cpp`进行渲染的时候，传入的是这个`fbo`的话，颜色和深度信息就会被赋值到这个贴图上了
```cpp
```cpp
int main() {
	...
	while (glApp->update()) {
		cameraControl->update();
		renderer->setClearColor(clearColor);
		//pass01
		renderer->render(sceneOffScreen, camera,dirLight, ambLight, fbo);
		//pass02
		renderer->render(sceneInScreen, camera, dirLight, ambLight);
		renderIMGUI();
	}

	glApp->destroy();

	return 0;
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyNDUwNzE2MjZdfQ==
-->