# 形状
```
uniform vec2 u_resolution; 
void main(){ 
	vec2 st = gl_FragCoord.xy/u_resolution.xy; 
	vec3 color = vec3(0.0); // Each result will return 1.0 (white) or 0.0 (black). 
	float left = step(0.1,st.x); // Similar to ( X greater than 0.1)
	float bottom = step(0.1,st.y); // Similar to ( Y greater than 0.1 )
	// The multiplication of left*bottom will be similar to the logical AND. 
	color = vec3( left * bottom ); 
	gl_FragColor = vec4(color,1.0); }
```
这一句 `vec3(left * bottom)` 的作用是根据 `left` 和 `bottom` 的计算结果，生成一个 RGB 颜色值，具体细节如下：

### 背景：

-   `left` 和 `bottom` 都是通过 `step()` 函数得到的，`step()` 是 GLSL 中的一个常用函数，用于判断一个值是否大于等于某个阈值。
    -   `left = step(0.1, st.x)`：判断 `st.x` 是否大于等于 `0.1`，如果是，则返回 `1.0`，否则返回 `0.0`。
    -   `bottom = step(0.1, st.y)`：判断 `st.y` 是否大于等于 `0.1`，如果是，则返回 `1.0`，否则返回 `0.0`。

### `left * bottom` 逻辑：

-   `left` 和 `bottom` 的值都是 `0.0` 或 `1.0`，它们的乘积会遵循逻辑 **AND** 的规则：
    -   当 `left` 和 `bottom` 都是 `1.0` 时，结果为 `1.0`，即颜色为白色。
    -   当 `left` 或 `bottom` 中有一个是 `0.0` 时，结果为 `0.0`，即颜色为黑色。

### `vec3(left * bottom)`：

-   `vec3()` 是构造一个 3 分量向量，在这里 `left * bottom` 的值被应用到 `RGB` 的每个分量上。
-   结果：
    -   如果 `left * bottom == 1.0`，则生成 `vec3(1.0, 1.0, 1.0)`，即白色。
    -   如果 `left * bottom == 0.0`，则生成 `vec3(0.0, 0.0, 0.0)`，即黑色。

### 总结：

-   `left * bottom` 只有当 `st.x >= 0.1` **并且** `st.y >= 0.1` 时才会为 `1.0`，否则为 `0.0`。
-   因此，`vec3(left * bottom)` 在左上角 `(0.0 <= st.x < 0.1, 0.0 <= st.y < 0.1)` 的区域为黑色，其余区域为白色，形成了一个区域判断的效果。

## 代码精简
在前一例代码中我们重复每个像素的结构（左边和底边）。我们可以把原来的一个值换成两个值直接给step（）来精减代码。就像这样：

```glsl
    vec2 borders = step(vec2(0.1),st);
    float pct = borders.x * borders.y;
```

## hui'zhi
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgyMjIzMzg1MCwtMTE5NzQ1MDUzNF19
-->