# 形状
```
uniform vec2 u_resolution; 
void main(){ 
	vec2 st = gl_FragCoord.xy/u_resolution.xy; 
	vec3 color = vec3(0.0); // Each result will return 1.0 (white) or 0.0 (black). 
	float left = step(0.1,st.x); // Similar to ( X greater than 0.1)
	float bottom = step(0.1,st.y); // Similar to ( Y greater than 0.1 )
	// The multiplication of left*bottom will be similar to the logical AND. 
	color = vec3( left * bottom ); 
	gl_FragColor = vec4(color,1.0); }
```
这一句 `vec3(left * bottom)` 的作用是根据 `left` 和 `bottom` 的计算结果，生成一个 RGB 颜色值，具体细节如下：

### 背景：

-   `left` 和 `bottom` 都是通过 `step()` 函数得到的，`step()` 是 GLSL 中的一个常用函数，用于判断一个值是否大于等于某个阈值。
    -   `left = step(0.1, st.x)`：判断 `st.x` 是否大于等于 `0.1`，如果是，则返回 `1.0`，否则返回 `0.0`。
    -   `bottom = step(0.1, st.y)`：判断 `st.y` 是否大于等于 `0.1`，如果是，则返回 `1.0`，否则返回 `0.0`。

### `left * bottom` 逻辑：

-   `left` 和 `bottom` 的值都是 `0.0` 或 `1.0`，它们的乘积会遵循逻辑 **AND** 的规则：
    -   当 `left` 和 `bottom` 都是 `1.0` 时，结果为 `1.0`，即颜色为白色。
    -   当 `left` 或 `bottom` 中有一个是 `0.0` 时，结果为 `0.0`，即颜色为黑色。

### `vec3(left * bottom)`：

-   `vec3()` 是构造一个 3 分量向量，在这里 `left * bottom` 的值被应用到 `RGB` 的每个分量上。
-   结果：
    -   如果 `left * bottom == 1.0`，则生成 `vec3(1.0, 1.0, 1.0)`，即白色。
    -   如果 `left * bottom == 0.0`，则生成 `vec3(0.0, 0.0, 0.0)`，即黑色。

### 总结：

-   `left * bottom` 只有当 `st.x >= 0.1` **并且** `st.y >= 0.1` 时才会为 `1.0`，否则为 `0.0`。
-   因此，`vec3(left * bottom)` 在左上角 `(0.0 <= st.x < 0.1, 0.0 <= st.y < 0.1)` 的区域为黑色，其余区域为白色，形成了一个区域判断的效果。

## 代码精简
在前一例代码中我们重复每个像素的结构（左边和底边）。我们可以把原来的一个值换成两个值直接给step（）来精减代码。就像这样：

```glsl
    vec2 borders = step(vec2(0.1),st);
    float pct = borders.x * borders.y;
```

## 绘制框
![输入图片说明](/imgs/2024-10-12/fjK78LvSNMM6eHgp.png)
```
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

void main(){
    vec2 st = gl_FragCoord.xy/u_resolution.xy;
    vec3 color = vec3(0.0);

    // bottom-left
    vec2 bl = step(vec2(0.1),st);
    float pct = bl.x * bl.y;

    // top-right
     vec2 tr = step(vec2(0.1),1.0-st);
     pct *= tr.x * tr.y;

    color = vec3(pct);

    gl_FragColor = vec4(color,1.0);
}
```

## 画圆
![输入图片说明](/imgs/2024-10-12/MEWMpEKMtGHIKFx0.png)
```
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

void main(){
	vec2 st = gl_FragCoord.xy/u_resolution;
    float pct = 0.0;

    // a. The DISTANCE from the pixel to the center
    pct = distance(st,vec2(0.5));

    // b. The LENGTH of the vector
    //    from the pixel to the center
    // vec2 toCenter = vec2(0.5)-st;
    // pct = length(toCenter);

    // c. The SQUARE ROOT of the vector
    //    from the pixel to the center
    // vec2 tC = vec2(0.5)-st;
    // pct = sqrt(tC.x*tC.x+tC.y*tC.y);

    vec3 color = vec3(pct);

	gl_FragColor = vec4( color, 1.0 );
}
```
-   **`vec3 color = vec3(pct);`**
    
    -   这里使用 `pct`（即当前片元到中心的距离）作为灰度值，构造 `vec3(pct)` 生成一个 RGB 颜色，其中 `R、G、B` 三个通道的值都相同，表示一个灰度颜色。
    -   因此，距离中心越近的片元，`pct` 越小，颜色越暗（接近黑色）；距离越远，`pct` 越大，颜色越亮（接近白色）。
-   **`gl_FragColor = vec4(color, 1.0);`**
    
    -   最终将颜色值 `color` 赋给片段着色器的输出 `gl_FragColor`，并将 `alpha`（透明度）设为 1.0，表示完全不透明。

## 画圆2.0
![输入图片说明](/imgs/2024-10-12/LhllKgX6452eBICM.png)
```
#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

float circle(in vec2 _st, in float _radius){
    vec2 dist = _st-vec2(0.5);
	return 1.-smoothstep(_radius-(_radius*0.01),
                         _radius+(_radius*0.01),
                         dot(dist,dist)*4.0);
}

void main(){
	vec2 st = gl_FragCoord.xy/u_resolution.xy;

	vec3 color = vec3(circle(st,0.9));

	gl_FragColor = vec4( color, 1.0 );
}
```

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5NDU5ODY5MDgsLTE5OTI4MTQ1OTMsLT
Y0MTE2NTA3MywtMTE5NzQ1MDUzNF19
-->