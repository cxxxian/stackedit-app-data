# 反射
Unreal 引擎中的 **反射（Reflection）** 是指：

> **运行时获取、检查和操作类、属性、函数等信息的能力**，即“程序能在运行时知道自己有哪些结构和成员，并对它们进行操作”。

在 C++ 原生语言里几乎**没有运行时反射**（不像 C# 或 Java），但 Unreal 实现了一套强大的反射系统，主要基于 `UObject` 和宏系统。

### Unreal 反射系统能做什么？

Unreal 的反射系统允许你：

-   在 **运行时** 获取类的名字、成员变量、函数列表
    
-   通过字符串访问属性（如 `SetPropertyByName("Health", 100)`）
    
-   把对象**序列化 / 反序列化**（如保存游戏、蓝图变量、编辑器设置）
    
-   暴露类/属性给 **蓝图、编辑器、网络、垃圾回收、序列化系统**
    
-   动态创建类对象（如 `NewObject<UYourClass>()`）

### Unreal 反射是如何实现的？

#### 1. 宏标记 + UCLASS / USTRUCT / UPROPERTY / UFUNCTION

```cpp
UCLASS()
class MYGAME_API UMyActor : public AActor
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    int32 Health;

    UFUNCTION(BlueprintCallable)
    void TakeDamage(int32 Amount);
};
```
这些宏不会被编译器直接处理，而是会触发 **Unreal Header Tool (UHT)** 在编译前生成反射元信息。

#### 2. 生成反射元信息（代码）

UHT 会生成一套结构，如：
```cpp
static const FClassRegisterCompiledInInfo ClassInfo[] = {
    // 类名、类类型、构造函数、字段描述等
};
```
这些数据被注册到 `UClass`, `UFunction`, `UProperty` 等系统里，提供运行时查询能力。

#### 示例：如何用反射获取属性名和修改值
```cpp
UProperty* Prop = FindField<UProperty>(MyActor->GetClass(), "Health");
void* PropAddr = Prop->ContainerPtrToValuePtr<void>(MyActor);
int32* HealthPtr = (int32*)PropAddr;
*HealthPtr = 200;
```
你可以在运行时通过名字访问类成员，这就是反射。

### 常用的反射宏

宏

用途

`UCLASS()`

标记一个类可反射

`USTRUCT()`

标记一个结构体可反射

`UPROPERTY()`

暴露一个属性给引擎（编辑器/蓝图/GC）

`UFUNCTION()`

暴露一个函数给蓝图/网络等

`GENERATED_BODY()`

自动生成类的反射元信息代码
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTgyMzg3MTIzNF19
-->