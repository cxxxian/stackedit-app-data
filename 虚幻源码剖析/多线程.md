# c++多线程
`join`
加入主线程，使得主线程强制等待该线程执行完。
`detach`
从主线程分离，使得主线程无需等待该线程执行完。
`swap`
与另外一个线程交换线程对象。
`joinable`
查询是否可加入主线程。
`get_id`
获取该线程的唯一标识符。
`native_handle`
返回实现层的线程句柄。
`hardware_concurrency`
静态接口，返回硬件支持的并发线程数量。


使用范例：

```c++
#include <iostream>
#include <thread>
#include <chrono>

void foo()
{
    // simulate expensive operation
    std::this_thread::sleep_for(std::chrono::seconds(1));
}
 
int main()
{
    std::cout << "starting thread...\n";
    std::thread t(foo); // 构造线程对象，且传入被执行的函数。
 
    std::cout << "waiting for thread to finish..." << std::endl;
    t.join(); // 加入主线程，使得主线程必须等待该线程执行完毕。
 
    std::cout << "done!\n";
}
```
简单来说就是将子线程加入主线程，然后主线程必须等待该线程执行完毕

输出：

```cpp
starting thread...
waiting for thread to finish...
done!
```

如果需要在调用线程和新线程之间同步数据，则可以使用C++的`std::promise`和`std::future`等机制。
示例代码：

```c++
#include <vector>
#include <thread>
#include <future>
#include <numeric>
#include <iostream>
 
void accumulate(std::vector<int>::iterator first,
                std::vector<int>::iterator last,
                std::promise<int> accumulate_promise)
{
    int sum = std::accumulate(first, last, 0);
    accumulate_promise.set_value(sum);  // Notify future
}
 
int main()
{
    // Demonstrate using promise<int> to transmit a result between threads.
    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };
    std::promise<int> accumulate_promise;
    std::future<int> accumulate_future = accumulate_promise.get_future();
    std::thread work_thread(accumulate, numbers.begin(), numbers.end(),
                            std::move(accumulate_promise));
 
    // future::get() will wait until the future has a valid result and retrieves it.
    // Calling wait() before get() is not needed
    //accumulate_future.wait();  // wait for result
    std::cout << "result = " << accumulate_future.get() << '\n';
    work_thread.join();  // wait for thread completion
}
```
和`join`的一个很明显的区别就是，`promise`和`future`配合可以返回结果，`join`不行

输出结果：
```ini
result = 21
```

如果需要强制异步，则可使用`std::async`。它可以指定两种异步方式：`std::launch::async`和`std::launch::deferred`，前者表示使用新的线程异步地执行任务，后者表示在当前线程执行，且会被延迟执行。使用范例：

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <future>
#include <string>
#include <mutex>
 
std::mutex m;
struct X {
    void foo(int i, const std::string& str) {
        std::lock_guard<std::mutex> lk(m);
        std::cout << str << ' ' << i << '\n';
    }
    void bar(const std::string& str) {
        std::lock_guard<std::mutex> lk(m);
        std::cout << str << '\n';
    }
    int operator()(int i) {
        std::lock_guard<std::mutex> lk(m);
        std::cout << i << '\n';
        return i + 10;
    }
};
 
template <typename RandomIt>
int parallel_sum(RandomIt beg, RandomIt end)
{
    auto len = end - beg;
    if (len < 1000)
        return std::accumulate(beg, end, 0);
 
    RandomIt mid = beg + len/2;
    auto handle = std::async(std::launch::async,
                             parallel_sum<RandomIt>, mid, end);
    int sum = parallel_sum(beg, mid);
    return sum + handle.get();
}
 
int main()
{
    std::vector<int> v(10000, 1);
    std::cout << "The sum is " << parallel_sum(v.begin(), v.end()) << '\n';
 
    X x;
    // Calls (&x)->foo(42, "Hello") with default policy:
    // may print "Hello 42" concurrently or defer execution
    auto a1 = std::async(&X::foo, &x, 42, "Hello");
    // Calls x.bar("world!") with deferred policy
    // prints "world!" when a2.get() or a2.wait() is called
    auto a2 = std::async(std::launch::deferred, &X::bar, x, "world!");
    // Calls X()(43); with async policy
    // prints "43" concurrently
    auto a3 = std::async(std::launch::async, X(), 43);
    a2.wait();                     // prints "world!"
    std::cout << a3.get() << '\n'; // prints "53"
} // if a1 is not done at this point, destructor of a1 prints "Hello 42" here
```

执行结果：

```python
The sum is 10000
43
Hello 42
world!
53
```

可以捋一下这个输出顺序：
```cpp
std::vector<int> v(10000, 1);
std::cout << "The sum is " << parallel_sum(v.begin(), v.end()) << '\n';
```
这里调用 `parallel_sum`，它内部调用`std::launch::async`所以会立马执行


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTk3MTI1NTMzMSw4NzY4MTIwODRdfQ==
-->