# c++多线程
`join`
加入主线程，使得主线程强制等待该线程执行完。
`detach`
从主线程分离，使得主线程无需等待该线程执行完。
`swap`
与另外一个线程交换线程对象。
`joinable`
查询是否可加入主线程。
`get_id`
获取该线程的唯一标识符。
`native_handle`
返回实现层的线程句柄。
`hardware_concurrency`
静态接口，返回硬件支持的并发线程数量。


使用范例：

```c++
#include <iostream>
#include <thread>
#include <chrono>

void foo()
{
    // simulate expensive operation
    std::this_thread::sleep_for(std::chrono::seconds(1));
}
 
int main()
{
    std::cout << "starting thread...\n";
    std::thread t(foo); // 构造线程对象，且传入被执行的函数。
 
    std::cout << "waiting for thread to finish..." << std::endl;
    t.join(); // 加入主线程，使得主线程必须等待该线程执行完毕。
 
    std::cout << "done!\n";
}
```
简单来说就是将子线程加入主线程，然后主线程必须等待该线程执行完毕

输出：

```cpp
starting thread...
waiting for thread to finish...
done!
```

如果需要在调用线程和新线程之间同步数据，则可以使用C++的`std::promise`和`std::future`等机制。
示例代码：

```c++
#include <vector>
#include <thread>
#include <future>
#include <numeric>
#include <iostream>
 
void accumulate(std::vector<int>::iterator first,
                std::vector<int>::iterator last,
                std::promise<int> accumulate_promise)
{
    int sum = std::accumulate(first, last, 0);
    accumulate_promise.set_value(sum);  // Notify future
}
 
int main()
{
    // Demonstrate using promise<int> to transmit a result between threads.
    std::vector<int> numbers = { 1, 2, 3, 4, 5, 6 };
    std::promise<int> accumulate_promise;
    std::future<int> accumulate_future = accumulate_promise.get_future();
    std::thread work_thread(accumulate, numbers.begin(), numbers.end(),
                            std::move(accumulate_promise));
 
    // future::get() will wait until the future has a valid result and retrieves it.
    // Calling wait() before get() is not needed
    //accumulate_future.wait();  // wait for result
    std::cout << "result = " << accumulate_future.get() << '\n';
    work_thread.join();  // wait for thread completion
}
```
和`join`的一个很明显的区别就是，`promise`和`future`配合可以返回结果，``
输出结果：

```ini
result = 21
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQ0MDU5OTY0XX0=
-->